.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Realize::Later 3"
.TH Object::Realize::Later 3 "2014-01-24" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Realize::Later \- Delayed creation of objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package MyLazyObject;
\&
\& use Object::Realize::Later
\&    becomes => \*(AqMyRealObject\*(Aq,
\&    realize => \*(Aqload\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Object::Realize::Later\*(C'\fR class helps with implementing transparent
on demand realization of object data.  This is related to the tricks
on autoloading of data, the lesser known cousin of autoloading of
functionality.
.PP
On demand realization is all about performance gain.  Why should you
spent costly time on realizing an object, when the data on the object is
never (or not yet) used?  In interactive programs, postponed realization
may boost start-up: the realization of objects is triggered by the
use, so spread over time.
.SH "METHODS"
.IX Header "METHODS"
.SS "Construction"
.IX Subsection "Construction"
.ie n .IP "\fBuse\fR(Object::Realize::Later %options)" 4
.el .IP "\fBuse\fR(Object::Realize::Later \f(CW%options\fR)" 4
.IX Item "use(Object::Realize::Later %options)"
When you invoke (\f(CW\*(C`use\*(C'\fR) the \f(CW\*(C`Object::Realize::Later\*(C'\fR package, it will
add a set of methods to your package (see section \*(L"Added to \s-1YOUR\s0 class\*(R").
.Sp
.Vb 7
\& \-Option            \-\-Default
\&  becomes             <required>
\&  believe_caller      <false>
\&  realize             <required>
\&  source_module       <becomes>
\&  warn_realization    <false>
\&  warn_realize_again  <false>
.Ve
.RS 4
.IP "becomes => \s-1CLASS\s0" 2
.IX Item "becomes => CLASS"
Which type will this object become after realization.
.IP "believe_caller => \s-1BOOLEAN\s0" 2
.IX Item "believe_caller => BOOLEAN"
When a method is called on the un-realized object, the \s-1AUTOLOAD\s0
checks whether this resolves the need.  If not, the realization is
not done.  However, when realization may result in an object that
extends the functionality of the class specified with \f(CW\*(C`becomes\*(C'\fR,
this check must be disabled.  In that case, specify true for
this option.
.IP "realize => METHOD|CODE" 2
.IX Item "realize => METHOD|CODE"
How will transform.  If you specify a \s-1CODE\s0 reference, then this will be
called with the lazy-object as first argument, and the requested method
as second.
.Sp
After realization, you may still have your hands on the lazy object
on various places.  Be sure that your realization method is coping
with that, for instance by using Memoize.  See examples below.
.IP "source_module => \s-1CLASS\s0" 2
.IX Item "source_module => CLASS"
if the class (a package) is included in a file (module) with a different
name, then use this argument to specify the file name. The name is
expected to be the same as in the \f(CW\*(C`require\*(C'\fR call which would load it.
.IP "warn_realization => \s-1BOOLEAN\s0" 2
.IX Item "warn_realization => BOOLEAN"
Print a warning message when the realization starts.  This is for
debugging purposes.
.IP "warn_realize_again => \s-1BOOLEAN\s0" 2
.IX Item "warn_realize_again => BOOLEAN"
When an object is realized, the original object \-which functioned
as a stub\- is reconstructed to work as proxy to the realized object.
This option will issue a warning when that proxy is used, which means
that somewhere in your program there is a variable still holding a
reference to the stub.  This latter is not problematic at all, although
it slows-down each method call.
.RE
.RS 4
.RE
.SS "Added to \s-1YOUR\s0 class"
.IX Subsection "Added to YOUR class"
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
When a method is called which is not available for the lazy object, the
\&\s-1AUTOLOAD\s0 is called.
.ie n .IP "$obj\->\fBcan\fR($method)" 4
.el .IP "\f(CW$obj\fR\->\fBcan\fR($method)" 4
.IX Item "$obj->can($method)"
.PD 0
.IP "Object::Realize::Later\->\fBcan\fR($method)" 4
.IX Item "Object::Realize::Later->can($method)"
.PD
Is the specified \f(CW$method\fR available for the lazy or the realized version
of this object?  It will return the reference to the code.
.Sp
example:
.Sp
.Vb 2
\&   MyLazyObject\->can(\*(AqlazyWork\*(Aq)      # true
\&   MyLazyObject\->can(\*(AqrealWork\*(Aq)      # true
\&
\&   my $lazy = MyLazyObject\->new;
\&   $lazy\->can(\*(AqlazyWork\*(Aq);            # true
\&   $lazy\->can(\*(AqrealWork\*(Aq);            # true
.Ve
.ie n .IP "$obj\->\fBforceRealize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBforceRealize\fR()" 4
.IX Item "$obj->forceRealize()"
You can force the load by calling this method on your object.  It returns
the realized object.
.IP "Object::Realize::Later\->\fBisa\fR($class)" 4
.IX Item "Object::Realize::Later->isa($class)"
Is this object a (sub\-)class of the specified \f(CW$class\fR or can it become a
(sub\-)class of \f(CW$class\fR.
.Sp
example:
.Sp
.Vb 3
\& MyLazyObject\->isa(\*(AqMyRealObject\*(Aq)      # true
\& MyLazyObject\->isa(\*(AqSuperClassOfLazy\*(Aq); # true
\& MyLazyObject\->isa(\*(AqSuperClassOfReal\*(Aq); # true
\&
\& my $lazy = MyLazyObject\->new;
\& $lazy\->isa(\*(AqMyRealObject\*(Aq);            # true
\& $lazy\->isa(\*(AqSuperClassOfLazy\*(Aq);        # true
\& $lazy\->isa(\*(AqSuperClassOfReal\*(Aq);        # true
.Ve
.ie n .IP "$obj\->\fBwillRealize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwillRealize\fR()" 4
.IX Item "$obj->willRealize()"
Returns which class will be the realized to follow-up this class.
.SS "Object::Realize::Later internals"
.IX Subsection "Object::Realize::Later internals"
The next methods are not exported to the class where the `use' took
place.  These methods implement the actual realization.
.IP "Object::Realize::Later\->\fBimport\fR(%options)" 4
.IX Item "Object::Realize::Later->import(%options)"
The \f(CW%options\fR used for \f(CW\*(C`import\*(C'\fR are the values after the class name
with \f(CW\*(C`use\*(C'\fR.  So this routine implements the actual option parsing.
It generates code dynamically, which is then evaluated in the
callers name-space.
.ie n .IP "Object::Realize::Later\->\fBrealizationOf\fR( $object, [$realized] )" 4
.el .IP "Object::Realize::Later\->\fBrealizationOf\fR( \f(CW$object\fR, [$realized] )" 4
.IX Item "Object::Realize::Later->realizationOf( $object, [$realized] )"
Returns the \f(CW$realized\fR version of \f(CW$object\fR, optionally after setting it
first.  When the method returns \f(CW\*(C`undef\*(C'\fR, the realization has not
yet taken place or the realized object has already been removed again.
.IP "Object::Realize::Later\->\fBrealize\fR(%options)" 4
.IX Item "Object::Realize::Later->realize(%options)"
This method is called when a \f(CW\*(C`$object\-\*(C'\fR\fIforceRealize()\fR> takes
place.  It checks whether the realization has been done already
(is which case the realized object is returned)
.SH "DETAILS"
.IX Header "DETAILS"
.SS "About lazy loading"
.IX Subsection "About lazy loading"
There are two ways to implement lazy behaviour: you may choose to check
whether you have realized the data in each method which accesses the data,
or use the autoloading of data trick.
.PP
An implementation of the first solution is:
.PP
.Vb 3
\& sub realize {
\&     my $self = shift;
\&     return $self unless $self\->{_is_realized};
\&
\&     # read the data from file, or whatever
\&     $self\->{data} = ....;
\&
\&     $self\->{_is_realized} = 1;
\&     $self;
\& }
\&
\& sub getData() {
\&     my $self = shift;
\&     return $self\->realize\->{data};
\& }
.Ve
.PP
The above implementation is error-prone, where you can easily forget to
call \fIrealize()\fR.  The tests cannot cover all ordenings of method-calls to
detect the mistakes.
.PP
The \fIsecond approach\fR uses autoloading, and is supported by this package.
First we create a stub-object, which will be transformable into a
realized object later.  This transformation is triggered by \s-1AUTOLOAD\s0.
.PP
This stub-object may contain some methods from the realized object,
to reduce the need for realization.  The stub will also contain some
information which is required for the creation of the real object.
.PP
\&\f(CW\*(C`Object::Realize::Later\*(C'\fR solves the inheritance problems (especially
the \fIisa()\fR and \fIcan()\fR methods) and supplies the \s-1AUTOLOAD\s0 method.
Class methods which are not defined in the stub object are forwarded
as class methods without realization.
.SS "Traps"
.IX Subsection "Traps"
Be aware of dangerous traps in the current implementation.  These
problems appear by having multiple references to the same delayed
object.  Depending on how the realization is implemented, terrible
things can happen.
.PP
The two versions of realization:
.IP "\(bu" 4
by reblessing
.Sp
This is the safe version.  The realized object is the same object as
the delayed one, but reblessed in a different package.  When multiple
references to the delayed object exists, they will all be updated
at the same, because the bless information is stored within the
refered variable.
.IP "\(bu" 4
by new instance
.Sp
This is the nicest way of realization, but also quite more dangerous.
Consider this:
.Sp
.Vb 4
\& package Delayed;
\& use Object::Realize::Later
\&      becomes => \*(AqRealized\*(Aq,
\&      realize => \*(Aqload\*(Aq;
\&
\& sub new($)      {my($class,$v)=@_; bless {label=>$v}, $class}
\& sub setLabel($) {my $self = shift; $self\->{label} = shift}
\& sub load()      {$_[0] = Realized\->new($_[0]\->{label}) }
\&
\& package Realized;  # file Realized.pm or use use(source_module)
\& sub new($)      {my($class,$v)=@_; bless {label=>$v}, $class}
\& sub setLabel($) {my $self = shift; $self\->{label} = shift}
\& sub getLabel()  {my $self = shift; $self\->{label}}
\&
\& package main;
\& my $original = Delayed\->new(\*(Aqoriginal\*(Aq);
\& my $copy     = $original;
\& print $original\->getLabel;     # prints \*(Aqoriginal\*(Aq
\& print ref $original;           # prints \*(AqRealized\*(Aq
\& print ref $copy;               # prints \*(AqDelayed\*(Aq
\& $original\->setLabel(\*(Aqchanged\*(Aq);
\& print $original\->getLabel;     # prints \*(Aqchanged\*(Aq
\& print $copy\->getLabel;         # prints \*(Aqoriginal\*(Aq
.Ve
.SS "Examples"
.IX Subsection "Examples"
\fIExample 1\fR
.IX Subsection "Example 1"
.PP
In the first example, we delay-load a message.  On the moment the
message is defined, we only take the location.  When the data of the
message is taken (header or body), the data is autoloaded.
.PP
.Vb 1
\& package Mail::Message::Delayed;
\&
\& use Object::Realize::Later
\&   ( becomes => \*(AqMail::Message::Real\*(Aq
\&   , realize => \*(AqloadMessage\*(Aq
\&   );
\&
\& sub new($) {
\&     my ($class, $file) = @_;
\&     bless { filename => $file }, $class;
\& }
\&
\& sub loadMessage() {
\&     my $self = shift;
\&     Mail::Message::Real\->new($self\->{filename});
\& }
.Ve
.PP
In the main program:
.PP
.Vb 2
\& package main;
\& use Mail::Message::Delayed;
\&
\& my $msg    = Mail::Message::Delayed\->new(\*(Aq/home/user/mh/1\*(Aq);
\& $msg\->body\->print;     # this will trigger autoload.
.Ve
.PP
\fIExample 2\fR
.IX Subsection "Example 2"
.PP
Your realization may also be done by reblessing.  In that case to change the
type of your object into a different type which stores the same information.
Is that right?  Are you sure?  For simple cases, this may be possible:
.PP
.Vb 4
\& package Alive;
\& use Object::Realize::Later
\&      becomes => \*(AqDead\*(Aq,
\&      realize => \*(Aqkill\*(Aq;
\&
\& sub new()         {my $class = shift; bless {@_}, $class}
\& sub jump()        {print "Jump!\en"}
\& sub showAntlers() {print "Fight!\en"}
\& sub kill()        {bless(shift, \*(AqDead\*(Aq)}
\&
\& package Dead;
\& sub takeAntlers() {...}
.Ve
.PP
In the main program:
.PP
.Vb 2
\& my $deer   = Alive\->new(Animal => \*(Aqdeer\*(Aq);
\& my $trophy = $deer\->takeAntlers();
.Ve
.PP
In this situation, the object (reference) is not changed but is \fIreblessed\fR.
There is no danger that the un-realized version of the object is kept
somewhere: all variable which know about this partical \fIdeer\fR see the
change.
.PP
\fIExample 3\fR
.IX Subsection "Example 3"
.PP
This module is especially usefull for larger projects, which there is
a need for speed or memory reduction. In this case, you may have an
extra overview on which objects have been realized (transformed), and
which not.  This example is taken from the MailBox modules:
.PP
The Mail::Box module tries to boost the access-time to a folder.
If you only need the messages of the last day, why shall all be read?
So, MailBox only creates an invertory of messages at first.  It
takes the headers of all messages, but leaves the body (content) of
the message in the file.
.PP
In MailBox' case, the Mail::Message\-object has the choice
between a number of Mail::Message::Body's, one of which has only
be prepared to read the body when needed.  A code snippet:
.PP
.Vb 8
\& package Mail::Message;
\& sub new($$)
\& {   my ($class, $head, $body) = @_;
\&     my $self = bless {head => $head, body => $body}, $class;
\&     $body\->message($self);          # tell body about the message
\& }
\& sub head()     { shift\->{head} }
\& sub body()     { shift\->{body} }
\&
\& sub loadBody()
\& {   my $self = shift;
\&     my $body = $self\->body;
\&
\&     # Catch re\-invocations of the loading.  If anywhere was still
\&     # a reference to the old (unrealized) body of this message, we
\&     # return the new\-one directly.
\&     return $body unless $body\->can(\*(AqforceRealize\*(Aq);
\&
\&     # Load the body (change it to anything which really is of
\&     # the promised type, or a sub\-class of it.
\&     my ($lines, $size) = .......;    # get the data
\&     $self\->{body} = Mail::Message::Body::Lines
\&                          \->new($lines, $size, $self);
\&
\&     # Return the realized object.
\&     return $self\->{body};
\& }
\&
\& package Mail::Message::Body::Lines;
\& use base \*(AqMail::Message::Body\*(Aq;
\&
\& sub new($$$)
\& {   my ($class, $lines, $size, $message) = @_;
\&     bless { lines => $lines, size => $size
\&           , message => $message }, $class;
\& }
\& sub size()    { shift\->{size} }
\& sub lines()   { shift\->{lines} }
\& sub message() { shift\->{message);
\&
\& package Mail::Message::Body::Delayed;
\& use Object::Realize::Later
\&     becomes => \*(AqMail::Message::Body\*(Aq,
\&     realize => sub {shift\->message\->loadBody};
\&
\& sub new($)
\& {   my ($class, $size) = @_;
\&     bless {size => $size}, $class;
\& }
\& sub size() { shift\->{size} }
\& sub message(;$)
\& {   my $self = shift;
\&     @_ ? ($self\->{message} = shift) : $self\->{messages};
\& }
\&
\& package main;
\& use Mail::Message;
\& use Mail::Message::Body::Delayed;
\&
\& my $body    = Mail::Message::Body::Delayed\->new(42);
\& my $message = Mail::Message\->new($head, $body);
\&
\& print $message\->size;         # will not trigger realization!
\& print $message\->can(\*(Aqlines\*(Aq); # true, but no realization yet.
\& print $message\->lines;        # realizes automatically.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Object-Realize-Later distribution version 0.19,
built on January 24, 2014. Website: \fIhttp://perl.overmeer.net/orl/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2014 by [Mark Overmeer <perl@overmeer.net>]. For other contributors see Changes.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
