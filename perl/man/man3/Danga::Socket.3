.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Danga::Socket 3"
.TH Danga::Socket 3 "2008-11-28" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Danga::Socket \- Event loop and event\-driven async socket base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  package My::Socket
\&  use Danga::Socket;
\&  use base (\*(AqDanga::Socket\*(Aq);
\&  use fields (\*(Aqmy_attribute\*(Aq);
\&
\&  sub new {
\&     my My::Socket $self = shift;
\&     $self = fields::new($self) unless ref $self;
\&     $self\->SUPER::new( @_ );
\&
\&     $self\->{my_attribute} = 1234;
\&     return $self;
\&  }
\&
\&  sub event_err { ... }
\&  sub event_hup { ... }
\&  sub event_write { ... }
\&  sub event_read { ... }
\&  sub close { ... }
\&
\&  $my_sock\->tcp_cork($bool);
\&
\&  # write returns 1 if all writes have gone through, or 0 if there
\&  # are writes in queue
\&  $my_sock\->write($scalar);
\&  $my_sock\->write($scalarref);
\&  $my_sock\->write(sub { ... });  # run when previous data written
\&  $my_sock\->write(undef);        # kick\-starts
\&
\&  # read max $bytecount bytes, or undef on connection closed
\&  $scalar_ref = $my_sock\->read($bytecount);
\&
\&  # watch for writability.  not needed with \->write().  write()
\&  # will automatically turn on watch_write when you wrote too much
\&  # and turn it off when done
\&  $my_sock\->watch_write($bool);
\&
\&  # watch for readability
\&  $my_sock\->watch_read($bool);
\&
\&  # if you read too much and want to push some back on
\&  # readable queue.  (not incredibly well\-tested)
\&  $my_sock\->push_back_read($buf); # scalar or scalar ref
\&
\&  Danga::Socket\->AddOtherFds(..);
\&  Danga::Socket\->SetLoopTimeout($millisecs);
\&  Danga::Socket\->DescriptorMap();
\&  Danga::Socket\->WatchedSockets();  # count of DescriptorMap keys
\&  Danga::Socket\->SetPostLoopCallback($code);
\&  Danga::Socket\->EventLoop();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an abstract base class for objects backed by a socket which
provides the basic framework for event-driven asynchronous \s-1IO\s0,
designed to be fast.  Danga::Socket is both a base class for objects,
and an event loop.
.PP
Callers subclass Danga::Socket.  Danga::Socket's constructor registers
itself with the Danga::Socket event loop, and invokes callbacks on the
object for readability, writability, errors, and other conditions.
.PP
Because Danga::Socket uses the \*(L"fields\*(R" module, your subclasses must
too.
.SH "MORE INFO"
.IX Header "MORE INFO"
For now, see servers using Danga::Socket for guidance.  For example:
perlbal, mogilefsd, or ddlockd.
.SH "API"
.IX Header "API"
Note where "\f(CW\*(C`CLASS\*(C'\fR" is used below, normally you would call these methods as:
.PP
.Vb 1
\&  Danga::Socket\->method(...);
.Ve
.PP
However using a subclass works too.
.PP
The \s-1CLASS\s0 methods are all methods for the event loop part of Danga::Socket,
whereas the object methods are all used on your subclasses.
.ie n .SS """CLASS\->Reset()"""
.el .SS "\f(CWCLASS\->Reset()\fP"
.IX Subsection "CLASS->Reset()"
Reset all state
.ie n .SS """CLASS\->HaveEpoll()"""
.el .SS "\f(CWCLASS\->HaveEpoll()\fP"
.IX Subsection "CLASS->HaveEpoll()"
Returns a true value if this class will use IO::Epoll for async \s-1IO\s0.
.ie n .SS """CLASS\->WatchedSockets()"""
.el .SS "\f(CWCLASS\->WatchedSockets()\fP"
.IX Subsection "CLASS->WatchedSockets()"
Returns the number of file descriptors which are registered with the global
poll object.
.ie n .SS """CLASS\->EnableProfiling()"""
.el .SS "\f(CWCLASS\->EnableProfiling()\fP"
.IX Subsection "CLASS->EnableProfiling()"
Turns profiling on, clearing current profiling data.
.ie n .SS """CLASS\->DisableProfiling()"""
.el .SS "\f(CWCLASS\->DisableProfiling()\fP"
.IX Subsection "CLASS->DisableProfiling()"
Turns off profiling, but retains data up to this point
.ie n .SS """CLASS\->ProfilingData()"""
.el .SS "\f(CWCLASS\->ProfilingData()\fP"
.IX Subsection "CLASS->ProfilingData()"
Returns reference to a hash of data in format:
.PP
.Vb 1
\&  ITEM => [ utime, stime, #calls ]
.Ve
.ie n .SS """CLASS\->ToClose()"""
.el .SS "\f(CWCLASS\->ToClose()\fP"
.IX Subsection "CLASS->ToClose()"
Return the list of sockets that are awaiting \fIclose()\fR at the end of the
current event loop.
.ie n .SS """CLASS\->OtherFds( [%fdmap] )"""
.el .SS "\f(CWCLASS\->OtherFds( [%fdmap] )\fP"
.IX Subsection "CLASS->OtherFds( [%fdmap] )"
Get/set the hash of file descriptors that need processing in parallel with
the registered Danga::Socket objects.
.ie n .SS """CLASS\->AddOtherFds( [%fdmap] )"""
.el .SS "\f(CWCLASS\->AddOtherFds( [%fdmap] )\fP"
.IX Subsection "CLASS->AddOtherFds( [%fdmap] )"
Add fds to the OtherFds hash for processing.
.ie n .SS """CLASS\->SetLoopTimeout( $timeout )"""
.el .SS "\f(CWCLASS\->SetLoopTimeout( $timeout )\fP"
.IX Subsection "CLASS->SetLoopTimeout( $timeout )"
Set the loop timeout for the event loop to some value in milliseconds.
.PP
A timeout of 0 (zero) means poll forever. A timeout of \-1 means poll and return
immediately.
.ie n .SS """CLASS\->DebugMsg( $format, @args )"""
.el .SS "\f(CWCLASS\->DebugMsg( $format, @args )\fP"
.IX Subsection "CLASS->DebugMsg( $format, @args )"
Print the debugging message specified by the \f(CW\*(C`sprintf\*(C'\fR\-style \fIformat\fR and
\&\fIargs\fR
.ie n .SS """CLASS\->AddTimer( $seconds, $coderef )"""
.el .SS "\f(CWCLASS\->AddTimer( $seconds, $coderef )\fP"
.IX Subsection "CLASS->AddTimer( $seconds, $coderef )"
Add a timer to occur \f(CW$seconds\fR from now. \f(CW$seconds\fR may be fractional, but timers
are not guaranteed to fire at the exact time you ask for.
.PP
Returns a timer object which you can call \f(CW\*(C`$timer\->cancel\*(C'\fR on if you need to.
.ie n .SS """CLASS\->DescriptorMap()"""
.el .SS "\f(CWCLASS\->DescriptorMap()\fP"
.IX Subsection "CLASS->DescriptorMap()"
Get the hash of Danga::Socket objects keyed by the file descriptor (fileno) they
are wrapping.
.PP
Returns a hash in list context or a hashref in scalar context.
.ie n .SS """CLASS\->EventLoop()"""
.el .SS "\f(CWCLASS\->EventLoop()\fP"
.IX Subsection "CLASS->EventLoop()"
Start processing \s-1IO\s0 events. In most daemon programs this never exits. See
\&\f(CW\*(C`PostLoopCallback\*(C'\fR below for how to exit the loop.
.ie n .SS """CLASS\->SetPostLoopCallback( CODEREF )"""
.el .SS "\f(CWCLASS\->SetPostLoopCallback( CODEREF )\fP"
.IX Subsection "CLASS->SetPostLoopCallback( CODEREF )"
Sets post loop callback function.  Pass a subref and it will be
called every time the event loop finishes.
.PP
Return 1 (or any true value) from the sub to make the loop continue, 0 or false
and it will exit.
.PP
The callback function will be passed two parameters: \e%DescriptorMap, \e%OtherFds.
.SS "\s-1OBJECT\s0 \s-1METHODS\s0"
.IX Subsection "OBJECT METHODS"
.ie n .SS """CLASS\->new( $socket )"""
.el .SS "\f(CWCLASS\->new( $socket )\fP"
.IX Subsection "CLASS->new( $socket )"
Create a new Danga::Socket subclass object for the given \fIsocket\fR which will
react to events on it during the \f(CW\*(C`EventLoop\*(C'\fR.
.PP
This is normally (always?) called from your subclass via:
.PP
.Vb 1
\&  $class\->SUPER::new($socket);
.Ve
.ie n .SS """$obj\->tcp_cork( $boolean )"""
.el .SS "\f(CW$obj\->tcp_cork( $boolean )\fP"
.IX Subsection "$obj->tcp_cork( $boolean )"
Turn \s-1TCP_CORK\s0 on or off depending on the value of \fIboolean\fR.
.ie n .SS """$obj\->steal_socket()"""
.el .SS "\f(CW$obj\->steal_socket()\fP"
.IX Subsection "$obj->steal_socket()"
Basically returns our socket and makes it so that we don't try to close it,
but we do remove it from epoll handlers.  \s-1THIS\s0 \s-1CLOSES\s0 \f(CW$self\fR.  It is the same
thing as calling close, except it gives you the socket to use.
.ie n .SS """$obj\->close( [$reason] )"""
.el .SS "\f(CW$obj\->close( [$reason] )\fP"
.IX Subsection "$obj->close( [$reason] )"
Close the socket. The \fIreason\fR argument will be used in debugging messages.
.ie n .SS """$obj\->sock()"""
.el .SS "\f(CW$obj\->sock()\fP"
.IX Subsection "$obj->sock()"
Returns the underlying IO::Handle for the object.
.ie n .SS """$obj\->set_writer_func( CODEREF )"""
.el .SS "\f(CW$obj\->set_writer_func( CODEREF )\fP"
.IX Subsection "$obj->set_writer_func( CODEREF )"
Sets a function to use instead of \f(CW\*(C`syswrite()\*(C'\fR when writing data to the socket.
.ie n .SS """$obj\->write( $data )"""
.el .SS "\f(CW$obj\->write( $data )\fP"
.IX Subsection "$obj->write( $data )"
Write the specified data to the underlying handle.  \fIdata\fR may be scalar,
scalar ref, code ref (to run when there), or undef just to kick-start.
Returns 1 if writes all went through, or 0 if there are writes in queue. If
it returns 1, caller should stop waiting for 'writable' events)
.ie n .SS """$obj\->push_back_read( $buf )"""
.el .SS "\f(CW$obj\->push_back_read( $buf )\fP"
.IX Subsection "$obj->push_back_read( $buf )"
Push back \fIbuf\fR (a scalar or scalarref) into the read stream. Useful if you read
more than you need to and want to return this data on the next \*(L"read\*(R".
.ie n .SS """$obj\->read( $bytecount )"""
.el .SS "\f(CW$obj\->read( $bytecount )\fP"
.IX Subsection "$obj->read( $bytecount )"
Read at most \fIbytecount\fR bytes from the underlying handle; returns scalar
ref on read, or undef on connection closed.
.ie n .SS "(\s-1VIRTUAL\s0) ""$obj\->event_read()"""
.el .SS "(\s-1VIRTUAL\s0) \f(CW$obj\->event_read()\fP"
.IX Subsection "(VIRTUAL) $obj->event_read()"
Readable event handler. Concrete deriviatives of Danga::Socket should
provide an implementation of this. The default implementation will die if
called.
.ie n .SS "(\s-1VIRTUAL\s0) ""$obj\->event_err()"""
.el .SS "(\s-1VIRTUAL\s0) \f(CW$obj\->event_err()\fP"
.IX Subsection "(VIRTUAL) $obj->event_err()"
Error event handler. Concrete deriviatives of Danga::Socket should
provide an implementation of this. The default implementation will die if
called.
.ie n .SS "(\s-1VIRTUAL\s0) ""$obj\->event_hup()"""
.el .SS "(\s-1VIRTUAL\s0) \f(CW$obj\->event_hup()\fP"
.IX Subsection "(VIRTUAL) $obj->event_hup()"
\&'Hangup' event handler. Concrete deriviatives of Danga::Socket should
provide an implementation of this. The default implementation will die if
called.
.ie n .SS """$obj\->event_write()"""
.el .SS "\f(CW$obj\->event_write()\fP"
.IX Subsection "$obj->event_write()"
Writable event handler. Concrete deriviatives of Danga::Socket may wish to
provide an implementation of this. The default implementation calls
\&\f(CW\*(C`write()\*(C'\fR with an \f(CW\*(C`undef\*(C'\fR.
.ie n .SS """$obj\->watch_read( $boolean )"""
.el .SS "\f(CW$obj\->watch_read( $boolean )\fP"
.IX Subsection "$obj->watch_read( $boolean )"
Turn 'readable' event notification on or off.
.ie n .SS """$obj\->watch_write( $boolean )"""
.el .SS "\f(CW$obj\->watch_write( $boolean )\fP"
.IX Subsection "$obj->watch_write( $boolean )"
Turn 'writable' event notification on or off.
.ie n .SS """$obj\->dump_error( $message )"""
.el .SS "\f(CW$obj\->dump_error( $message )\fP"
.IX Subsection "$obj->dump_error( $message )"
Prints to \s-1STDERR\s0 a backtrace with information about this socket and what lead
up to the dump_error call.
.ie n .SS """$obj\->debugmsg( $format, @args )"""
.el .SS "\f(CW$obj\->debugmsg( $format, @args )\fP"
.IX Subsection "$obj->debugmsg( $format, @args )"
Print the debugging message specified by the \f(CW\*(C`sprintf\*(C'\fR\-style \fIformat\fR and
\&\fIargs\fR.
.ie n .SS """$obj\->peer_ip_string()"""
.el .SS "\f(CW$obj\->peer_ip_string()\fP"
.IX Subsection "$obj->peer_ip_string()"
Returns the string describing the peer's \s-1IP\s0
.ie n .SS """$obj\->peer_addr_string()"""
.el .SS "\f(CW$obj\->peer_addr_string()\fP"
.IX Subsection "$obj->peer_addr_string()"
Returns the string describing the peer for the socket which underlies this
object in form \*(L"ip:port\*(R"
.ie n .SS """$obj\->local_ip_string()"""
.el .SS "\f(CW$obj\->local_ip_string()\fP"
.IX Subsection "$obj->local_ip_string()"
Returns the string describing the local \s-1IP\s0
.ie n .SS """$obj\->local_addr_string()"""
.el .SS "\f(CW$obj\->local_addr_string()\fP"
.IX Subsection "$obj->local_addr_string()"
Returns the string describing the local end of the socket which underlies this
object in form \*(L"ip:port\*(R"
.ie n .SS """$obj\->as_string()"""
.el .SS "\f(CW$obj\->as_string()\fP"
.IX Subsection "$obj->as_string()"
Returns a string describing this socket.
.SH "AUTHORS"
.IX Header "AUTHORS"
Brad Fitzpatrick <brad@danga.com> \- author
.PP
Michael Granger <ged@danga.com> \- docs, testing
.PP
Mark Smith <junior@danga.com> \- contributor, heavy user, testing
.PP
Matt Sergeant <matt@sergeant.org> \- kqueue support, docs, timers, other bits
.SH "BUGS"
.IX Header "BUGS"
Not documented enough (but isn't that true of every project?).
.PP
tcp_cork only works on Linux for now.  No \s-1BSD\s0 push/nopush support.
.SH "LICENSE"
.IX Header "LICENSE"
License is granted to use and distribute this module under the same
terms as Perl itself.
