.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dancer::Request 3"
.TH Dancer::Request 3 "2020-01-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer::Request \- interface for accessing incoming requests
.SH "VERSION"
.IX Header "VERSION"
version 1.3513
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements a common interface for accessing incoming requests in
a Dancer application.
.PP
In a route handler, the current request object can be accessed by the \f(CW\*(C`request\*(C'\fR
method, like in the following example:
.PP
.Vb 6
\&    get \*(Aq/foo\*(Aq => sub {
\&        request\->params; # request, params parsed as a hash ref
\&        request\->body; # returns the request body, unparsed
\&        request\->path; # the path requested by the client
\&        # ...
\&    };
.Ve
.PP
A route handler should not read the environment by itself, but should instead
use the current request object.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.SS "\fBnew()\fP"
.IX Subsection "new()"
The constructor of the class, used internally by Dancer's core to create request
objects.
.PP
It uses the environment hash table given to build the request object:
.PP
.Vb 1
\&    Dancer::Request\->new(env => \e%ENV);
.Ve
.PP
It also accepts the \f(CW\*(C`is_forward\*(C'\fR boolean flag, if the new request
object is the result of a forward.
.SS "\fBinit()\fP"
.IX Subsection "init()"
Used internally to define some default values and parse parameters.
.ie n .SS "new_for_request($method, $path, $params, $body, $headers)"
.el .SS "new_for_request($method, \f(CW$path\fP, \f(CW$params\fP, \f(CW$body\fP, \f(CW$headers\fP)"
.IX Subsection "new_for_request($method, $path, $params, $body, $headers)"
An alternate constructor convenient for test scripts which creates a request
object with the arguments given.
.ie n .SS "forward($request, $new_location)"
.el .SS "forward($request, \f(CW$new_location\fP)"
.IX Subsection "forward($request, $new_location)"
Create a new request which is a clone of the current one, apart
from the path location, which points instead to the new location.
This is used internally to chain requests using the forward keyword.
.PP
Note that the new location should be a hash reference. Only one key is
required, the \f(CW\*(C`to_url\*(C'\fR, that should point to the \s-1URL\s0 that forward
will use. Optional values are the key \f(CW\*(C`params\*(C'\fR to a hash of
parameters to be added to the current request parameters, and the key
\&\f(CW\*(C`options\*(C'\fR that points to a hash of options about the redirect (for
instance, \f(CW\*(C`method\*(C'\fR pointing to a new request method).
.SS "is_forward"
.IX Subsection "is_forward"
Flag that will be set to true if the request has been forwarded.
.SS "\fBto_string()\fP"
.IX Subsection "to_string()"
Return a string representing the request object (eg: \f(CW"GET /some/path"\fR)
.SS "\fBmethod()\fP"
.IX Subsection "method()"
Return the \s-1HTTP\s0 method used by the client to access the application.
.PP
While this method returns the method string as provided by the environment, it's
better to use one of the following boolean accessors if you want to inspect the
requested method.
.SS "\fBaddress()\fP"
.IX Subsection "address()"
Return the \s-1IP\s0 address of the client.
.SS "\fBremote_host()\fP"
.IX Subsection "remote_host()"
Return the remote host of the client. This only works with web servers configured
to do a reverse \s-1DNS\s0 lookup on the client's \s-1IP\s0 address.
.SS "\fBprotocol()\fP"
.IX Subsection "protocol()"
Return the protocol (\s-1HTTP/1.0\s0 or \s-1HTTP/1.1\s0) used for the request.
.SS "\fBport()\fP"
.IX Subsection "port()"
Return the port of the server.
.SS "\fBuri()\fP"
.IX Subsection "uri()"
An alias to \fBrequest_uri()\fR
.SS "\fBrequest_uri()\fP"
.IX Subsection "request_uri()"
Return the raw, undecoded request \s-1URI\s0 path.
.SS "\fBuser()\fP"
.IX Subsection "user()"
Return remote user if defined.
.SS "\fBscript_name()\fP"
.IX Subsection "script_name()"
Return script_name from the environment.
.SS "\fBscheme()\fP"
.IX Subsection "scheme()"
Return the scheme of the request
.SS "\fBsecure()\fP"
.IX Subsection "secure()"
Return true of false, indicating whether the connection is secure
.SS "\fBis_get()\fP"
.IX Subsection "is_get()"
Return true if the method requested by the client is '\s-1GET\s0'
.SS "\fBis_head()\fP"
.IX Subsection "is_head()"
Return true if the method requested by the client is '\s-1HEAD\s0'
.SS "\fBis_patch()\fP"
.IX Subsection "is_patch()"
Return true if the method requested by the client is '\s-1PATCH\s0'
.SS "\fBis_post()\fP"
.IX Subsection "is_post()"
Return true if the method requested by the client is '\s-1POST\s0'
.SS "\fBis_put()\fP"
.IX Subsection "is_put()"
Return true if the method requested by the client is '\s-1PUT\s0'
.SS "\fBis_delete()\fP"
.IX Subsection "is_delete()"
Return true if the method requested by the client is '\s-1DELETE\s0'
.SS "\fBpath()\fP"
.IX Subsection "path()"
Return the path requested by the client.
.SS "\fBbase()\fP"
.IX Subsection "base()"
Returns an absolute \s-1URI\s0 for the base of the application.  Returns a \s-1URI\s0
object (which stringifies to the \s-1URL,\s0 as you'd expect).
.SS "\fBuri_base()\fP"
.IX Subsection "uri_base()"
Same thing as \f(CW\*(C`base\*(C'\fR above, except it removes the last trailing slash in the
path if it is the only path.
.PP
This means that if your base is \fIhttp://myserver/\fR, \f(CW\*(C`uri_base\*(C'\fR will return
\&\fIhttp://myserver\fR (notice no trailing slash). This is considered very useful
when using templates to do the following thing:
.PP
.Vb 1
\&    <link rel="stylesheet" href="<% request.uri_base %>/css/style.css" />
.Ve
.SS "uri_for(path, params)"
.IX Subsection "uri_for(path, params)"
Constructs a \s-1URI\s0 from the base and the passed path.  If params (hashref) is
supplied, these are added to the query string of the uri.  If the base is
\&\f(CW\*(C`http://localhost:5000/foo\*(C'\fR, \f(CW\*(C`request\->uri_for(\*(Aq/bar\*(Aq, { baz => \*(Aqbaz\*(Aq })\*(C'\fR
would return \f(CW\*(C`http://localhost:5000/foo/bar?baz=baz\*(C'\fR.  Returns a \s-1URI\s0 object
(which stringifies to the \s-1URL,\s0 as you'd expect).
.SS "params($source)"
.IX Subsection "params($source)"
Called in scalar context, returns a hashref of params, either from the specified
source (see below for more info on that) or merging all sources.
.PP
So, you can use, for instance:
.PP
.Vb 1
\&    my $foo = params\->{foo}
.Ve
.PP
If called in list context, returns a list of key => value pairs, so you could use:
.PP
.Vb 1
\&    my %allparams = params;
.Ve
.PP
If the incoming form data contains multiple values for the same key, they will
be returned as an arrayref.
.PP
\fIFetching only params from a given source\fR
.IX Subsection "Fetching only params from a given source"
.PP
If a required source isn't specified, a mixed hashref (or list of key value
pairs, in list context) will be returned; this will contain params from all
sources (route, query, body).
.PP
In practical terms, this means that if the param \f(CW\*(C`foo\*(C'\fR is passed both on the
querystring and in a \s-1POST\s0 body, you can only access one of them.
.PP
If you want to see only params from a given source, you can say so by passing
the \f(CW$source\fR param to \f(CW\*(C`params()\*(C'\fR:
.PP
.Vb 3
\&    my %querystring_params = params(\*(Aqquery\*(Aq);
\&    my %route_params       = params(\*(Aqroute\*(Aq);
\&    my %post_params        = params(\*(Aqbody\*(Aq);
.Ve
.PP
If source equals \f(CW\*(C`route\*(C'\fR, then only params parsed from the route pattern
are returned.
.PP
If source equals \f(CW\*(C`query\*(C'\fR, then only params parsed from the query string are
returned.
.PP
If source equals \f(CW\*(C`body\*(C'\fR, then only params sent in the request body will be
returned.
.PP
If another value is given for \f(CW$source\fR, then an exception is triggered.
.SS "Vars"
.IX Subsection "Vars"
Alias to the \f(CW\*(C`params\*(C'\fR accessor, for backward-compatibility with \f(CW\*(C`CGI\*(C'\fR interface.
.SS "request_method"
.IX Subsection "request_method"
Alias to the \f(CW\*(C`method\*(C'\fR accessor, for backward-compatibility with \f(CW\*(C`CGI\*(C'\fR interface.
.SS "input_handle"
.IX Subsection "input_handle"
Alias to the \s-1PSGI\s0 input handle (\f(CW\*(C`<request\->env\->{psgi.input}>\*(C'\fR)
.SS "\fBcontent_type()\fP"
.IX Subsection "content_type()"
Return the content type of the request.
.SS "\fBcontent_length()\fP"
.IX Subsection "content_length()"
Return the content length of the request.
.SS "header($name)"
.IX Subsection "header($name)"
Return the value of the given header, if present. If the header has multiple
values, return a list with its values if called in list context, or the first
one if called in scalar context.
.SS "\fBheaders()\fP"
.IX Subsection "headers()"
Returns the HTTP::Header object used to store all the headers.
.SS "\fBbody()\fP"
.IX Subsection "body()"
Return the raw body of the request, unparsed.
.PP
\&\s-1NOTE:\s0 the behaviour of this keyword has changed.  Originally, the entire raw
request body was kept in \s-1RAM\s0 for this accessor, but that's not ideal if you
handle large requests (file uploads, etc), so in 1.3143 that was ditched, and
the body accessor replaced by a convenience method which would get the temp file
handle that HTTP::Body uses, read it for you and return the content, so that if
you did want the raw body, it was there.  However, HTTP::Body only creates a
temp file for certain types of request, leading to unpredictable behaviour and
confusion \- see issue #1140.
.PP
So, handling of the raw request body is now controlled by a configuration
setting, raw_request_body_in_ram, which controls whether or not the raw request
body will be kept in \s-1RAM\s0 when it's parsed; if this is set to a false value,
then \fIthe body accessor will not return anything\fR, giving you lower memory
usage, at the cost of not having access to the raw (unparsed) request body.
.SS "\fBis_ajax()\fP"
.IX Subsection "is_ajax()"
Return true if the value of the header \f(CW\*(C`X\-Requested\-With\*(C'\fR is XMLHttpRequest.
.SS "\fBenv()\fP"
.IX Subsection "env()"
Return the current environment as a hashref.
.PP
Note that a request's environment is not always reflected by the global
variable \f(CW%ENV\fR (e.g., when running via Plack::Handler::FCGI). In
consequence, it is recommended to always rely on the values returned by
\&\f(CW\*(C`env()\*(C'\fR, and not to access \f(CW%ENV\fR directly.
.SS "\fBuploads()\fP"
.IX Subsection "uploads()"
Returns a reference to a hash containing uploads. Values can be either a
Dancer::Request::Upload object, or an arrayref of Dancer::Request::Upload
objects.
.PP
You should probably use the \f(CW\*(C`upload($name)\*(C'\fR accessor instead of manually accessing the
\&\f(CW\*(C`uploads\*(C'\fR hash table.
.SS "upload($name)"
.IX Subsection "upload($name)"
Context-aware accessor for uploads. It's a wrapper around an access to the hash
table provided by \f(CW\*(C`uploads()\*(C'\fR. It looks at the calling context and returns a
corresponding value.
.PP
If you have many file uploads under the same name, and call \f(CW\*(C`upload(\*(Aqname\*(Aq)\*(C'\fR in
an array context, the accessor will unroll the \s-1ARRAY\s0 ref for you:
.PP
.Vb 1
\&    my @uploads = request\->upload(\*(Aqmany_uploads\*(Aq); # OK
.Ve
.PP
Whereas with a manual access to the hash table, you'll end up with one element
in \f(CW@uploads\fR, being the \s-1ARRAY\s0 ref:
.PP
.Vb 1
\&    my @uploads = request\->uploads\->{\*(Aqmany_uploads\*(Aq}; # $uploads[0]: ARRAY(0xXXXXX)
.Ve
.PP
That is why this accessor should be used instead of a manual access to
\&\f(CW\*(C`uploads\*(C'\fR.
.SH "Values"
.IX Header "Values"
Given a request to http://perldancer.org:5000/request\-methods?a=1 these are
the values returned by the various request\->  method calls:
.PP
.Vb 11
\&  base         http://perldancer.org:5000/
\&  host         perldancer.org
\&  uri_base     http://perldancer.org:5000
\&  uri          /request\-methods?a=1
\&  request_uri  /request\-methods?a=1
\&  path         /request\-methods
\&  path_info    /request\-methods
\&  method       GET
\&  port         5000
\&  protocol     HTTP/1.1
\&  scheme       http
.Ve
.SH "HTTP environment variables"
.IX Header "HTTP environment variables"
All \s-1HTTP\s0 environment variables that are in \f(CW%ENV\fR will be provided in the
Dancer::Request object through specific accessors, here are those supported:
.ie n .IP """accept""" 4
.el .IP "\f(CWaccept\fR" 4
.IX Item "accept"
.PD 0
.ie n .IP """accept_charset""" 4
.el .IP "\f(CWaccept_charset\fR" 4
.IX Item "accept_charset"
.ie n .IP """accept_encoding""" 4
.el .IP "\f(CWaccept_encoding\fR" 4
.IX Item "accept_encoding"
.ie n .IP """accept_language""" 4
.el .IP "\f(CWaccept_language\fR" 4
.IX Item "accept_language"
.ie n .IP """accept_type""" 4
.el .IP "\f(CWaccept_type\fR" 4
.IX Item "accept_type"
.ie n .IP """agent"" (alias for ""user_agent"")" 4
.el .IP "\f(CWagent\fR (alias for \f(CWuser_agent\fR)" 4
.IX Item "agent (alias for user_agent)"
.ie n .IP """connection""" 4
.el .IP "\f(CWconnection\fR" 4
.IX Item "connection"
.ie n .IP """forwarded_for_address""" 4
.el .IP "\f(CWforwarded_for_address\fR" 4
.IX Item "forwarded_for_address"
.PD
Looks for \s-1HTTP_X_FORWARDED_FOR\s0 if X_FORWARDED_FOR is not there.
.ie n .IP """forwarded_protocol""" 4
.el .IP "\f(CWforwarded_protocol\fR" 4
.IX Item "forwarded_protocol"
.PD 0
.ie n .IP """forwarded_host""" 4
.el .IP "\f(CWforwarded_host\fR" 4
.IX Item "forwarded_host"
.ie n .IP """host""" 4
.el .IP "\f(CWhost\fR" 4
.IX Item "host"
.PD
If you app is on a non-standard port, you can expect this to return the hostname
and port, e.g. \f(CW\*(C`example.com:5000\*(C'\fR.
.ie n .IP """keep_alive""" 4
.el .IP "\f(CWkeep_alive\fR" 4
.IX Item "keep_alive"
.PD 0
.ie n .IP """path_info""" 4
.el .IP "\f(CWpath_info\fR" 4
.IX Item "path_info"
.ie n .IP """referer""" 4
.el .IP "\f(CWreferer\fR" 4
.IX Item "referer"
.ie n .IP """remote_address""" 4
.el .IP "\f(CWremote_address\fR" 4
.IX Item "remote_address"
.ie n .IP """request_base""" 4
.el .IP "\f(CWrequest_base\fR" 4
.IX Item "request_base"
.ie n .IP """user_agent""" 4
.el .IP "\f(CWuser_agent\fR" 4
.IX Item "user_agent"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
This module has been written by Alexis Sukrieh and was mostly
inspired by Plack::Request, written by Tatsuiko Miyagawa.
.PP
Tatsuiko Miyagawa also gave a hand for the \s-1PSGI\s0 interface.
.SH "LICENCE"
.IX Header "LICENCE"
This module is released under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Dancer
.SH "AUTHOR"
.IX Header "AUTHOR"
Dancer Core Developers
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by Alexis Sukrieh.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
