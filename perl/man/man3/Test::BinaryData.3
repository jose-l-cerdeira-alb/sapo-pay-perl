.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::BinaryData 3"
.TH Test::BinaryData 3 "2013-10-18" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::BinaryData \- compare two things, give hex dumps if they differ
.SH "VERSION"
.IX Header "VERSION"
version 0.014
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Test::BinaryData;
\&  
\&  my $computed_data = do_something_complicated;
\&  my $expected_data = read_file(\*(Aqcorrect.data\*(Aq);
\&
\&  is_binary(
\&    $computed_data,
\&    $expected_data,
\&    "basic data computation",
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes using Test::More's \f(CW\*(C`is\*(C'\fR test isn't good enough.  Its diagnostics may
make it easy to miss differences between strings.
.PP
For example, given two strings which differ only in their line endings, you can
end up with diagnostic output like this:
.PP
.Vb 8
\&  not ok 1
\&  #   Failed test in demo.t at line 8.
\&  #          got: \*(Aqfoo
\&  # bar
\&  # \*(Aq
\&  #     expected: \*(Aqfoo
\&  # bar
\&  # \*(Aq
.Ve
.PP
That's not very helpful, except to tell you that the alphanumeric characters
seem to be in the right place.  By using \f(CW\*(C`is_binary\*(C'\fR instead of \f(CW\*(C`is\*(C'\fR, this
output would be generated instead:
.PP
.Vb 4
\&  not ok 2
\&  #   Failed test in demo.t at line 10.
\&  # have (hex)           have         want (hex)           want
\&  # 666f6f0a6261720a\-\-\-\- foo.bar.   ! 666f6f0d0a6261720d0a foo..bar..
.Ve
.PP
The \*(L"!\*(R" tells us that the lines differ, and we can quickly scan the bytes that
make up the line to see which differ.
.PP
When comparing very long strings, we can stop after we've seen a few
differences.  Here, we'll just look for two:
.PP
.Vb 10
\&  # have (hex)           have         want (hex)           want    
\&  # 416c6c20435220616e64 All CR and = 416c6c20435220616e64 All CR and
\&  # 206e6f204c46206d616b  no LF mak = 206e6f204c46206d616b  no LF mak
\&  # 6573204d616320612064 es Mac a d = 6573204d616320612064 es Mac a d
\&  # 756c6c20626f792e0d41 ull boy..A = 756c6c20626f792e0d41 ull boy..A
\&  # 6c6c20435220616e6420 ll CR and  = 6c6c20435220616e6420 ll CR and 
\&  # 6e6f204c46206d616b65 no LF make = 6e6f204c46206d616b65 no LF make
\&  # 73204d61632061206475 s Mac a du = 73204d61632061206475 s Mac a du
\&  # 6c6c20626f792e0d416c ll boy..Al ! 6c6c20626f792e0a416c ll boy..Al
\&  # 6c20435220616e64206e l CR and n = 6c20435220616e64206e l CR and n
\&  # 6f204c46206d616b6573 o LF makes = 6f204c46206d616b6573 o LF makes
\&  # 204d616320612064756c  Mac a dul = 204d616320612064756c  Mac a dul
\&  # 6c20626f792e0d416c6c l boy..All ! 6c20626f792e0a416c6c l boy..All
\&  # 20435220616e64206e6f  CR and no = 20435220616e64206e6f  CR and no
\&  # ...
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "is_binary"
.IX Subsection "is_binary"
.Vb 1
\&  is_binary($have, $want, $comment, \e%arg);
.Ve
.PP
This test behaves like Test::More's \f(CW\*(C`is\*(C'\fR test, but if the given data are not
string equal, the diagnostics emits four columns, describing the strings in
parallel, showing a simplified \s-1ASCII\s0 representation and a hexadecimal dump.
.PP
If \f(CW$want\fR is an arrayref, it's treated as a sequence of strings giving hex
values for expected bytes.  For example, this is a passing test:
.PP
.Vb 4
\&  is_binary(
\&    "Mumblefrotz",
\&    [ qw(4d75 6d62 6c65 6672 6f74 7a0a) ],
\&  );
.Ve
.PP
Notice that each string in the sequence is broken into two-character pieces.
This makes this interface accept the kind of dumps produced by \fIxxd\fR or
Test::BinaryData itself.
.PP
Between the got and expected data for each line, a \*(L"=\*(R" or \*(L"!\*(R" indicates whether
the chunks are identical or different.
.PP
The \f(CW$comment\fR and \f(CW%arg\fR arguments are optional.  Valid arguments are:
.PP
.Vb 3
\&  columns   \- the number of screen columns available
\&              if the COLUMNS environment variable is an positive integer, then
\&              COLUMNS \- is used; otherwise, the default is 79
\&
\&  max_diffs \- if given, this is the maximum number of differing lines that will
\&              be compared; if output would have been given beyond this line, 
\&              it will be replaced with an elipsis ("...")
.Ve
.SH "WARNING"
.IX Header "WARNING"
This library is for comparing \fBbinary\fR data.  That is, \fBbyte strings\fR.
Often, in Perl 5, it is not clear whether a scalar contains a byte string or a
character strings.  You should use this library for comparing byte strings
only.  If either the \*(L"have\*(R" or \*(L"want\*(R" values contain wide characters \*(-- that is,
characters that won't fit in one byte \*(-- then the test will fail.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
optional position markers
.Sp
.Vb 8
\&     have (hex)       have       want (hex)       want
\&  00 46726f6d206d6169 From mai = 46726f6d206d6169 From mai
\&  08 3130353239406c6f 10529@lo = 3130353239406c6f 10529@lo
\&  16 63616c686f737420 calhost  = 63616c686f737420 calhost 
\&  24 5765642044656320 Wed Dec  = 5765642044656320 Wed Dec 
\&  32 31382031323a3037 18 12:07 = 31382031323a3037 18 12:07
\&  40 3a35352032303032 :55 2002 = 3a35352032303032 :55 2002
\&  48 0a52656365697665 .Receive ! 0d0a526563656976 ..Receiv
.Ve
.IP "\(bu" 4
investigate probably bugs with wide chars, multibyte strings
.Sp
I wrote this primarily for detecting \s-1CRLF\s0 problems, but it's also very useful
for dealing with encoded strings.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ricardo Signes <rjbs@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
