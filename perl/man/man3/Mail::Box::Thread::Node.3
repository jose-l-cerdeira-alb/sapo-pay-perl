.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::Box::Thread::Node 3"
.TH Mail::Box::Thread::Node 3 "2019-10-04" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Box::Thread::Node \- one node in a message thread
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Box::Thread::Node
\&   is a Mail::Reporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& my $node = Mail::Box::Thread::Node\->new;
\& $node\->addMessage($message);
\& ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Mail::Box::Thread::Node\*(C'\fR maintains one node in the linked list of
threads.  Each node contains one message, and a list of its follow-ups.
Next to that, it refers to its own ancestor and contains information
about the trustworthiness of that relationship.
.PP
To complicate things a little, because the thread-manager can maintain
multiple folders, and merge there content, you may find the same message
in more folders.  All versions of the same message (based on message-id)
are stored in the same node.
.PP
Extends \*(L"\s-1DESCRIPTION\*(R"\s0 in Mail::Reporter.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\*(R"\s0 in Mail::Reporter.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in Mail::Reporter.
.IP "Mail::Box::Thread::Node\->\fBnew\fR(%options)" 4
.IX Item "Mail::Box::Thread::Node->new(%options)"
You will not call this method yourself. The Mail::Box::Thread::Manager
object will call it to construct \f(CW\*(C`Mail::Box::Thread::Node\*(C'\fR objects.
Either a \f(CW\*(C`message\*(C'\fR or a \f(CW\*(C`messageId\*(C'\fR must be supplied.
.Sp
.Vb 6
\& \-Option    \-\-Defined in     \-\-Default
\&  dummy_type                   undef
\&  log         Mail::Reporter   \*(AqWARNINGS\*(Aq
\&  message                      undef
\&  messageId                    undef
\&  trace       Mail::Reporter   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "dummy_type => \s-1CLASS\s0" 2
.IX Item "dummy_type => CLASS"
Indicates the class name of dummy messages. Dummy messages are
placeholders in a Mail::Box::Thread::Manager data structure.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "message => \s-1MESSAGE\s0" 2
.IX Item "message => MESSAGE"
.PD
The \s-1MESSAGE\s0 which is stored in this node.  The message
must be a Mail::Box::Message.
.IP "messageId => MESSAGE-ID" 2
.IX Item "messageId => MESSAGE-ID"
The MESSAGE-ID for the message which is stored in this node.  Only
specify it when you don't have the message yet.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.SS "The thread node"
.IX Subsection "The thread node"
.PD 0
.ie n .IP "$obj\->\fBaddMessage\fR($message)" 4
.el .IP "\f(CW$obj\fR\->\fBaddMessage\fR($message)" 4
.IX Item "$obj->addMessage($message)"
.PD
Add one message to the thread node.  If the node contains a dummy, then
the dummy is replaced. Otherwise, the messages is added to the end of the
list.
.ie n .IP "$obj\->\fBexpand\fR( [\s-1BOOLEAN\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBexpand\fR( [\s-1BOOLEAN\s0] )" 4
.IX Item "$obj->expand( [BOOLEAN] )"
Returns whether this (part of the) folder has to be shown expanded or not.
This is simply done by a label, which means that most folder types can
store this.
.ie n .IP "$obj\->\fBisDummy\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDummy\fR()" 4
.IX Item "$obj->isDummy()"
Returns true if the message is a dummy. A dummy is a \*(L"hole\*(R" in a thread
which has follow-ups but does not have a message.
.ie n .IP "$obj\->\fBmessage\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR()" 4
.IX Item "$obj->message()"
Get the message which is stored in this thread node.  \s-1NOTE:\s0 the same
message may be located in many folders at the same time, and these
folders may be controlled by the same thread manager.
.Sp
In scalar context, this method returns the first instance of the
message that is not deleted. If all instances are flagged for deletion,
then you get the first deleted message. When the open folders only
contain references to the message, but no instance, you get a dummy
message (see Mail::Message::Dummy).
.Sp
In list context, all instances of the message which have been found are
returned.
.Sp
example:
.Sp
.Vb 2
\& my $threads = $mgr\->threads(folders => [$draft, $sent]);
\& my $node    = $draft\->message(1)\->thread;
\&
\& foreach my $instance ($node\->message) {
\&    print "Found in ", $instance\->folder, ".\en";
\& }
\&
\& print "Subject is ", $node\->message\->subject, ".\en";
.Ve
.ie n .IP "$obj\->\fBmessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessageId\fR()" 4
.IX Item "$obj->messageId()"
Return the message-id related to this thread node.  Each of the messages
listed in this node will have the same \s-1ID.\s0
.SS "The thread order"
.IX Subsection "The thread order"
.ie n .IP "$obj\->\fBfollowUps\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfollowUps\fR()" 4
.IX Item "$obj->followUps()"
Returns the list of follow-ups to this thread node.  This list
may contain parsed, not-parsed, and dummy messages.
.ie n .IP "$obj\->\fBfollowedBy\fR($threads)" 4
.el .IP "\f(CW$obj\fR\->\fBfollowedBy\fR($threads)" 4
.IX Item "$obj->followedBy($threads)"
Register that the \f(CW$threads\fR are follow-ups to this message. These
follow-ups need not be related to each other in any way other than
sharing the same parent.
.Sp
Defining the same relation more than once will not cause information to
be duplicated.
.ie n .IP "$obj\->\fBfollows\fR($thread, $quality)" 4
.el .IP "\f(CW$obj\fR\->\fBfollows\fR($thread, \f(CW$quality\fR)" 4
.IX Item "$obj->follows($thread, $quality)"
Register that the current thread is a reply to the specified \f(CW$thread\fR. The
\&\f(CW$quality\fR of the relation is specified by the second argument.  The method
returns \f(CW\*(C`undef\*(C'\fR if the link is not accepted in order to avoid circular
references.
.Sp
The relation may be specified more than once, but only the most confident
relation is used. For example, if a reply ($quality equals \f(CW\*(C`REPLY\*(C'\fR) is
specified, later calls to the follow method will have no effect. If
\&\f(CW\*(C`follows\*(C'\fR is called with a \f(CW$quality\fR that matches the current quality, the
new thread overrides the previous.
.ie n .IP "$obj\->\fBrepliedTo\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBrepliedTo\fR()" 4
.IX Item "$obj->repliedTo()"
Returns the message(s) to which the message in this node replies. In
scalar context, this method will return the message to which the message
in this node replies. This message object may be a dummy message.
.Sp
If the message seems to be the first message of a thread, the value \f(CW\*(C`undef\*(C'\fR
is returned.  (Remember that some \s-1MUA\s0 are not adding reference information
to the message's header, so you can never be sure a message is the
start of a thread)
.Sp
In list context, this method returns a second string value indicating the
confidence that the messages are related.  When extended thread discovery
is enabled, then some heuristics are applied to determine if messages are
related. Values for the \s-1STRING\s0 may be:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(AqREPLY\*(Aq\fR
.Sp
This relation was directly derived from an `in\-reply\-to' message header
field. The relation has a high confidence.
.IP "\(bu" 4
\&\f(CW\*(AqREFERENCE\*(Aq\fR
.Sp
This relation is based on information found in a `Reference' message
header field.  One message may reference a list of messages which
precede it in the thread. The heuristic attempts to determine
relationships between messages assuming that the references are in order.
This relation has a lower confidence.
.IP "\(bu" 4
\&\f(CW\*(AqGUESS\*(Aq\fR
.Sp
The relation is a big guess, with low confidence.  It may be based on
a subject which seems to be related, or commonalities in the message's
body.
.RE
.RS 4
.Sp
More constants may be added later.
.Sp
example:
.Sp
.Vb 3
\& my $question = $answer\->repliedTo;
\& my ($question, $quality) = $answer\->repliedTo;
\& if($question && $quality eq \*(AqREPLY\*(Aq) { ... };
.Ve
.RE
.ie n .IP "$obj\->\fBsortedFollowUps\fR( [$prepare, [$compare]] )" 4
.el .IP "\f(CW$obj\fR\->\fBsortedFollowUps\fR( [$prepare, [$compare]] )" 4
.IX Item "$obj->sortedFollowUps( [$prepare, [$compare]] )"
Returns the list of \fBfollowUps()\fR, but sorted.  By default
sorting is based on the estimated time of the reply. See
\&\fBstartTimeEstimate()\fR.
.SS "On the whole thread"
.IX Subsection "On the whole thread"
Some convenience methods are added to threads, to simplify retrieving
information from it.
.ie n .IP "$obj\->\fBendTimeEstimate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBendTimeEstimate\fR()" 4
.IX Item "$obj->endTimeEstimate()"
Returns a guess as to when the thread has ended (although you never
know for sure whether there fill follow messages in the future).
.ie n .IP "$obj\->\fBids\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBids\fR()" 4
.IX Item "$obj->ids()"
Returns all the ids in the thread starting at the current thread node.
.Sp
example:
.Sp
.Vb 2
\& $newfolder\->addMessages($folder\->ids($thread\->ids));
\& $folder\->delete($thread\->ids);
.Ve
.ie n .IP "$obj\->\fBnumberOfMessages\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnumberOfMessages\fR()" 4
.IX Item "$obj->numberOfMessages()"
Number of messages in the thread starting at the current thread node, but
not counting the dummies.
.ie n .IP "$obj\->\fBrecurse\fR(\s-1CODE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBrecurse\fR(\s-1CODE\s0)" 4
.IX Item "$obj->recurse(CODE)"
Execute a function for all sub-threads.  If the subroutine returns true,
sub-threads are visited recursively. Otherwise, the current branch
traversal is aborted. The routine is called with the thread-node as the
only argument.
.ie n .IP "$obj\->\fBstartTimeEstimate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstartTimeEstimate\fR()" 4
.IX Item "$obj->startTimeEstimate()"
Returns a guess as to when the thread was started.  Each message contains
various date specifications (each with various uncertainties resulting
from timezones and out-of-sync clocks). One of these date specifications
is used as the timestamp for the message. If the node contains a dummy
message the lowest timestamp of the replies is returned. Otherwise the
estimated timestamp of the node's message is returned.
.ie n .IP "$obj\->\fBthreadMessages\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBthreadMessages\fR()" 4
.IX Item "$obj->threadMessages()"
Returns all the messages in the thread starting at the current thread
node.  This list will not include dummies.
.Sp
example:
.Sp
.Vb 3
\& my @t = $folder\->message(3)
\&                \->threadStart
\&                \->threadMessages;
.Ve
.ie n .IP "$obj\->\fBthreadToString\fR( [\s-1CODE\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBthreadToString\fR( [\s-1CODE\s0] )" 4
.IX Item "$obj->threadToString( [CODE] )"
Translate a thread into a string. The string will contain at least one
line for each message which was found, but tries to fold dummies.  This
is useful for debugging, but most message readers will prefer to
implement their own thread printer.
.Sp
The optional \s-1CODE\s0 argument is a reference to a routine which will be called
for each message in the thread.  The routine will be called with the
message as the first argument.  The default shows the subject of the message.
In the first example below, this routine is called seven times.
.Sp
example:
.Sp
.Vb 1
\& print $node\->threadToString;
.Ve
.Sp
may result in
.Sp
.Vb 7
\& Subject of this message
\& |\- Re: Subject of this message
\& |\-*\- Re: Re: Subject of this message
\& | |\- Re(2) Subject of this message
\& | |\- [3] Re(2) Subject of this message
\& | \`\- Re: Subject of this message (reply)
\& \`\- Re: Subject of this message
.Ve
.Sp
The `*' represents a missing message (a \*(L"dummy\*(R" message).  The `[3]'
presents a folded thread with three messages.
.Sp
.Vb 1
\& print $node\->threadToString(\e&show);
\&
\& sub show($) {
\&    my $message = shift;
\&    my $subject = $message\->head\->get(\*(Aqsubject\*(Aq);
\&    length $subject ? $subject : \*(Aq<no subject>\*(Aq;
\& }
.Ve
.ie n .IP "$obj\->\fBtotalSize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtotalSize\fR()" 4
.IX Item "$obj->totalSize()"
Returns the sum of the size of all the messages in the thread.
.SS "Error handling"
.IX Subsection "Error handling"
Extends \*(L"Error handling\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR($object)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR($object)" 4
.IX Item "$obj->addReport($object)"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "$obj->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD 0
.ie n .IP "Mail::Box::Thread::Node\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "Mail::Box::Thread::Node\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "Mail::Box::Thread::Node->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR( [$level, [$strings]] )" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "$obj->log( [$level, [$strings]] )"
.PD 0
.IP "Mail::Box::Thread::Node\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "Mail::Box::Thread::Node->log( [$level, [$strings]] )"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR($level)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR($level)" 4
.IX Item "$obj->logPriority($level)"
.PD 0
.IP "Mail::Box::Thread::Node\->\fBlogPriority\fR($level)" 4
.IX Item "Mail::Box::Thread::Node->logPriority($level)"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR( [$level] )" 4
.IX Item "$obj->report( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR( [$level] )" 4
.IX Item "$obj->reportAll( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR( [$level] )" 4
.IX Item "$obj->trace( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
Extends \*(L"Cleanup\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
Inherited, see \*(L"Cleanup\*(R" in Mail::Reporter
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Package $package does not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR does not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package does not implement $method."
Fatal error: the specific package (or one of its superclasses) does not
implement this method where it should. This message means that some other
related classes do implement this method however the class at hand does
not.  Probably you should investigate this and probably inform the author
of the package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 3.008,
built on October 04, 2019. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2019 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
