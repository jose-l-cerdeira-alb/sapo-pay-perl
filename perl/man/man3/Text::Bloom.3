.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bloom 3"
.TH Bloom 3 "2001-11-12" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Text::Bloom \- Evaluate Bloom signature of a set of terms
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\&  my $b = Text::Bloom\->new();
\&  $b\->Compute( qw( foo bar baz ) );
\&  my $sig = $b\->WriteToString();
\&  $b\->WriteToFile( \*(Aqafile.sig\*(Aq );
\&  my $b2 = Text::Bloom::NewFromFile( \*(Aqafile.sig\*(Aq );
\&  my $b3 = Text::Bloom\->new();
\&  $b3\->Compute( qw( foo bar barbaz ) );
\&  my $sim = $b\->Similarity( $b2 );
\&  my $b4 = Text::Bloom::NewFromString( $sig );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Text::Bloom\*(C'\fR applies the Bloom filtering technique to
the statistical analysis of documents.
.PP
The terms in the document are quantized using a base\-36
radix representation; each term thus corresponds to an
integer in the range 0..\fIp\-1\fR, where \fIp\fR is a prime,
currently set to the greatest prime less than 2^32.
.PP
Each quantized value is mapped to \fId\fR integers in the range
0..\fIsize\-1\fR, where \fIsize\fR is an integer less than \fIp\fR,
currently 2^17, using a  family of hash functions,
computed by the \f(CW\*(C`HashV\*(C'\fR function.
.PP
Each hashed value is used as the index in a large bit vector.
Bits corresponding to terms present in the document are set to
1; all other bits are set to 0.
.PP
Of course, collisions may cause the same bit to be set twice,
by different terms. It follows that, if the document contains
\&\fIn\fR distinct terms, in the resulting bit vector at most
\&\fIn * d\fR bits are set to 1.
.PP
The resulting bit string is a very compact representation of the
presence/absence of terms in the document, and  is therefore
characterised as a \fIsignature\fR. Moreover, it does not
depend on a pre-set dictionary of terms.
.PP
The signature may be used for:
.IP "\(bu" 4
testing whether a given set of terms is present in the document,
.IP "\(bu" 4
computing which fraction of terms are common to two documents.
.PP
The bit representation may be written to and read from a file.
\&\f(CW\*(C`Text::Bloom\*(C'\fR prepends a header to the bit stream proper;
moreover, whenever the package \f(CW\*(C`Compress::Zlib\*(C'\fR is available,
the bit vector is compressed, so that disk space requirements
are drastically reduced, especially for small documents.
.PP
The hash function is obviously a crucial component of the filter;
the reference implementation uses a radix representation of
strings. Each term must therefore match the regular
expression \f(CW\*(C`/[0\-9a\-z]+/\*(C'\fR.
.PP
There are quite a few viable alternatives, which can be pursued
by subclassing and redefining the method \f(CW\*(C`QuantizeV\*(C'\fR.
.SH "FORESEEN REUSE"
.IX Header "FORESEEN REUSE"
The package may be {re}used either by simple instantiation,
or by subclassing (defining a descendant package).  In the
latter case the methods which are foreseen to be redefined are
those ending with a \f(CW\*(C`V\*(C'\fR suffix.  Redefining other methods
will require greater attention.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "new"
.IX Subsection "new"
The constructor. No arguments are required.
.PP
.Vb 1
\&  $b = Text::Bloom\->new();
.Ve
.SS "NewFromString"
.IX Subsection "NewFromString"
Take a string written by \f(CW\*(C`WriteToString\*(C'\fR (see below)
and create a new \f(CW\*(C`Text::Bloom\*(C'\fR with the same contents;
call \f(CW\*(C`die\*(C'\fR whenever the restore is impossible or ill-advised,
for instance when the current version of the package is different
from the original one, or the compression library in unavailable.
.PP
.Vb 1
\&  my $b = Text::Bloom::NewFromString( $str );
.Ve
.PP
The return value is a blessed reference; put in another way,
this is an alternative contructor.
.PP
The string should have been written by \f(CW\*(C`WriteToString\*(C'\fR; 
you may of course tweak the string contents, but
at this point you're entirely on you own.
.SS "NewFromFile"
.IX Subsection "NewFromFile"
Utility function that reads a binary file and performs a \f(CW\*(C`NewFromString\*(C'\fR
on its content; see its counterpart, \f(CW\*(C`WriteToFile\*(C'\fR.
.PP
.Vb 1
\&  my $b2 = Text::Document::NewFromFile( \*(Aqfoo.sig\*(Aq );
.Ve
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "Size"
.IX Subsection "Size"
Set and get the size of the filter, in bits. The default size
is currently 128K.
.PP
.Vb 2
\&  print \*(Aqsize is \*(Aq . $b\->Size() . "\en";
\&  $b\->Size( 65536 );
.Ve
.PP
The \f(CW\*(C`Size\*(C'\fR method must be called before the \f(CW\*(C`Compute\*(C'\fR method
in order to have effect.
.SS "Compute"
.IX Subsection "Compute"
Compute the Bloom signature from the given set of words
and store it internally.
.PP
.Vb 1
\&  $b\->Compute( qw( foo bar baz foobar bazbaz ) );
.Ve
.PP
Makes use of the \f(CW\*(C`QuantizeV\*(C'\fR method.
.SS "QuantizeV"
.IX Subsection "QuantizeV"
Convert a term into an integer; must return
an integer in the range 0 .. \f(CW\*(C`$Text::Bloom::p\-1\*(C'\fR.
.PP
It is called as
.PP
.Vb 1
\&  my $hash = $b\->QuantizeV( $term );
.Ve
.PP
The current version is designed for strings matching
\&\f(CW\*(C`/[a\-z0\-9]+/\*(C'\fR. Other characters do not cause errors,
but degrade the hash function performance.
.PP
This function is a likely candidate for redefinition.
.SS "HashV"
.IX Subsection "HashV"
Convert an integer to a (smaller) integer, according
to one of a class of similar functions.
.PP
It is internally called as:
.PP
.Vb 1
\&  my $index = $b\->HashV( $order, $value );
.Ve
.PP
The \f(CW$value\fR must belong  to the  interval
0..\f(CW\*(C`$Text::Bloom::p\-1\*(C'\fR, while the index  must
lie in 0..\fIsize\-1\fR. \f(CW$order\fR is
a small integer from 0 to \fId\-1\fR.
.PP
The default implementation is
.PP
.Vb 1
\&  index = m[order] * value + q[order]   (mod size)
.Ve
.PP
the values of \fIm\fR and \fIq\fR are taken from the array
\&\f(CW@Text::Bloom::hashParam\fR; the form of the  function
is taken from [2].
.SS "WriteToString"
.IX Subsection "WriteToString"
Convert the Bloom signature into a string which can be saved and
later restored with \f(CW\*(C`NewFromString\*(C'\fR. \f(CW\*(C`Compute\*(C'\fR must have
been called previously.
.PP
.Vb 1
\&  my $str = $b\->WriteToString();
.Ve
.PP
The string begins with a header which encodes the
originating package, its version, the parameters
of the current instance.
.PP
Whenever possible, \f(CW\*(C`Compress::Zlib\*(C'\fR is used in order to
compress the bit vector in the most efficient way.
On systems without \f(CW\*(C`Compress::Zlib\*(C'\fR, the bit string is
saved uncompressed.
.SS "WriteToFile"
.IX Subsection "WriteToFile"
These convenience functions just call their String counterparts
and read/write the file specified in the argument.
.PP
.Vb 1
\&  $b\->WriteToFile( \*(Aqfoo.sig\*(Aq );
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 2
\&  spinellia@acm.org (Andrea Spinelli)
\&  walter@humans.net (Walter Vannini)
.Ve
.SH "BIBLIOGRAPHY"
.IX Header "BIBLIOGRAPHY"
.IP "[1]" 4
.IX Item "[1]"
Burton H. Bloom, \*(L"Space/time trade-offs in hash coding with allowable errors\*(R",
\&\fICommunications of the \s-1ACM\s0\fR, \fB13\fR, 7, July 1970, pages 422\-426. (available
electronically from \s-1ACM\s0 Digital Library).
.IP "[2]" 4
.IX Item "[2]"
M. V. Ramakrishna, \*(L"Practical Performance of Bloom FIlters
and Parallel Free-Text Searching\*(R", 
\&\fICommunications of the \s-1ACM\s0\fR, \fB32\fR, 10, October 1989, pages 1237\-1239.
(available electronically from \s-1ACM\s0 Digital Library).
.SH "BUGS"
.IX Header "BUGS"
On Win32 we have experienced some instabilities when dealing
with a large number of signatures; in this case Perl crashes
without apparent explanation. The main suspect is  Bit::Vector,
but without any evidence.
.SH "HISTORY"
.IX Header "HISTORY"
.Vb 1
\&  2001\-11\-02 \- initial revision
.Ve
