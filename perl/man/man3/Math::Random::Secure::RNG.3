.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Random::Secure::RNG 3"
.TH Math::Random::Secure::RNG 3 "2011-01-25" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Random::Secure::RNG \- The underlying PRNG, as an object.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Math::Random::Secure::RNG;
\& my $rng = Math::Random::Secure::RNG\->new();
\& my $int = $rng\->irand();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This represents a random number generator, as an object.
.PP
Generally, you shouldn't have to worry about this, and you should just use
Math::Random::Secure. But if for some reason you want to modify how the
random number generator works or you want an object-oriented interface
to a random-number generator, you can use this.
.PP
Math::Random::Secure::RNG uses Any::Moose, meaning that it has a
\&\f(CW\*(C`new\*(C'\fR method that works like Mouse or Moose modules work.
.SH "METHODS"
.IX Header "METHODS"
.SS "irand"
.IX Subsection "irand"
Generates a random unsigned 32\-bit integer.
.SS "rand"
.IX Subsection "rand"
Generates a random floating-point number greater than or equal to 0
and less than 1.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
These are all options that can be passed to \f(CW\*(C`new()\*(C'\fR or called as methods
on an existing object.
.SS "rng"
.IX Subsection "rng"
The underlying random number generator. Defaults to an instance of
Math::Random::ISAAC.
.SS "seed"
.IX Subsection "seed"
The random data used to seed \*(L"rng\*(R", as a string of bytes. This should
be large enough to properly seed \*(L"rng\*(R". This means \fIminimally\fR, it
should be 8 bytes (64 bits) and more ideally, 32 bytes (256 bits) or 64 
bytes (512 bits). For an idea of how large your seed should be, see 
<http://burtleburtle.net/bob/crypto/magnitude.html#brute> for information
on how long it would take to brute-force seeds of each size.
.PP
Note that \f(CW\*(C`seed\*(C'\fR should not be an integer, but a \fBstring of bytes\fR.
.PP
It is very important that the seed be large enough, and also that the seed
be very random. \fBThere are serious attacks possible against random number
generators that are seeded with non-random data or with insufficient random
data.\fR
.PP
By default, we use a 512\-bit (64 byte) seed. If 
<Moore's Law> continues to hold
true, it will be approximately 1000 years before computers can brute-force a
512\-bit (64 byte) seed at any reasonable speed (and physics suggests that
computers will never actually become that fast, although there could always
be improvements or new methods of computing we can't now imagine, possibly
making Moore's Law continue to hold true forever).
.PP
If you pass this to \f(CW\*(C`new()\*(C'\fR, \*(L"seeder\*(R" and \*(L"seed_size\*(R" will be ignored.
.SS "seeder"
.IX Subsection "seeder"
An instance of Crypt::Random::Source::Base that will be used to
get the seed for \*(L"rng\*(R".
.SS "seed_size"
.IX Subsection "seed_size"
How much data (in bytes) should be read using \*(L"seeder\*(R" to seed \*(L"rng\*(R".
Defaults to 64 bytes (which is 512 bits).
.PP
See \*(L"seed\*(R" for more info about what is a reasonable seed size.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Random::Secure
