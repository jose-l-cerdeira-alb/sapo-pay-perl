.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "User::Identity::Archive::Plain 3"
.TH User::Identity::Archive::Plain 3 "2018-01-24" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
User::Identity::Archive::Plain \- simple, plain text archiver
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& User::Identity::Archive::Plain
\&   is an User::Identity::Archive
\&   is an User::Identity::Item
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use User::Identity::Archive::Plain;
\& my $friends = User::Identity::Archive::Plain\->new(\*(Aqfriends\*(Aq);
\& $friends\->from(\e*FH);
\& $friends\->from(\*(Aq.friends\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This archiver, which extends User::Identity::Archive, uses a very
simple plain text file to store the information of users.  The syntax
is described in the \s-1DETAILS\s0 section, below.
.PP
Extends \*(L"\s-1DESCRIPTION\*(R"\s0 in User::Identity::Archive.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
Extends \*(L"\s-1OVERLOADED\*(R"\s0 in User::Identity::Archive.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\*(R"\s0 in User::Identity::Archive.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in User::Identity::Archive.
.ie n .IP "User::Identity::Archive::Plain\->\fBnew\fR( [$name], %options )" 4
.el .IP "User::Identity::Archive::Plain\->\fBnew\fR( [$name], \f(CW%options\fR )" 4
.IX Item "User::Identity::Archive::Plain->new( [$name], %options )"
.Vb 8
\& \-Option       \-\-Defined in             \-\-Default
\&  abbreviations                           []
\&  description    User::Identity::Item     undef
\&  from           User::Identity::Archive  undef
\&  name           User::Identity::Item     <required>
\&  only                                    []
\&  parent         User::Identity::Item     undef
\&  tabstop                                 8
.Ve
.RS 4
.IP "abbreviations => HASH|ARRAY" 2
.IX Item "abbreviations => HASH|ARRAY"
Adds a set of abbreviations for collections to the syntax of the
plain text archiver.  See section \*(L"Simplified class names\*(R" for
a list of predefined names.
.IP "description => \s-1STRING\s0" 2
.IX Item "description => STRING"
.PD 0
.IP "from => FILEHANDLE|FILENAME" 2
.IX Item "from => FILEHANDLE|FILENAME"
.IP "name => \s-1STRING\s0" 2
.IX Item "name => STRING"
.IP "only => ARRAY|ABBREV" 2
.IX Item "only => ARRAY|ABBREV"
.PD
Lists the only information (as (list of) abbreviations) which should be
read.  Other information is removed before even checking whether it is
a valid abbreviation or not.
.IP "parent => \s-1OBJECT\s0" 2
.IX Item "parent => OBJECT"
.PD 0
.IP "tabstop => \s-1INTEGER\s0" 2
.IX Item "tabstop => INTEGER"
.PD
Sets the default tab-stop width.
.RE
.RS 4
.RE
.SS "Attributes"
.IX Subsection "Attributes"
Extends \*(L"Attributes\*(R" in User::Identity::Archive.
.ie n .IP "$obj\->\fBabbreviation\fR( $name, [$class] )" 4
.el .IP "\f(CW$obj\fR\->\fBabbreviation\fR( \f(CW$name\fR, [$class] )" 4
.IX Item "$obj->abbreviation( $name, [$class] )"
Returns the class which is capable of storing information which is
grouped as \f(CW$name\fR.  With \f(CW$class\fR argument, you add (or overrule) the
definitions of an abbreviation.  The \f(CW$class\fR is automatically loaded.
.Sp
If \f(CW$class\fR is \f(CW\*(C`undef\*(C'\fR, then the abbreviation is deleted.  The class
name which is deleted is returned.
.ie n .IP "$obj\->\fBabbreviations\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBabbreviations\fR()" 4
.IX Item "$obj->abbreviations()"
Returns a sorted list of all names which are known as abbreviations.
.ie n .IP "$obj\->\fBdefaultTabStop\fR( [$integer] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTabStop\fR( [$integer] )" 4
.IX Item "$obj->defaultTabStop( [$integer] )"
Returns the width of a tab, optionally after setting it.  This must be
the same as set in your editor.
.ie n .IP "$obj\->\fBdescription\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdescription\fR()" 4
.IX Item "$obj->description()"
Inherited, see \*(L"Attributes\*(R" in User::Identity::Item
.ie n .IP "$obj\->\fBname\fR( [$newname] )" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR( [$newname] )" 4
.IX Item "$obj->name( [$newname] )"
Inherited, see \*(L"Attributes\*(R" in User::Identity::Item
.SS "Collections"
.IX Subsection "Collections"
Extends \*(L"Collections\*(R" in User::Identity::Archive.
.ie n .IP "$obj\->\fBadd\fR($collection, $role)" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR($collection, \f(CW$role\fR)" 4
.IX Item "$obj->add($collection, $role)"
Inherited, see \*(L"Collections\*(R" in User::Identity::Item
.ie n .IP "$obj\->\fBaddCollection\fR( $object | <[$type], %options> )" 4
.el .IP "\f(CW$obj\fR\->\fBaddCollection\fR( \f(CW$object\fR | <[$type], \f(CW%options\fR> )" 4
.IX Item "$obj->addCollection( $object | <[$type], %options> )"
Inherited, see \*(L"Collections\*(R" in User::Identity::Item
.ie n .IP "$obj\->\fBcollection\fR($name)" 4
.el .IP "\f(CW$obj\fR\->\fBcollection\fR($name)" 4
.IX Item "$obj->collection($name)"
Inherited, see \*(L"Collections\*(R" in User::Identity::Item
.ie n .IP "$obj\->\fBparent\fR( [$parent] )" 4
.el .IP "\f(CW$obj\fR\->\fBparent\fR( [$parent] )" 4
.IX Item "$obj->parent( [$parent] )"
Inherited, see \*(L"Collections\*(R" in User::Identity::Item
.ie n .IP "$obj\->\fBremoveCollection\fR($object|$name)" 4
.el .IP "\f(CW$obj\fR\->\fBremoveCollection\fR($object|$name)" 4
.IX Item "$obj->removeCollection($object|$name)"
Inherited, see \*(L"Collections\*(R" in User::Identity::Item
.ie n .IP "$obj\->\fBtype\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR()" 4
.IX Item "$obj->type()"
.PD 0
.IP "User::Identity::Archive::Plain\->\fBtype\fR()" 4
.IX Item "User::Identity::Archive::Plain->type()"
.PD
Inherited, see \*(L"Collections\*(R" in User::Identity::Item
.ie n .IP "$obj\->\fBuser\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBuser\fR()" 4
.IX Item "$obj->user()"
Inherited, see \*(L"Collections\*(R" in User::Identity::Item
.SS "Searching"
.IX Subsection "Searching"
Extends \*(L"Searching\*(R" in User::Identity::Archive.
.ie n .IP "$obj\->\fBfind\fR($collection, $role)" 4
.el .IP "\f(CW$obj\fR\->\fBfind\fR($collection, \f(CW$role\fR)" 4
.IX Item "$obj->find($collection, $role)"
Inherited, see \*(L"Searching\*(R" in User::Identity::Item
.SS "Access to the archive"
.IX Subsection "Access to the archive"
Extends \*(L"Access to the archive\*(R" in User::Identity::Archive.
.ie n .IP "$obj\->\fBfrom\fR( <$fh|$filename|ARRAY>, %options )" 4
.el .IP "\f(CW$obj\fR\->\fBfrom\fR( <$fh|$filename|ARRAY>, \f(CW%options\fR )" 4
.IX Item "$obj->from( <$fh|$filename|ARRAY>, %options )"
Read the plain text information from the specified \f(CW$fh\fR, \f(CW$filename\fR,
\&\s-1STRING,\s0 or \s-1ARRAY\s0 of lines.
.Sp
.Vb 3
\& \-Option \-\-Default
\&  tabstop  <default from object>
\&  verbose  0
.Ve
.RS 4
.IP "tabstop => \s-1INTEGER\s0" 2
.IX Item "tabstop => INTEGER"
.PD 0
.IP "verbose => \s-1INTEGER\s0" 2
.IX Item "verbose => INTEGER"
.RE
.RS 4
.RE
.PD
.SH "DETAILS"
.IX Header "DETAILS"
.SS "The Plain Archiver Format"
.IX Subsection "The Plain Archiver Format"
\fISimplified class names\fR
.IX Subsection "Simplified class names"
.PP
It is too much work to specify full class named on each spot where you
want to create a new object with data.  Therefore, abbreviations are
introduced.  Use new(abbreviations) or \fBabbreviations()\fR to add extra
abbreviations or to overrule some predefined.
.PP
Predefined names:
  user         User::Identity
  email        Mail::Identity
  location     User::Identity::Location
  system       User::Identity::System
  list         User::Identity::Collection::Emails
.PP
It would have been nicer to refer to a \fIperson\fR in stead of a \fIuser\fR,
however that would add to the confusion with the name-space.
.PP
\fIIndentation says all\fR
.IX Subsection "Indentation says all"
.PP
The syntax is as simple as possible. An extra indentation on a line
means that the variable or class is a collection within the class on
the line before.
.PP
.Vb 8
\& user markov
\&   location home
\&      country NL
\&   email home
\&      address  mark@overmeer.net
\&      location home
\&   email work
\&      address  solutions@overmeer.bet
\&
\& email tux
\&    address tux@fish.net
.Ve
.PP
The above defines two items: one User::Identity named \f(CW\*(C`markov\*(C'\fR, and
an e\-mail address \f(CW\*(C`tux\*(C'\fR.  The user has two collections: one contains
a single location, and one stores two e\-mail addresses.
.PP
To add to the confusion: the \f(CW\*(C`location\*(C'\fR is defined as field in \f(CW\*(C`email\*(C'\fR
and as collection.  The difference is easily detected: if there are
indented fields following the line it is a collection.  Mistakes will
in most cases result in an error message.
.PP
\fILong lines\fR
.IX Subsection "Long lines"
.PP
If you want to continue on the next line, because your content is too
large, then add a backslash to the end, like this:
.PP
.Vb 5
\& email home
\&    description This is my home address,     \e
\&                But I sometimes use this for \e
\&                work as well
\&    address tux@fish.aq
.Ve
.PP
Continuations do not play the game of indentation, so what you also
can do is:
.PP
.Vb 6
\& email home
\&    description               \e
\& This is my home address,     \e
\& But I sometimes use this for \e
\& work as well
\&    address tux@fish.aq
.Ve
.PP
The fields \f(CW\*(C`comment\*(C'\fR and \f(CW\*(C`address\*(C'\fR must be correctly indented.
The line terminations are lost, which is useful for most fields.  However,
if you need them, you have to check the description of the applicable field.
.PP
\fIComments\fR
.IX Subsection "Comments"
.PP
You may add comments and white spaces.  Comments start with a \f(CW\*(Aq#\*(Aq\fR as
first non-blank character on the line.  Comments are \fBnot allowed\fR on
the same line as real data, as some languages (like Perl) permit.
.PP
You can insert comments and blank lines on all places where you need
them:
.PP
.Vb 1
\& user markov
\&
\&    # my home address
\&    email home
\&
\&       # useless comment statement
\&       address tux@fish.aq
\&       location #mind_the_hash
.Ve
.PP
is equivalent to:
.PP
.Vb 4
\& user markov
\&    email home
\&       address tux@fish.aq
\&       location #mind_the_hash
.Ve
.PP
\fIReferences\fR
.IX Subsection "References"
.PP
Often you will have the need to add the same information to two items,
for instance, multiple people share the same address.  In this case,
you can create a reference.  However, this is only permitted for
whole items: you can refer to someone's location, but not to the person's
street.
.PP
To create a reference to an item of someone else, use
.PP
.Vb 4
\& user markov
\&    location home = user(cleo).location(home)
\&    location work
\&       organization   MARKOV Solutions
.Ve
.PP
\fIConfiguration parameters\fR
.IX Subsection "Configuration parameters"
.PP
You can add some configuration lines as well.  On the moment, the only
one defined is
.PP
.Vb 1
\& tabstop = 4
.Ve
.PP
which can be used to change the meaning of tabs in the file.  The default
setting is 8, but some people prefer 4 (or other values).
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: $object is not a collection." 4
.el .IP "Error: \f(CW$object\fR is not a collection." 4
.IX Item "Error: $object is not a collection."
The first argument is an object, but not of a class which extends
User::Identity::Collection.
.ie n .IP "Error: Cannot load collection module for $type ($class)." 4
.el .IP "Error: Cannot load collection module for \f(CW$type\fR ($class)." 4
.IX Item "Error: Cannot load collection module for $type ($class)."
Either the specified \f(CW$type\fR does not exist, or that module named \f(CW$class\fR returns
compilation errors.  If the type as specified in the warning is not
the name of a package, you specified a nickname which was not defined.
Maybe you forgot the 'require' the package which defines the nickname.
.ie n .IP "Warning: Cannot read archive from $source" 4
.el .IP "Warning: Cannot read archive from \f(CW$source\fR" 4
.IX Item "Warning: Cannot read archive from $source"
.PD 0
.ie n .IP "Error: Creation of a collection via $class failed." 4
.el .IP "Error: Creation of a collection via \f(CW$class\fR failed." 4
.IX Item "Error: Creation of a collection via $class failed."
.PD
The \f(CW$class\fR did compile, but it was not possible to create an object
of that class using the options you specified.
.IP "Error: Don't know what type of collection you want to add." 4
.IX Item "Error: Don't know what type of collection you want to add."
If you add a collection, it must either by a collection object or a
list of options which can be used to create a collection object.  In
the latter case, the type of collection must be specified.
.ie n .IP "Warning: No collection $name" 4
.el .IP "Warning: No collection \f(CW$name\fR" 4
.IX Item "Warning: No collection $name"
The collection with \f(CW$name\fR does not exist and can not be created.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of User-Identity distribution version 0.99,
built on January 24, 2018. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2003\-2018 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
