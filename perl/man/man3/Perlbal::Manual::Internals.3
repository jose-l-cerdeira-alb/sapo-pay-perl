.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perlbal::Manual::Internals 3"
.TH Perlbal::Manual::Internals 3 "2011-09-03" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perlbal::Manual::Internals \- Perlbal's architecture at a glance
.SS "\s-1VERSION\s0"
.IX Subsection "VERSION"
Perlbal 1.78.
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
Connections come in from wherever and get to the TCPListener. It uses Service objects to determine what kind of Client* to spawn. The Client classes then handle crafting the response for the user.
.PP
.Vb 11
\&                            {{ INTERNET }}
\&                                  |
\&                                  v
\&              [Service]<===>[TCPListener]
\&                          _\|_\|_/    |    \e_\|_\|_
\&                         v        v        v
\&             [ClientManage]  [ClientHTTP] [ClientProxy]
\&                                                ^
\&                                                |
\&                                                v
\&                                          [BackendHTTP]
.Ve
.PP
Perlbal decides what backend to send a request to randomly (only presently supported method). If that service has idle backend connections available, configured by \f(CW\*(C`backend_persist\*(C'\fR and \f(CW\*(C`connect_ahead\*(C'\fR, it will reuse those connections and greatly reduce latency. See more detail in Perlbal::Manual::LoadBalancer.
.PP
Perlbal also specializes in \*(L"spoonfeeding\*(R" data to slow clients. This allows backends to continue serving requests while Perlbal transfers responses back as fast as the client can read.
.SS "Classes"
.IX Subsection "Classes"
The following is a brief introduction/overview to the main Perlbal's classes:
.PP
\fIPerlbal::Socket\fR
.IX Subsection "Perlbal::Socket"
.PP
Descends from Danga::Socket.
.PP
Adds on to the base class to provide some functionality specifically useful for creating \s-1HTTP\s0 sockets.
.PP
Fields
.IX Subsection "Fields"
.IP "headers_string" 4
.IX Item "headers_string"
Headers as they're being read.
.IP "req_headers" 4
.IX Item "req_headers"
The final Perlbal::HTTPHeaders object inbound.
.IP "res_headers" 4
.IX Item "res_headers"
Response headers outbound (Perlbal::HTTPHeaders object).
.IP "create_time" 4
.IX Item "create_time"
Creation time.
.IP "alive_time" 4
.IX Item "alive_time"
Last time noted alive.
.IP "state" 4
.IX Item "state"
General purpose state; used by descendants.
.IP "do_die" 4
.IX Item "do_die"
If on, die and do no further requests.
.IP "read_buf" 4
.IX Item "read_buf"
Arrayref of scalarref read from client.
.IP "read_ahead" 4
.IX Item "read_ahead"
Bytes sitting in read_buf.
.IP "read_size" 4
.IX Item "read_size"
Total bytes read from client, ever.
.IP "ditch_leading_rn" 4
.IX Item "ditch_leading_rn"
If true, the next header parsing will ignore a leading \er\en.
.IP "observed_ip_string" 4
.IX Item "observed_ip_string"
If defined, contains the observed \s-1IP\s0 string of the peer we're serving. This is intended for holding the value of the X\-Forwarded-For and using it to govern ACLs.
.PP
\fIPerlbal::TCPListener\fR
.IX Subsection "Perlbal::TCPListener"
.PP
Descends from Perlbal::Socket.
.PP
Very lightweight and fast connection accept class. Takes incoming connections as fast as possible and passes them off, instantiating one of the various Client* classes to handle it.
.PP
Fields
.IX Subsection "Fields"
.IP "service" 4
.IX Item "service"
Perlbal::Service.
.IP "hostport" 4
.IX Item "hostport"
Scalar \s-1IP\s0 port of where this service is listening for new connections.
.IP "sslopts" 4
.IX Item "sslopts"
The \s-1SSL\s0 Options.
.Sp
.Vb 2
\&    use Data::Dumper;
\&    warn Dumper( $tcp_listener\->{\*(Aqsslopts\*(Aq} );
.Ve
.Sp
The above lines would print something like the following:
.Sp
.Vb 9
\&    $VAR1 = {
\&              \*(Aqssl\*(Aq => {
\&                         \*(AqSSL_cipher_list\*(Aq => \*(Aq...\*(Aq,
\&                         \*(AqSSL_cert_file\*(Aq => \*(Aq...\*(Aq,
\&                         \*(AqSSL_key_file\*(Aq => \*(Aq,,,\*(Aq,
\&                         \*(AqSSL_ca_path\*(Aq => \*(Aq...\*(Aq,
\&                         \*(AqSSL_verify_mode\*(Aq => \*(Aq...\*(Aq
\&                       }
\&            };
.Ve
.IP "v6" 4
.IX Item "v6"
Boolean value stating whether the installation of Perlbal supports IPv6 (which basically boils down to Danga::Socket v1.6.1 and IO::Socket::INET6 being available).
.PP
\fIPerlbal::BackendHTTP\fR
.IX Subsection "Perlbal::BackendHTTP"
.PP
Descends from Perlbal::Socket.
.PP
This class handles connections to the backend web nodes for getting data back to the user. This class is used by other classes such as Perlbal::ClientProxy to send a request to an internal node.
.PP
Fields
.IX Subsection "Fields"
.IP "client" 4
.IX Item "client"
Perlbal::ClientProxy connection, or undef.
.IP "service" 4
.IX Item "service"
Perlbal::Service.
.IP "pool" 4
.IX Item "pool"
Perlbal::Pool; whatever pool we spawned from.
.IP "ip" 4
.IX Item "ip"
\&\s-1IP\s0 scalar.
.IP "port" 4
.IX Item "port"
Port scalar.
.IP "ipport" 4
.IX Item "ipport"
\&\f(CW\*(C`$ip:$port\*(C'\fR.
.IP "reportto" 4
.IX Item "reportto"
Object; must implement reporter interface.
.IP "has_attention" 4
.IX Item "has_attention"
Has been accepted by a webserver and we know for sure we're not just talking to the \s-1TCP\s0 stack.
.IP "waiting_options" 4
.IX Item "waiting_options"
If true, we're waiting for an \s-1OPTIONS\s0 * response to determine when we have attention.
.IP "disconnect_at" 4
.IX Item "disconnect_at"
Time this connection will be disconnected, if it's kept-alive and backend told us; otherwise \f(CW\*(C`undef\*(C'\fR for unknown.
.IP "content_length" 4
.IX Item "content_length"
Length of document being transferred. Only applies when the backend server sends a content-length header.
.IP "content_length_remain" 4
.IX Item "content_length_remain"
Bytes remaining to be read. Only applies when the backend server sends a content-length header.
.IP "use_count" 4
.IX Item "use_count"
Number of requests this backend's been used for.
.IP "generation" 4
.IX Item "generation"
Int; counts what generation we were spawned in.
.IP "buffered_upload_mode" 4
.IX Item "buffered_upload_mode"
Boolean. If on, we're doing a buffered upload transmit.
.IP "scratch" 4
.IX Item "scratch"
Extra storage; plugins can use it if they want.
.PP
\fIPerlbal::HTTPHeaders\fR
.IX Subsection "Perlbal::HTTPHeaders"
.PP
Header management. Parses headers (request and response) and stores data for further user. Also manages validation of the request line so that it conforms to \s-1HTTP\s0 specifications.
.PP
Fields
.IX Subsection "Fields"
.IP "headers" 4
.IX Item "headers"
href; lowercase header \-> comma-sep list of values.
.IP "origcase" 4
.IX Item "origcase"
Href; lowercase header \-> provided case.
.IP "hdorder" 4
.IX Item "hdorder"
Aref; order headers were received (canonical order).
.IP "method" 4
.IX Item "method"
Scalar; request method (if \s-1GET\s0 request).
.IP "uri" 4
.IX Item "uri"
Scalar; request \s-1URI\s0 (if \s-1GET\s0 request).
.IP "type" 4
.IX Item "type"
\&\f(CW\*(C`res\*(C'\fR or \f(CW\*(C`req\*(C'\fR.
.IP "code" 4
.IX Item "code"
\&\s-1HTTP\s0 response status code.
.IP "codetext" 4
.IX Item "codetext"
Status text that for response code.
.IP "ver" 4
.IX Item "ver"
Version (string) \*(L"1.1\*(R".
.IP "vernum" 4
.IX Item "vernum"
Version (number: major*1000+minor): \*(L"1.1\*(R" => 1001.
.IP "responseLine" 4
.IX Item "responseLine"
First line of \s-1HTTP\s0 response (if response).
.IP "requestLine" 4
.IX Item "requestLine"
First line of \s-1HTTP\s0 request (if request).
.PP
\fIPerlbal::ClientHTTPBase\fR
.IX Subsection "Perlbal::ClientHTTPBase"
.PP
Descends from Perlbal::Socket.
.PP
Provides base functionality to Perlbal::ClientHTTP and Perlbal::ClientProxy. Notably, the ability to efficiently send files to the remote user. Also handles most of the state logic for statistics and such. Is also used for services of type \f(CW\*(C`selector\*(C'\fR. Perlbal::ClientHTTPBase then reads in the request headers, and asks the service to re-bless the client instance to a more specific type, for either a Perlbal::ClientProxy or Perlbal::ClientHTTP (depending on selector's mapping).
.PP
Fields
.IX Subsection "Fields"
.IP "service" 4
.IX Item "service"
Perlbal::Service object.
.IP "replacement_uri" 4
.IX Item "replacement_uri"
\&\s-1URI\s0 to send instead of the one requested; this is used to instruct \f(CW\*(C`_serve_request\*(C'\fR to send an index file instead of trying to serve a directory and failing.
.IP "scratch" 4
.IX Item "scratch"
Extra storage; plugins can use it if they want.
.IP "reproxy_file" 4
.IX Item "reproxy_file"
Filename the backend told us to start opening.
.IP "reproxy_file_size" 4
.IX Item "reproxy_file_size"
Size of file, once we \f(CW\*(C`stat()\*(C'\fR it.
.IP "reproxy_fh" 4
.IX Item "reproxy_fh"
If needed, IO::Handle of fd.
.IP "reproxy_file_offset" 4
.IX Item "reproxy_file_offset"
How much we've sent from the file.
.IP "post_sendfile_cb" 4
.IX Item "post_sendfile_cb"
Subref to run after we're done sendfile'ing the current file.
.IP "requests" 4
.IX Item "requests"
Number of requests this object has performed for the user.
.IP "selector_svc" 4
.IX Item "selector_svc"
The original service from which we came.
.IP "is_ssl" 4
.IX Item "is_ssl"
Whether the socket was \s-1SSL\s0 attached (restricted operations).
.PP
\fIPerlbal::ClientHTTP\fR
.IX Subsection "Perlbal::ClientHTTP"
.PP
Descends from Perlbal::ClientHTTPBase.
.PP
Very simple and lightweight class. Handles sending files to the user without much overhead. Most of the functionality is contained in the parent class, and this class doesn't implement much new stuff.
.PP
Fields
.IX Subsection "Fields"
.IP "put_in_progress" 4
.IX Item "put_in_progress"
1 when we're currently waiting for an async job to return.
.IP "put_fh" 4
.IX Item "put_fh"
File handle to use for writing data.
.IP "put_fh_filename" 4
.IX Item "put_fh_filename"
Filename of put_fh.
.IP "put_pos" 4
.IX Item "put_pos"
File offset to write next data at.
.IP "content_length" 4
.IX Item "content_length"
Length of document being transferred.
.IP "content_length_remain" 4
.IX Item "content_length_remain"
Bytes remaining to be read.
.IP "chunked_upload_state" 4
.IX Item "chunked_upload_state"
Boolean/obj: if processing a chunked upload, Perlbal::ChunkedUploadState object, else undef.
.PP
\fIPerlbal::ClientProxy\fR
.IX Subsection "Perlbal::ClientProxy"
.PP
Descends from Perlbal::ClientHTTPBase.
.PP
Takes an incoming connection from a user and connects to a backend node (\f(CW\*(C`Perlbal::BackendHTTP\*(C'\fR) and relays the request. The backend can then either tell the proxy to reproxy and load a file from disk, or return a file directly, or just return a status message.
.PP
Fields
.IX Subsection "Fields"
.IP "backend" 4
.IX Item "backend"
Perlbal::BackendHTTP object (or \f(CW\*(C`undef\*(C'\fR if disconnected).
.IP "backend_requested" 4
.IX Item "backend_requested"
True if we've requested a backend for this request.
.IP "reconnect_count" 4
.IX Item "reconnect_count"
Number of times we've tried to reconnect to backend.
.IP "high_priority" 4
.IX Item "high_priority"
Boolean; 1 if we are or were in the high priority queue.
.IP "low_priority" 4
.IX Item "low_priority"
Boolean; 1 if we are or were in the low priority queue.
.IP "reproxy_uris" 4
.IX Item "reproxy_uris"
Arrayref; URIs to reproxy to, in order.
.IP "reproxy_expected_size" 4
.IX Item "reproxy_expected_size"
Int: size of response we expect to get back for reproxy.
.IP "currently_reproxying" 4
.IX Item "currently_reproxying"
Arrayref; the host info and \s-1URI\s0 we're reproxying right now.
.IP "content_length_remain" 4
.IX Item "content_length_remain"
Int: amount of data we're still waiting for.
.IP "responded" 4
.IX Item "responded"
Bool: whether we've already sent a response to the user or not.
.IP "last_request_time" 4
.IX Item "last_request_time"
Int: time that we last received a request.
.IP "primary_res_hdrs" 4
.IX Item "primary_res_hdrs"
If defined, we are doing a transparent reproxy-URI and the headers we get back aren't necessarily the ones we want. Instead, get most headers from the provided \f(CW\*(C`res\*(C'\fR headers object here.
.IP "is_buffering" 4
.IX Item "is_buffering"
Bool; if we're buffering some/all of a request to memory/disk.
.IP "is_writing" 4
.IX Item "is_writing"
Bool; if on, we currently have an \f(CW\*(C`aio_write\*(C'\fR out.
.IP "start_time" 4
.IX Item "start_time"
Hi-res time when we started getting data to upload.
.IP "bufh" 4
.IX Item "bufh"
Buffered upload filehandle object.
.IP "bufilename" 4
.IX Item "bufilename"
String; buffered upload filename.
.IP "bureason" 4
.IX Item "bureason"
String; if defined, the reason we're buffering to disk.
.IP "buoutpos" 4
.IX Item "buoutpos"
Int; buffered output position.
.IP "backend_stalled" 4
.IX Item "backend_stalled"
Boolean: if backend has shut off its reads because we're too slow.
.IP "unread_data_waiting" 4
.IX Item "unread_data_waiting"
Boolean: if we shut off reads while we know data is yet to be read from client.
.IP "chunked_upload_state" 4
.IX Item "chunked_upload_state"
Bool/obj: if processing a chunked upload, Perlbal::ChunkedUploadState object, else undef.
.IP "request_body_length" 4
.IX Item "request_body_length"
Integer: request's body length, either as-declared, or calculated after chunked upload is complete.
.IP "last_upload_packet" 4
.IX Item "last_upload_packet"
Unixtime we last sent a \s-1UDP\s0 upload packet. For perlbal sending out \s-1UDP\s0 packets related to upload status (for xmlhttprequest upload bar).
.IP "upload_session" 4
.IX Item "upload_session"
Client's self-generated upload session. For perlbal sending out \s-1UDP\s0 packets related to upload status (for xmlhttprequest upload bar).
.IP "retry_count" 4
.IX Item "retry_count"
Number of times we've retried this request so far after getting \f(CW500\fR errors.
.PP
\fIPerlbal::ClientManage\fR
.IX Subsection "Perlbal::ClientManage"
.PP
Descends from Perlbal::Socket.
.PP
Simple interface that provides a way for users to use the management interface of Perlbal. You can connect to the management port (as defined in the config file) with a web browser or regular telnet (see Perlbal::Manual::Management for more information on this).
.PP
Fields
.IX Subsection "Fields"
.IP "service" 4
.IX Item "service"
Perlbal::Service.
.IP "buf" 4
.IX Item "buf"
Read buffer.
.IP "is_http" 4
.IX Item "is_http"
Boolean stating whether the request is \s-1HTTP\s0.
.IP "ctx" 4
.IX Item "ctx"
Perlbal::CommandContext.
.PP
\fIPerlbal::Service\fR
.IX Subsection "Perlbal::Service"
.PP
A service is a particular item that Perlbal is doing. Services can have a role which defines how they behave. Each service can also have a bunch of parameters set to further adjust its behavior. By itself, the Service class handles maintaining pools of backend connections and managing statistics about itself.
.PP
Fields
.IX Subsection "Fields"
.IP "name" 4
.IX Item "name"
Name of the service.
.IP "role" 4
.IX Item "role"
Role type (\f(CW\*(C`web_server\*(C'\fR, \f(CW\*(C`reverse_proxy\*(C'\fR, etc).
.IP "enabled" 4
.IX Item "enabled"
Boolean; whether we're enabled or not (enabled = listening).
.IP "pool" 4
.IX Item "pool"
Perlbal::Pool that we're using to allocate nodes if we're in proxy mode.
.IP "listener" 4
.IX Item "listener"
Perlbal::TCPListener object, when enabled.
.IP "reproxy_cache" 4
.IX Item "reproxy_cache"
Perlbal::Cache object, when enabled.
.PP
End-user tunables
.IX Subsection "End-user tunables"
.IP "listen" 4
.IX Item "listen"
\&\f(CW\*(C`IP:port\*(C'\fR of where we're listening for new connections.
.IP "docroot" 4
.IX Item "docroot"
Document root for \f(CW\*(C`web_server\*(C'\fR role.
.IP "dirindexing" 4
.IX Item "dirindexing"
Boolean; directory indexing (for \f(CW\*(C`web_server\*(C'\fR role). Not async.
.IP "index_files" 4
.IX Item "index_files"
Arrayref of filenames to try for index files.
.IP "enable_concatenate_get" 4
.IX Item "enable_concatenate_get"
Boolean; if user can request concatenated files.
.IP "enable_put" 4
.IX Item "enable_put"
Boolean; whether \s-1PUT\s0 is supported.
.IP "max_put_size" 4
.IX Item "max_put_size"
Max size in bytes of a put file.
.IP "max_chunked_request_size" 4
.IX Item "max_chunked_request_size"
Max size in bytes of a chunked request (to be written to disk first).
.IP "min_put_directory" 4
.IX Item "min_put_directory"
Number of directories required to exist at beginning of URIs in put.
.IP "enable_delete" 4
.IX Item "enable_delete"
Boolean; whether \s-1DELETE\s0 is supported.
.IP "high_priority_cookie" 4
.IX Item "high_priority_cookie"
Cookie name to check if the client's requests should be considered high priority.
.Sp
See also \f(CW\*(C`high_priority_cookie_contents\*(C'\fR.
.IP "high_priority_cookie_contents" 4
.IX Item "high_priority_cookie_contents"
Aforementioned cookie value must contain this substring.
.IP "backend_persist_cache" 4
.IX Item "backend_persist_cache"
Max number of persistent backends to hold onto while no clients.
.IP "persist_client" 4
.IX Item "persist_client"
Boolean; persistent connections for clients.
.IP "persist_backend" 4
.IX Item "persist_backend"
Boolean; persistent connections for backends.
.IP "verify_backend" 4
.IX Item "verify_backend"
Boolean; get attention of backend before giving it clients (using \s-1OPTIONS\s0).
.IP "verify_backend_path" 4
.IX Item "verify_backend_path"
Path to check with the \s-1OPTIONS\s0 request (default is \f(CW\*(C`*\*(C'\fR).
.IP "max_backend_uses" 4
.IX Item "max_backend_uses"
Max requests to send per kept-alive backend (default 0 = unlimited).
.IP "connect_ahead" 4
.IX Item "connect_ahead"
Number of spare backends to connect to in advance all the time.
.IP "buffer_size" 4
.IX Item "buffer_size"
How much data a Perlbal::ClientProxy object should buffer from a backend.
.IP "buffer_size_reproxy_url" 4
.IX Item "buffer_size_reproxy_url"
Same as above but for backends that are reproxying for us.
.IP "queue_relief_size" 4
.IX Item "queue_relief_size"
Number of outstanding standard priority connections to activate pressure relief at.
.IP "queue_relief_chance" 4
.IX Item "queue_relief_chance"
Int, 0\-100; % chance to take a standard priority request when we're in pressure relief mode.
.IP "trusted_upstream_proxies" 4
.IX Item "trusted_upstream_proxies"
Array of Net::Netmask objects containing netmasks for trusted upstreams.
.IP "always_trusted" 4
.IX Item "always_trusted"
Boolean; if true, always trust upstreams.
.IP "blind_proxy" 4
.IX Item "blind_proxy"
Boolean; if true, do not modify \f(CW\*(C`X\-Forwarded\-For\*(C'\fR, \f(CW\*(C`X\-Host\*(C'\fR, or \f(CW\*(C`X\-Forwarded\-Host\*(C'\fR headers.
.IP "enable_reproxy" 4
.IX Item "enable_reproxy"
Boolean; if true, advertise that server will reproxy files and/or URLs.
.IP "reproxy_cache_maxsize" 4
.IX Item "reproxy_cache_maxsize"
Maximum number of reproxy results to be cached. (0 is disabled and default).
.IP "client_sndbuf_size" 4
.IX Item "client_sndbuf_size"
Bytes for \f(CW\*(C`SO_SNDBUF\*(C'\fR.
.IP "server_process" 4
.IX Item "server_process"
Path to server process (executable).
.IP "persist_client_idle_timeout" 4
.IX Item "persist_client_idle_timeout"
Keep-alive timeout in seconds for clients (default is 30).
.IP "idle_timeout" 4
.IX Item "idle_timeout"
Idle timeout outside of keep-alive time (default is 30).
.PP
Internal state
.IX Subsection "Internal state"
.IP "waiting_clients" 4
.IX Item "waiting_clients"
Arrayref of clients waiting for backendhttp connections.
.IP "waiting_clients_highpri" 4
.IX Item "waiting_clients_highpri"
Arrayref of high-priority clients waiting for backendhttp connections.
.IP "waiting_clients_lowpri" 4
.IX Item "waiting_clients_lowpri"
Arrayref of low-priority clients waiting for backendhttp connections.
.IP "waiting_client_count" 4
.IX Item "waiting_client_count"
Number of clients waiting for backends.
.IP "waiting_client_map" 4
.IX Item "waiting_client_map"
Map of clientproxy fd \-> 1 (if they're waiting for a connection).
.IP "pending_connects" 4
.IX Item "pending_connects"
Hashref of \f(CW\*(C`ip:port\*(C'\fR \-> \f(CW$time\fR (only one pending connect to backend at a time).
.IP "pending_connect_count" 4
.IX Item "pending_connect_count"
Number of outstanding backend connects.
.IP "bored_backends" 4
.IX Item "bored_backends"
Arrayref of backends we've already connected to, but haven't got clients.
.IP "hooks" 4
.IX Item "hooks"
Hashref: hookname => [ [ plugin, ref ], [ plugin, ref ], ... ].
.IP "plugins" 4
.IX Item "plugins"
Hashref: name => 1.
.IP "plugin_order" 4
.IX Item "plugin_order"
Arrayref: name, name, name...
.IP "plugin_setters" 4
.IX Item "plugin_setters"
Hashref: { plugin_name => { key_name => coderef } }.
.IP "extra_config" 4
.IX Item "extra_config"
Hashref with extra config options; name => values.
.IP "spawn_lock" 4
.IX Item "spawn_lock"
Boolean; if true, we're currently in \f(CW\*(C`spawn_backends\*(C'\fR.
.IP "extra_headers" 4
.IX Item "extra_headers"
{ insert => [ [ header, value ], ... ], remove => [ header, header, ... ], set => [ [ header, value ], ... ] }.
.Sp
Used in header management interface.
.IP "generation" 4
.IX Item "generation"
Int; generation count so we can slough off backends from old pools.
.IP "backend_no_spawn" 4
.IX Item "backend_no_spawn"
{ \*(L"ip:port\*(R" => 1 }.
.Sp
If on, \f(CW\*(C`spawn_backends\*(C'\fR will ignore this \f(CW\*(C`ip:port\*(C'\fR combo.
.IP "buffer_backend_connect" 4
.IX Item "buffer_backend_connect"
0 if off; otherwise, number of bytes to buffer before we ask for a backend.
.IP "selector" 4
.IX Item "selector"
\&\s-1CODE\s0 ref, or undef, for role \f(CW\*(C`selector\*(C'\fR services.
.IP "default_service" 4
.IX Item "default_service"
Name of a service a selector should default to.
.IP "buffer_uploads" 4
.IX Item "buffer_uploads"
Boolean; enable/disable the buffered uploads to disk system.
.IP "buffer_uploads_path" 4
.IX Item "buffer_uploads_path"
Path to store buffered upload files.
.IP "buffer_upload_threshold_time" 4
.IX Item "buffer_upload_threshold_time"
Int; buffer uploads estimated to take longer than this.
.IP "buffer_upload_threshold_size" 4
.IX Item "buffer_upload_threshold_size"
Int; buffer uploads greater than this size (in bytes).
.IP "buffer_upload_threshold_rate" 4
.IX Item "buffer_upload_threshold_rate"
Int; buffer uploads uploading at less than this rate (in bytes/sec).
.IP "upload_status_listeners" 4
.IX Item "upload_status_listeners"
Comma separated list of \f(CW\*(C`ip:port\*(C'\fR of \s-1UDP\s0 upload status receivers.
.IP "upload_status_listeners_sockaddr" 4
.IX Item "upload_status_listeners_sockaddr"
Arrayref of sockaddrs (packed ip/port).
.IP "enable_ssl" 4
.IX Item "enable_ssl"
Boolean; whether this service speaks \s-1SSL\s0 to the client.
.IP "ssl_key_file" 4
.IX Item "ssl_key_file"
File path to key pem file.
.IP "ssl_cert_file" 4
.IX Item "ssl_cert_file"
File to path to cert pem file.
.IP "ssl_cipher_list" 4
.IX Item "ssl_cipher_list"
OpenSSL cipher list string.
.IP "ssl_ca_path" 4
.IX Item "ssl_ca_path"
Path to certificates directory.
.IP "ssl_verify_mode" 4
.IX Item "ssl_verify_mode"
Int; verification mode, see IO::Socket::SSL.
.IP "enable_error_retries" 4
.IX Item "enable_error_retries"
Boolean; whether we should retry requests after errors.
.IP "error_retry_schedule" 4
.IX Item "error_retry_schedule"
Comma-separated seconds (full or partial) to delay between retries.
.IP "latency" 4
.IX Item "latency"
Milliseconds of latency to add to request.
.IP "server_tokens" 4
.IX Item "server_tokens"
Boolean; whether to provide a \*(L"Server\*(R" header.
.IP "_stat_requests" 4
.IX Item "_stat_requests"
Total requests to this service.
.IP "_stat_cache_hits" 4
.IX Item "_stat_cache_hits"
Total requests to this service that were served via the reproxy-url cache.
