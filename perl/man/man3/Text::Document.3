.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Document 3"
.TH Document 3 "2002-02-03" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Text::Document \- a text document subject to statistical analysis
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $t = Text::Document\->new();
\&  $t\->AddContent( \*(Aqfoo bar baz\*(Aq );
\&  $t\->AddContent( \*(Aqfoo barbaz; \*(Aq );
\&
\&  my @freqList = $t\->KeywordFrequency();
\&  my $u = Text::Document\->new();
\&  ...
\&  my $sj = $t\->JaccardSimilarity( $u );
\&  my $sc = $t\->CosineSimilarity( $u );
\&  my $wsc = $t\->WeightedCosineSimilarity( $u, \e&MyWeight, $rock );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Text::Document\*(C'\fR allows to perform simple
Information-Retrieval-oriented statistics on pure-text documents.
.PP
Text can be added in chunks, so that the document may be
incrementally built, for instance by a class like
\&\f(CW\*(C`HTML::Parser\*(C'\fR.
.PP
A simple algorithm splits the text into terms; the algorithm
may be redefined by subclassing and redefining \f(CW\*(C`ScanV\*(C'\fR.
.PP
The \f(CW\*(C`KeywordFrequency\*(C'\fR function computes term frequency
over the whole document.
.SH "FORESEEN REUSE"
.IX Header "FORESEEN REUSE"
The package may be {re}used either by simple instantiation,
or by subclassing (defining a descendant package).  In the
latter case the methods which are foreseen to be redefined are
those ending with a \f(CW\*(C`V\*(C'\fR suffix.  Redefining other methods
will require greater attention.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.SS "new"
.IX Subsection "new"
The creator method.  The optional arguments are in the
\&\fI(key,value)\fR form and allow to specify whether
all keywords are trasformed to lowercase (default) and
whether the string representation (\f(CW\*(C`WriteToString\*(C'\fR)
will be compressed (default).
.PP
.Vb 3
\&  my $d = Text::Document\->new();
\&  my $dNotCompressed = Text::Document( compressed => 0 );
\&  my $dPreserveCase = Text::Document( lowercase => 0 );
.Ve
.SS "NewFromString"
.IX Subsection "NewFromString"
Take a string written by \f(CW\*(C`WriteToString\*(C'\fR (see below)
and create a new \f(CW\*(C`Text::Document\*(C'\fR with the same contents;
call \f(CW\*(C`die\*(C'\fR whenever the restore is impossible or ill-advised,
for instance when the current version of the package is different
from the original one, or the compression library in unavailable.
.PP
.Vb 1
\&  my $b = Text::Document::NewFromString( $str );
.Ve
.PP
The return value is a blessed reference; put in another way,
this is an alternative contructor.
.PP
The string should have been written by \f(CW\*(C`WriteToString\*(C'\fR; 
you may of course tweak the string contents, but
at this point you're entirely on you own.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "AddContent"
.IX Subsection "AddContent"
Used as
.PP
.Vb 2
\&  $d\->AddContent( \*(Aqfoo bar baz foo9\*(Aq );
\&  $d\->AddContent( \*(Aqmary had a little lamb\*(Aq );
.Ve
.PP
Successive calls accumulate content; there is currently no way
of resetting the content to zero.
.SS "Terms"
.IX Subsection "Terms"
Returns a list of all distinct terms in the document, in no
particular order.
.SS "Occurrences"
.IX Subsection "Occurrences"
Returns the number of occurrences of a given term.
.PP
.Vb 2
\&  $d\->AddContent( \*(Aqfoo baz bar foo foo\*(Aq);
\&  my $n = $d\->Occurrences( \*(Aqfoo\*(Aq ); # now $n is 3
.Ve
.SS "ScanV"
.IX Subsection "ScanV"
Scan a string and return a list of terms.
.PP
Called internally as:
.PP
.Vb 1
\&  my @terms = $self\->ScanV( $text );
.Ve
.SS "KeywordFrequency"
.IX Subsection "KeywordFrequency"
Returns a reference list of pairs \fI[term,frequency]\fR, sorted by
ascending frequency.
.PP
.Vb 5
\&  my $listRef = $d\->KeywordFrequency();
\&  foreach my $pair (@{$listRef}){
\&        my ($term,$frequency) = @{$pair};
\&        ...
\&  }
.Ve
.PP
Terms in the document are sampled and their frequencies of occurrency
are sorted in ascending order;
finally, the list is returned to the user.
.SS "WriteToString"
.IX Subsection "WriteToString"
Convert the document (actually, some parameters
and the term counters) into a string which can be saved and
later restored with \f(CW\*(C`NewFromString\*(C'\fR.
.PP
.Vb 1
\&  my $str = $d\->WriteToString();
.Ve
.PP
The string begins with a header which encodes the
originating package, its version, the parameters
of the current instance.
.PP
Whenever possible, \f(CW\*(C`Compress::Zlib\*(C'\fR is used in order to
compress the bit vector in the most efficient way.
On systems without \f(CW\*(C`Compress::Zlib\*(C'\fR, the bit string is
saved uncompressed.
.PP
This method is influenced by \f(CW\*(C`PureASCII\*(C'\fR.
.SS "PureASCII"
.IX Subsection "PureASCII"
Ensure that the representation in WriteToString does not contain
characters with \s-1ASCII\s0 code >= 128. Needed to easily include document
representations into textual databases (e.g. \s-1XML\s0 files).
.SS "JaccardSimilarity"
.IX Subsection "JaccardSimilarity"
Compute the Jaccard measure of document similarity, which is defined
as follows: given two documents \fID\fR and \fIE\fR, let \fIDs\fR and \fIEs\fR be the set
of terms occurring in \fID\fR and  \fIE\fR, respectively. Define \fIS\fR as the
intersection of \fIDs\fR and \fIEs\fR, and \fIT\fR as their union. Then
the Jaccerd  similarity is the the number of  elements
of \fIS\fR divided by the number of elements of \fIT\fR.
.PP
It is called as follows:
.PP
.Vb 1
\&  my $sim = $d\->JaccardSimilarity( $e );
.Ve
.PP
If neither document has any terms the result is undef (a rare evenience).
Otherwise the similarity is a real number between 0.0 (no terms in common)
and 1.0 (all terms in common).
.SS "CosineSimilarity"
.IX Subsection "CosineSimilarity"
Compute the cosine similarity between two documents \fID\fR and
\&\fIE\fR.
.PP
Let \fIDs\fR and \fIEs\fR be the set
of terms occurring in \fID\fR and  \fIE\fR, respectively. Define \fIT\fR as the
union of \fIDs\fR and \fIEs\fR, and let \fIti\fR be the \fIi\fR\-th element of \fIT\fR.
.PP
Then the term vectors of \fID\fR and  \fIE\fR are
.PP
.Vb 2
\&  Dv = (nD(t1), nD(t2), ..., nD(tN))
\&  Ev = (nE(t1), nE(t2), ..., nE(tN))
.Ve
.PP
where nD(ti) is the  number of occurrences of term ti in \fID\fR,
and nE(ti) the same for \fIE\fR.
.PP
Now we are at last ready to define the cosine similarity \fI\s-1CS\s0\fR:
.PP
.Vb 1
\&  CS = (Dv,Ev) / (Norm(Dv)*Norm(Ev))
.Ve
.PP
Here (... , ...) is the scalar product and Norm is the Euclidean
norm (square root of the sum of squares).
.PP
\&\f(CW\*(C`CosineSimilarity\*(C'\fR is called as
.PP
.Vb 1
\&   $sim = $d\->CosineSimilarity( $e );
.Ve
.PP
It is \f(CW\*(C`undef\*(C'\fR if either \fID\fR or \fIE\fR have no occurrence of any term.
Otherwise, it is a number between 0.0 and 1.0. Since term occurrences
are always non-negative, the cosine is obviously always non-negative.
.SS "WeightedCosineSimilarity"
.IX Subsection "WeightedCosineSimilarity"
Compute the weighted cosine similarity between two documents \fID\fR and
\&\fIE\fR.
.PP
In the setting of \f(CW\*(C`CosineSimilarity\*(C'\fR, the 
term vectors of \fID\fR and  \fIE\fR are
.PP
.Vb 2
\&  Dv = (nD(t1)*w1, nD(t2)*w2, ..., nD(tN)*wN)
\&  Ev = (nE(t1)*w1, nE(t2)*w2, ..., nE(tN)*wN)
.Ve
.PP
The weights are nonnegative real values; each term has associated
a weight. To achieve generality, weights may be defined
using a function, like:
.PP
.Vb 5
\&  my $wcs = $d\->WeightedCosineSimilarity(
\&        $e,
\&        \e&function,
\&        $rock
\&  );
.Ve
.PP
The \f(CW\*(C`function\*(C'\fR will be called as follows:
.PP
.Vb 1
\&  my $weight = function( $rock, \*(Aqfoo\*(Aq );
.Ve
.PP
\&\f(CW$rock\fR is a 'constant' object used for passing a \fIcontext\fR
to the function.
.PP
For instance, a common way of defining weights is the \s-1IDF\s0 (inverse
document frequency), which is defined in Text::DocumentCollection.
In this context, you can weigh terms with their \s-1IDF\s0 as
follows:
.PP
.Vb 5
\&  $sim = $c\->WeightedCosineSimilarity(
\&        $d,
\&        \e&Text::DocumentCollection::IDF,
\&        $collection
\&  );
.Ve
.PP
\&\f(CW\*(C`WeightedCosineSimilarity\*(C'\fR will call
.PP
.Vb 1
\&  $collection\->IDF( \*(Aqfoo\*(Aq );
.Ve
.PP
which is what we expect.
.PP
Actually, we should return the square root of \s-1IDF\s0, but this
detail is not necessary here.
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 2
\&  spinellia@acm.org (Andrea Spinelli)
\&  walter@humans.net (Walter Vannini)
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
.Vb 1
\&  2001\-11\-02 \- initial revision
\&
\&  2001\-11\-20 \- added WeightedCosineSimilarity, suggested by JP Mc Gowan <jp.mcgowan@ucd.ie>
\&
\&  2002\-02\-03 \- changed representation of checksum. New method C<PureASCII>.
.Ve
.PP
We did not use \f(CW\*(C`Storable\*(C'\fR, because we wanted to fine-tune
compression and version compatibility.  However, this
choice may be easily reversed redefining WriteToString and
NewFromString.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 609:" 4
.IX Item "Around line 609:"
Unknown directive: =head
