.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message::Construct::Rebuild 3"
.TH Mail::Message::Construct::Rebuild 3 "2014-08-24" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Construct::Rebuild \- modify a Mail::Message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& my $cleanup = $msg\->rebuild;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Modifying existing messages is a pain, certainly if this has to be
done in an automated fashion.  The problems are especially had when
multiparts have to be created or removed.  The \fIrebuild()\fR method
tries to simplify this task and add some standard features.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructing a message"
.IX Subsection "Constructing a message"
.ie n .IP "$obj\->\fBrebuild\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBrebuild\fR(%options)" 4
.IX Item "$obj->rebuild(%options)"
Reconstruct an existing message into something new.  Returned is a new
message when there were modifications made, \f(CW\*(C`undef\*(C'\fR if the message has
no body left, or the original message when no modifications had to be
made.
.Sp
Examples of use: you have a message which only contains html, and you
want to translate it into a multipart which contains the original html
and the textual translation of it.  Or, you have a message with parts
flagged to be deleted, and you want those changes be incorparted in the
memory structure.  Another possibility: clear all the resent groups
(see Mail::Message::Head::ResentGroup) from the header, before it is
written to file.
.Sp
Reconstructing is a hazardous task, where multi level multiparts and
nested messages come into play.  The rebuild method tries to simplify
handing these messages for you.
.Sp
.Vb 4
\& \-Option         \-\-Default
\&  extra_rules      []
\&  keep_message_id  <false>
\&  rules            <see text>
.Ve
.RS 4
.IP "extra_rules => \s-1ARRAY\s0" 2
.IX Item "extra_rules => ARRAY"
The standard set of rules, which is the default for the \f(CW\*(C`rules\*(C'\fR option,
is a moderest setting.  In stead of copying that list into a full set
of rules of your own, you can also specify only some additional rules
which will be prependend to the default rule set.
.Sp
The order of the rules is respected, which means that you do not always
need to rewrite the whole rule is (see \f(CW\*(C`rule\*(C'\fR option).  For instance,
the extra rule of \f(CW\*(C`removeDeletedParts\*(C'\fR returns an \f(CW\*(C`undef\*(C'\fR, which
means that it cancels the effect of the default rule \f(CW\*(C`replaceDeletedParts\*(C'\fR.
.IP "keep_message_id => \s-1BOOLEAN\s0" 2
.IX Item "keep_message_id => BOOLEAN"
The message-id is an unique identification of the message: no two messages
with different content shall exist anywhere.  However in practice, when
a message is changed during transmission, the id is often incorrectly
not changed.  This may lead to complications in application which see
both messages with the same id.
.IP "rules => \s-1ARRAY\s0" 2
.IX Item "rules => ARRAY"
The \s-1ARRAY\s0 is a list of rules, which each describe an action which will
be called on each part which is found in the message.  Most rules
probably won't match, but some will bring changes to the content.
Rules can be specified as method name, or as code reference.  See the
\&\*(L"\s-1DETAILS\s0\*(R" chapter in this manual page, and \fIrecursiveRebuildPart()\fR.
.Sp
By default, only the relatively safe transformations are performed:
\&\f(CW\*(C`replaceDeletedParts\*(C'\fR, \f(CW\*(C`descendMultiparts\*(C'\fR, \f(CW\*(C`descendNested\*(C'\fR,
\&\f(CW\*(C`flattenMultiparts\*(C'\fR, \f(CW\*(C`flattenEmptyMultiparts\*(C'\fR.  In the future, more
safe transformations may be added to this list.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 3
\& # remove all deleted parts
\& my $cleaned = $msg\->rebuild(keep_message_id => 1);
\& $folder\->addMessage($cleaned) if defined $cleaned;
\&
\& # Replace deleted parts by a place\-holder
\& my $cleaned = $msg\->rebuild
\&   ( keep_message_id => 1
\&   , extra_rules => [ \*(AqremoveEmpty\*(Aq, \*(AqflattenMultiparts\*(Aq ]
\&   );
.Ve
.RE
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBrecursiveRebuildPart\fR($part, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBrecursiveRebuildPart\fR($part, \f(CW%options\fR)" 4
.IX Item "$obj->recursiveRebuildPart($part, %options)"
.Vb 2
\& \-Option\-\-Default
\&  rules   <required>
.Ve
.RS 4
.IP "rules => ARRAY-OF-RULES" 2
.IX Item "rules => ARRAY-OF-RULES"
Rules are method names which can be called on messages and message parts
objects.  The \s-1ARRAY\s0 can also list code references which can be called.
In any case, each rule will be called the same way:
.Sp
.Vb 1
\& $code\->(MESSAGE, PART)
.Ve
.Sp
The return can be \f(CW\*(C`undef\*(C'\fR or any complex construct based on a
Mail::Message::Part or coerceable into such a part.  For each part,
all rules are called in sequence.  When a rule returns a changed object,
the rules will start all over again, however \f(CW\*(C`undef\*(C'\fR will immediately
stop it.
.RE
.RS 4
.RE
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Rebuilding a message"
.IX Subsection "Rebuilding a message"
Modifying an existing message is a complicated job.  Not only do you need
to know what you are willing to change, but you have to take care about
multiparts (possibly nested in multiple levels), rfc822 encapsulated
messages, header field consistency, and so on.  The \fIrebuild()\fR method
let you focus on the task, and takes care of the rest.
.PP
The \fIrebuild()\fR method uses rules to transform the one message into an
other.  If one or more of the rules apply, a new message will be returned.
A simple numeric comparison tells whether the message has changed.  For
example
.PP
.Vb 2
\& print "No change"
\&    if $message == $message\->rebuild;
.Ve
.PP
Transformation is made with a set of rules.  Each rule performs only a
small step, which makes is easily configurable.  The rules are ordered,
and when one makes a change to the result, the result will be passed
to all the rules again until no rule makes a change on the part anymore.
A rule may also return \f(CW\*(C`undef\*(C'\fR in which case the part will be removed
from the (resulting) message.
.PP
\fIGeneral rules\fR
.IX Subsection "General rules"
.PP
This sections describes the general configuration rules: all quite straight
forward transformations on the message structure.  The rules marked with (*)
are used by default.
.IP "\(bu" 4
descendMultiparts (*)
.Sp
Apply the rules to the parts of (possibly nested) multiparts, not only to
the top-level message.
.IP "\(bu" 4
descendNested (*)
.Sp
Apply the rules to the \f(CW\*(C`message/rfc822\*(C'\fR encapsulated message as well.
.IP "\(bu" 4
flattenEmptyMultiparts (*)
.Sp
Multipart messages which do not have any parts left are replaced by
a single part which contains the preamble, epilogue and a brief
explanation.
.IP "\(bu" 4
flattenMultiparts (*)
.Sp
When a multipart contains only one part, that part will take the place of
the multipart: the removal of a level of nesting.  This way, the preamble
and epilogue of the multipart (which do not have a meaning, officially)
are lost.
.IP "\(bu" 4
flattenNesting
.Sp
Remove the \f(CW\*(C`message/rfc822\*(C'\fR encapsulation.  Only the content related
lines of the encapsulated body are preserved one level higher.  Other
information will be lost, which is often not too bad.
.IP "\(bu" 4
removeDeletedParts
.Sp
All parts which are flagged for deletion are removed from the message
without leaving a trace.  If a nested message is encountered which has
its encapsulated content flagged for deletion, it will be removed as
a whole.
.IP "\(bu" 4
removeEmptyMultiparts
.Sp
Multipart messages which do not have any parts left are removed.  The
information in preamble and epiloge is lost.
.IP "\(bu" 4
removeEmptyBodies
.Sp
Simple message bodies which do not contain any lines of content are
removed.  This will loose the information which is stored in the
headers of these bodies.
.IP "\(bu" 4
replaceDeletedParts (*)
.Sp
All parts of the message which are flagged for deletion are replace
by a message which says that the part is deleted.
.PP
You can specify a selection of these rules with rebuild(rules) and
rebuild(extra_rules).
.PP
\fIConversion rules\fR
.IX Subsection "Conversion rules"
.PP
This section describes the rules which try to be smart with the
content.  Please contribute with ideas and implementations.
.IP "\(bu" 4
removeHtmlAlternativeToText
.Sp
When a multipart alternative is encountered, which contains both a
plain text and an html part, then the html part is deleted.
Especially useful in combination with the \f(CW\*(C`flattenMultiparts\*(C'\fR rule.
.IP "\(bu" 4
textAlternativeForHtml
.Sp
Any \f(CW\*(C`text/html\*(C'\fR part which is not accompanied by an alternative
plain text part will have one added.  You must have a working
Mail::Message::Convert::HtmlFormatText, which means that
HTML::TreeBuilder and HTML::FormatText  must be installed on
your system.
.IP "\(bu" 4
removeExtraAlternativeText
.Sp
[2.110] When a multipart alternative is encountered, deletes all its parts
except for the last part (the preferred part in accordance
with \s-1RFC2046\s0). In practice, this normally results in the alternative
plain text part being deleted of an html message. Useful in combination
with the \f(CW\*(C`flattenMultiparts\*(C'\fR rule.
.PP
\fIAdding your own rules\fR
.IX Subsection "Adding your own rules"
.PP
If you have designed your own rule, please consider contributing this
to Mail::Box; it may be useful for other people as well.
.PP
Each rule is called
.PP
.Vb 1
\& my $new = $code\->($message, $part, %options)
.Ve
.PP
where the \f(CW%options\fR are defined by the \f(CW\*(C`rebuild()\*(C'\fR method internals. At
least the \f(CW\*(C`rules\*(C'\fR option is passed, which is a full expansion of all
the rules which will be applied.
.PP
Your subroutine shall return \f(CW$part\fR if no changes are needed,
\&\f(CW\*(C`undef\*(C'\fR if the part should be removed, and any newly constructed
\&\f(CW\*(C`Mail::Message::Part\*(C'\fR when a change is required.  It is easiest to
start looking at the source code of this package, and copy from a
comparible routine.
.PP
When you have your own routine, you simply call:
.PP
.Vb 2
\& my $rebuild_message = $message\->rebuild
\&  ( extra_rules => [ \e&my_own_rule, \*(Aqother_rule\*(Aq ] );
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: No rebuild rule $name defined." 4
.el .IP "Error: No rebuild rule \f(CW$name\fR defined." 4
.IX Item "Error: No rebuild rule $name defined."
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.117,
built on August 24, 2014. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2014 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
