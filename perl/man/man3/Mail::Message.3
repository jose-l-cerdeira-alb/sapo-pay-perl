.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::Message 3"
.TH Mail::Message 3 "2014-08-24" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message \- general message object
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 9
\& Mail::Message has extra code in
\&   Mail::Message::Construct
\&   Mail::Message::Construct::Bounce
\&   Mail::Message::Construct::Build
\&   Mail::Message::Construct::Forward
\&   Mail::Message::Construct::Read
\&   Mail::Message::Construct::Rebuild
\&   Mail::Message::Construct::Reply
\&   Mail::Message::Construct::Text
\&
\& Mail::Message
\&   is a Mail::Reporter
\&
\& Mail::Message is extended by
\&   Mail::Box::Message
\&   Mail::Message::Dummy
\&   Mail::Message::Part
\&   Mail::Message::Replace::MailInternet
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Mail::Box::Manager;
\& my $mgr    = Mail::Box::Manager\->new;
\& my $folder = $mgr\->open(folder => \*(AqInBox\*(Aq);
\& my $msg    = $folder\->message(2);    # $msg is a Mail::Message now
\&
\& my $subject = $msg\->subject;         # The message\*(Aqs subject
\& my @cc      = $msg\->cc;              # List of Mail::Address\*(Aqes
\&
\& my $msg       = Mail::Message\->build(...);
\& my $reply_msg = Mail::Message\->reply(...);
\& my $frwd_msg  = Mail::Message\->forward(...);
\&
\& my Mail::Message::Head $head = $msg\->head;
\& my Mail::Message::Body $body = $msg\->decoded;
\& $msg\->decoded\->print($outfile);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \f(CW\*(C`Mail::Message\*(C'\fR object is a container for MIME-encoded message information,
as defined by \s-1RFC2822\s0.  Everything what is not specificly related to storing
the messages in mailboxes (folders) is implemented in this class.  Methods
which are related to folders is implemented in the Mail::Box::Message
extension.
.PP
The main methods are \fIget()\fR, to get information from a message header
field, and \fIdecoded()\fR to get the intended content of a message.
But there are many more which can assist your program.
.PP
Complex message handling, like construction of replies and forwards, are
implemented in separate packages which are autoloaded into this class.
This means you can simply use these methods as if they are part of this class.
Those package add functionality to all kinds of message objects.
.PP
Extends \*(L"\s-1DESCRIPTION\s0\*(R" in Mail::Reporter.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\s0\*(R" in Mail::Reporter.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fBclone\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR(%options)" 4
.IX Item "$obj->clone(%options)"
Create a copy of this message.  Returned is a \f(CW\*(C`Mail::Message\*(C'\fR object.
The head and body, the log and trace levels are taken.  Labels are
copied with the message, but the delete and modified flags are not.
.Sp
\&\s-1BE\s0 \s-1WARNED:\s0 the clone of any kind of message (or a message part)
will \fBalways\fR be a \f(CW\*(C`Mail::Message\*(C'\fR object.  For example, a
Mail::Box::Message's clone is detached from the folder of its original.
When you use \fIMail::Box::addMessage()\fR with the cloned message at hand,
then the clone will automatically be coerced into the right message type
to be added.
.Sp
See also \fIMail::Box::Message::copyTo()\fR and \fIMail::Box::Message::moveTo()\fR.
.Sp
.Vb 4
\& \-Option      \-\-Default
\&  shallow       <false>
\&  shallow_body  <false>
\&  shallow_head  <false>
.Ve
.RS 4
.IP "shallow => \s-1BOOLEAN\s0" 2
.IX Item "shallow => BOOLEAN"
When a shallow clone is made, the header and body of the message will not
be cloned, but shared.  This is quite dangerous: for instance in some
folder types, the header fields are used to store folder flags.  When
one of both shallow clones change the flags, that will update the header
and thereby be visible in both.
.Sp
There are situations where a shallow clone can be used safely.  For instance,
when \fIMail::Box::Message::moveTo()\fR is used and you are sure that the
original message cannot get undeleted after the move.
.IP "shallow_body => \s-1BOOLEAN\s0" 2
.IX Item "shallow_body => BOOLEAN"
A rather safe bet, because you are not allowed to modify the body of a
message: you may only set a new body with \fIbody()\fR.
.IP "shallow_head => \s-1BOOLEAN\s0" 2
.IX Item "shallow_head => BOOLEAN"
Only the head uses is reused, not the body.  This is probably a bad choice,
because the header fields can be updated, for instance when labels change.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 1
\& $copy = $msg\->clone;
.Ve
.RE
.IP "Mail::Message\->\fBnew\fR(%options)" 4
.IX Item "Mail::Message->new(%options)"
.Vb 10
\& \-Option    \-\-Defined in     \-\-Default
\&  body                         undef
\&  body_type                    Mail::Message::Body::Lines
\&  deleted                      <false>
\&  field_type                   undef
\&  head                         undef
\&  head_type                    Mail::Message::Head::Complete
\&  labels                       {}
\&  log         Mail::Reporter   \*(AqWARNINGS\*(Aq
\&  messageId                    undef
\&  modified                     <false>
\&  trace       Mail::Reporter   \*(AqWARNINGS\*(Aq
\&  trusted                      <false>
.Ve
.RS 4
.IP "body => \s-1OBJECT\s0" 2
.IX Item "body => OBJECT"
Instantiate the message with a body which has been created somewhere
before the message is constructed.  The \s-1OBJECT\s0 must be a sub-class
of Mail::Message::Body.  See also \fIbody()\fR and \fIstoreBody()\fR.
.IP "body_type => \s-1CLASS\s0" 2
.IX Item "body_type => CLASS"
Default type of body to be created for \fIreadBody()\fR.
.IP "deleted => \s-1BOOLEAN\s0" 2
.IX Item "deleted => BOOLEAN"
Is the file deleted from the start?
.IP "field_type => \s-1CLASS\s0" 2
.IX Item "field_type => CLASS"
.PD 0
.IP "head => \s-1OBJECT\s0" 2
.IX Item "head => OBJECT"
.PD
Instantiate the message with a head which has been created somewhere
before the message is constructed.  The \s-1OBJECT\s0 must be a (sub\-)class
of Mail::Message::Head. See also \fIhead()\fR.
.IP "head_type => \s-1CLASS\s0" 2
.IX Item "head_type => CLASS"
Default type of head to be created for \fIreadHead()\fR.
.IP "labels => ARRAY|HASH" 2
.IX Item "labels => ARRAY|HASH"
Initial values of the labels.  In case of Mail::Box::Message's, this
shall reflect the state the message is in.  For newly constructed
Mail::Message's, this may be anything you want, because \fIcoerce()\fR
will take care of the folder specifics once the message is added to one.
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "messageId => \s-1STRING\s0" 2
.IX Item "messageId => STRING"
.PD
The id on which this message can be recognized.  If none specified and
not defined in the header \-\-but one is needed\*(-- there will be one assigned
to the message to be able to pass unique message-ids between objects.
.IP "modified => \s-1BOOLEAN\s0" 2
.IX Item "modified => BOOLEAN"
Flags this message as being modified from the beginning on.  Usually,
modification is auto-detected, but there may be reasons to be extra
explicit.
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.PD 0
.IP "trusted => \s-1BOOLEAN\s0" 2
.IX Item "trusted => BOOLEAN"
.PD
Is this message from a trusted source?  If not, the content must be
checked before use.  This checking will be performed when the
body data is decoded or used for transmission.
.RE
.RS 4
.RE
.SS "Constructing a message"
.IX Subsection "Constructing a message"
.ie n .IP "$obj\->\fBbounce\fR( [<$rg_object|%options>] )" 4
.el .IP "\f(CW$obj\fR\->\fBbounce\fR( [<$rg_object|%options>] )" 4
.IX Item "$obj->bounce( [<$rg_object|%options>] )"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Bounce
.ie n .IP "Mail::Message\->\fBbuild\fR( [$message|$part|$body], $content )" 4
.el .IP "Mail::Message\->\fBbuild\fR( [$message|$part|$body], \f(CW$content\fR )" 4
.IX Item "Mail::Message->build( [$message|$part|$body], $content )"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Build
.ie n .IP "Mail::Message\->\fBbuildFromBody\fR($body, [$head], $headers)" 4
.el .IP "Mail::Message\->\fBbuildFromBody\fR($body, [$head], \f(CW$headers\fR)" 4
.IX Item "Mail::Message->buildFromBody($body, [$head], $headers)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Build
.ie n .IP "$obj\->\fBforward\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBforward\fR(%options)" 4
.IX Item "$obj->forward(%options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardAttach\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardAttach\fR(%options)" 4
.IX Item "$obj->forwardAttach(%options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardEncapsulate\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardEncapsulate\fR(%options)" 4
.IX Item "$obj->forwardEncapsulate(%options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardInline\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardInline\fR(%options)" 4
.IX Item "$obj->forwardInline(%options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardNo\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardNo\fR(%options)" 4
.IX Item "$obj->forwardNo(%options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardPostlude\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBforwardPostlude\fR()" 4
.IX Item "$obj->forwardPostlude()"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardPrelude\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBforwardPrelude\fR()" 4
.IX Item "$obj->forwardPrelude()"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "$obj\->\fBforwardSubject\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBforwardSubject\fR(\s-1STRING\s0)" 4
.IX Item "$obj->forwardSubject(STRING)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Forward
.ie n .IP "Mail::Message\->\fBread\fR($fh|STRING|SCALAR|ARRAY, %options)" 4
.el .IP "Mail::Message\->\fBread\fR($fh|STRING|SCALAR|ARRAY, \f(CW%options\fR)" 4
.IX Item "Mail::Message->read($fh|STRING|SCALAR|ARRAY, %options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Read
.ie n .IP "$obj\->\fBrebuild\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBrebuild\fR(%options)" 4
.IX Item "$obj->rebuild(%options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Rebuild
.ie n .IP "$obj\->\fBreply\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBreply\fR(%options)" 4
.IX Item "$obj->reply(%options)"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Reply
.ie n .IP "$obj\->\fBreplyPrelude\fR( [STRING|$field|$address|ARRAY\-$of\-$things] )" 4
.el .IP "\f(CW$obj\fR\->\fBreplyPrelude\fR( [STRING|$field|$address|ARRAY\-$of\-$things] )" 4
.IX Item "$obj->replyPrelude( [STRING|$field|$address|ARRAY-$of-$things] )"
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Reply
.ie n .IP "$obj\->\fBreplySubject\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreplySubject\fR(\s-1STRING\s0)" 4
.IX Item "$obj->replySubject(STRING)"
.PD 0
.IP "Mail::Message\->\fBreplySubject\fR(\s-1STRING\s0)" 4
.IX Item "Mail::Message->replySubject(STRING)"
.PD
Inherited, see \*(L"Constructing a message\*(R" in Mail::Message::Construct::Reply
.SS "The message"
.IX Subsection "The message"
.ie n .IP "$obj\->\fBcontainer\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcontainer\fR()" 4
.IX Item "$obj->container()"
If the message is a part of another message, \f(CW\*(C`container\*(C'\fR returns the
reference to the containing body.
.Sp
example:
.Sp
.Vb 3
\& my Mail::Message $msg = ...
\& return unless $msg\->body\->isMultipart;
\& my $part   = $msg\->body\->part(2);
\&
\& return unless $part\->body\->isMultipart;
\& my $nested = $part\->body\->part(3);
\&
\& $nested\->container;  # returns $msg\->body
\& $nested\->toplevel;   # returns $msg
\& $msg\->container;     # returns undef
\& $msg\->toplevel;      # returns $msg
\& $msg\->isPart;        # returns false
\& $part\->isPart;       # returns true
.Ve
.ie n .IP "$obj\->\fBisDummy\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDummy\fR()" 4
.IX Item "$obj->isDummy()"
Dummy messages are used to fill holes in linked-list and such, where only
a message-id is known, but not the place of the header of body data.
.Sp
This method is also available for Mail::Message::Dummy objects,
where this will return \f(CW\*(C`true\*(C'\fR.  On any extension of \f(CW\*(C`Mail::Message\*(C'\fR,
this will return \f(CW\*(C`false\*(C'\fR.
.ie n .IP "$obj\->\fBisPart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisPart\fR()" 4
.IX Item "$obj->isPart()"
Returns true if the message is a part of another message.  This is
the case for Mail::Message::Part extensions of \f(CW\*(C`Mail::Message\*(C'\fR.
.ie n .IP "$obj\->\fBmessageId\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmessageId\fR()" 4
.IX Item "$obj->messageId()"
Retrieve the message's id.  Every message has a unique message-id.  This id
is used mainly for recognizing discussion threads.
.ie n .IP "$obj\->\fBpartNumber\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBpartNumber\fR()" 4
.IX Item "$obj->partNumber()"
Returns a string representing the location of this part.  In case the
top message is a single message, 'undef' is returned.  When it is a
multipart, '1' upto the number of multiparts is returned.  A multi-level
nested part may for instance return '2.5.1'.
.Sp
Usually, this string is very short.  Numbering follows the \s-1IMAP4\s0 design,
see \s-1RFC2060\s0 secion 6.4.5.
.ie n .IP "$obj\->\fBprint\fR( [$fh] )" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR( [$fh] )" 4
.IX Item "$obj->print( [$fh] )"
Print the message to the FILE-HANDLE, which defaults to the selected
filehandle, without the encapsulation sometimes required by a folder
type, like \fIwrite()\fR does.
.Sp
example:
.Sp
.Vb 2
\& $message\->print(\e*STDERR);  # to the error output
\& $message\->print;            # to the selected file
\&
\& my $out = IO::File\->new(\*(Aqout\*(Aq, \*(Aqw\*(Aq);
\& $message\->print($out);      # no encapsulation: no folder
\& $message\->write($out);      # with encapsulation: is folder.
.Ve
.ie n .IP "$obj\->\fBsend\fR( [$mailer], %options )" 4
.el .IP "\f(CW$obj\fR\->\fBsend\fR( [$mailer], \f(CW%options\fR )" 4
.IX Item "$obj->send( [$mailer], %options )"
Transmit the message to anything outside this Perl program.  \f(CW$mailer\fR
is a Mail::Transport::Send object.  When the \f(CW$mailer\fR is not specified, one
will be created, and kept as default for the next messages as well.
.Sp
The \f(CW%options\fR are mailer specific, and a mixture of what is usable for
the creation of the mailer object and the sending itself.  Therefore, see
for possible options \fIMail::Transport::Send::new()\fR and
\&\fIMail::Transport::Send::send()\fR.
.Sp
example:
.Sp
.Vb 1
\& $message\->send;
.Ve
.Sp
is short (but little less flexibile) for
.Sp
.Vb 2
\& my $mailer = Mail::Transport::SMTP\->new(@smtpopts);
\& $mailer\->send($message, @sendopts);
.Ve
.Sp
See examples/send.pl in the distribution of Mail::Box.
.Sp
example:
.Sp
.Vb 1
\& $message\->send(via => \*(Aqsendmail\*(Aq)
.Ve
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
Returns an estimated size of the whole message in bytes.  In many occasions,
the functions which process the message further, for instance \fIsend()\fR
or \fIprint()\fR will need to add/change header lines or add \s-1CR\s0 characters,
so the size is only an estimate with a few percent margin of the real
result.
.Sp
The computation assumes that each line ending is represented by one
character (like \s-1UNIX\s0, MacOS, and sometimes Cygwin), and not two characters
(like Windows and sometimes Cygwin).  If you write the message to file on
a system which uses \s-1CR\s0 and \s-1LF\s0 to end a single line (all Windows versions),
the result in that file will be at least \fInrLines()\fR larger than this
method returns.
.ie n .IP "$obj\->\fBtoplevel\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoplevel\fR()" 4
.IX Item "$obj->toplevel()"
Returns a reference to the main message, which will be the current
message if the message is not part of another message.
.ie n .IP "$obj\->\fBwrite\fR( [$fh] )" 4
.el .IP "\f(CW$obj\fR\->\fBwrite\fR( [$fh] )" 4
.IX Item "$obj->write( [$fh] )"
Write the message to the FILE-HANDLE, which defaults to the selected
\&\f(CW$fh\fR, with all surrounding information which is needed to put
it correctly in a folder file.
.Sp
In most cases, the result of \f(CW\*(C`write\*(C'\fR will be the same as with \fIprint()\fR.
The main exception is for Mbox folder messages, which will get printed
with their leading 'From ' line and a trailing blank.  Each line of
their body which starts with 'From ' will have an '>' added in front.
.SS "The header"
.IX Subsection "The header"
.ie n .IP "$obj\->\fBbcc\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbcc\fR()" 4
.IX Item "$obj->bcc()"
Returns the addresses which are specified on the \f(CW\*(C`Bcc\*(C'\fR header line (or lines)
A list of Mail::Address objects is returned.
\&\f(CW\*(C`Bcc\*(C'\fR stands for \fIBlind Carbon Copy\fR: destinations of the message which are
not listed in the messages actually sent.  So, this field will be empty
for received messages, but may be present in messages you construct yourself.
.ie n .IP "$obj\->\fBcc\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcc\fR()" 4
.IX Item "$obj->cc()"
Returns the addresses which are specified on the \f(CW\*(C`Cc\*(C'\fR header line (or lines)
A list of Mail::Address objects is returned.  \f(CW\*(C`Cc\*(C'\fR stands for
\&\fICarbon Copy\fR; the people addressed on this line receive the message
informational, and are usually not expected to reply on its content.
.ie n .IP "$obj\->\fBdate\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdate\fR()" 4
.IX Item "$obj->date()"
Method has been removed for reasons of consistency.  Use \fItimestamp()\fR
or \f(CW\*(C`$msg\->head\->get(\*(AqDate\*(Aq)\*(C'\fR.
.ie n .IP "$obj\->\fBdestinations\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdestinations\fR()" 4
.IX Item "$obj->destinations()"
Returns a list of Mail::Address objects which contains the combined
info of active \f(CW\*(C`To\*(C'\fR, \f(CW\*(C`Cc\*(C'\fR, and \f(CW\*(C`Bcc\*(C'\fR addresses.  Double addresses are
removed if detectable.
.ie n .IP "$obj\->\fBfrom\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfrom\fR()" 4
.IX Item "$obj->from()"
Returns the addresses from the senders.  It is possible to have more than
one address specified in the \f(CW\*(C`From\*(C'\fR field of the message, according
to the specification. Therefore a list of Mail::Address objects is
returned, which usually has length 1.
.Sp
If you need only one address from a sender, for instance to create a
\&\*(L"original message by\*(R" line in constructed forwarded message body, then use
\&\fIsender()\fR.
.Sp
example: using \fIfrom()\fR to get all sender addresses
.Sp
.Vb 1
\& my @from = $message\->from;
.Ve
.ie n .IP "$obj\->\fBget\fR($fieldname)" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR($fieldname)" 4
.IX Item "$obj->get($fieldname)"
Returns the value which is stored in the header field with the specified
name.  The \f(CW$fieldname\fR is case insensitive.  The \fIunfolded body\fR of the
field is returned, stripped from any attributes.
See \fIMail::Message::Field::body()\fR.
.Sp
If the field has multiple appearances in the header, only the last
instance is returned.  If you need more complex handing of fields, then
call \fIMail::Message::Head::get()\fR yourself.  See \fIstudy()\fR when you
want to be smart, doing the better (but slower) job.
.Sp
example: the \fIget()\fR short-cut for header fields
.Sp
.Vb 1
\& print $msg\->get(\*(AqContent\-Type\*(Aq), "\en";
.Ve
.Sp
Is equivalent to:
.Sp
.Vb 1
\& print $msg\->head\->get(\*(AqContent\-Type\*(Aq)\->body, "\en";
.Ve
.ie n .IP "$obj\->\fBguessTimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBguessTimestamp\fR()" 4
.IX Item "$obj->guessTimestamp()"
Return an estimate on the time this message was sent.  The data is
derived from the header, where it can be derived from the \f(CW\*(C`date\*(C'\fR and
\&\f(CW\*(C`received\*(C'\fR lines.  For MBox-like folders you may get the date from
the from-line as well.
.Sp
This method may return \f(CW\*(C`undef\*(C'\fR if the header is not parsed or only
partially known.  If you require a time, then use the \fItimestamp()\fR
method, described below.
.Sp
example: using \fIguessTimestamp()\fR to get a transmission date
.Sp
.Vb 1
\& print "Receipt ", ($message\->timestamp || \*(Aqunknown\*(Aq), "\en";
.Ve
.ie n .IP "$obj\->\fBhead\fR( [$head] )" 4
.el .IP "\f(CW$obj\fR\->\fBhead\fR( [$head] )" 4
.IX Item "$obj->head( [$head] )"
Return (optionally after setting) the \f(CW$head\fR of this message.
The head must be an (sub\-)class of Mail::Message::Head.
When the head is added, status information is taken from it
and transformed into labels.  More labels can be added by the
\&\s-1LABELS\s0 hash.  They are added later.
.Sp
example:
.Sp
.Vb 3
\& my $header = Mail::Message::Head\->new;
\& $msg\->head($header);    # set
\& my $head = $msg\->head;  # get
.Ve
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
Returns the number of lines used for the whole message.
.ie n .IP "$obj\->\fBsender\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsender\fR()" 4
.IX Item "$obj->sender()"
Returns exactly one address, which is the originator of this message.
The returned Mail::Address object is taken from the \f(CW\*(C`Sender\*(C'\fR header
field, unless that field does not exists, in which case the first
address from the \f(CW\*(C`From\*(C'\fR field is taken.  If none of both provide
an address, \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
example: using \fIsender()\fR to get exactly one sender address
.Sp
.Vb 2
\& my $sender = $message\->sender;
\& print "Reply to: ", $sender\->format, "\en" if defined $sender;
.Ve
.ie n .IP "$obj\->\fBstudy\fR($fieldname)" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR($fieldname)" 4
.IX Item "$obj->study($fieldname)"
Study the content of a field, like \fIget()\fR does, with as main difference
that a Mail::Message::Field::Full object is returned.  These objects
stringify to an utf8 decoded representation of the data contained in
the field, where \fIget()\fR does not decode.  When the field does not exist,
then \f(CW\*(C`undef\*(C'\fR is returned.  See \fIMail::Message::Field::study()\fR.
.Sp
example: the \fIstudy()\fR short-cut for header fields
.Sp
.Vb 1
\& print $msg\->study(\*(Aqto\*(Aq), "\en";
.Ve
.Sp
Is equivalent to:
.Sp
.Vb 2
\& print $msg\->head\->study(\*(Aqto\*(Aq), "\en";       # and
\& print $msg\->head\->get(\*(Aqto\*(Aq)\->study, "\en";
.Ve
.Sp
or better:
 if(my \f(CW$to\fR = \f(CW$msg\fR\->study('to')) { print \*(L"$to\en\*(R" }
 if(my \f(CW$to\fR = \f(CW$msg\fR\->get('to')) { print \f(CW$to\fR\->study, \*(L"\en\*(R" }
.ie n .IP "$obj\->\fBsubject\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsubject\fR()" 4
.IX Item "$obj->subject()"
Returns the message's subject, or the empty string.  The subject may
have encoded characters in it; use \fIstudy()\fR to get rit of that.
.Sp
example: using \fIsubject()\fR to get the message's subject
.Sp
.Vb 2
\& print $msg\->subject;
\& print $msg\->study(\*(Aqsubject\*(Aq);
.Ve
.ie n .IP "$obj\->\fBtimestamp\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtimestamp\fR()" 4
.IX Item "$obj->timestamp()"
Get a good timestamp for the message, doesn't matter how much work it is.
The value returned is compatible with the platform dependent result of
function \fItime()\fR.
.Sp
In these days, the timestamp as supplied by the message (in the \f(CW\*(C`Date\*(C'\fR
field) is not trustable at all: many spammers produce illegal or
unreal dates to influence their location in the displayed folder.
.Sp
To start, the received headers are tried for a date (see
\&\fIMail::Message::Head::Complete::recvstamp()\fR) and only then the \f(CW\*(C`Date\*(C'\fR
field.  In very rare cases, only with some locally produced messages,
no stamp can be found.
.ie n .IP "$obj\->\fBto\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBto\fR()" 4
.IX Item "$obj->to()"
Returns the addresses which are specified on the \f(CW\*(C`To\*(C'\fR header line (or lines).
A list of Mail::Address objects is returned.  The people addressed
here are the targets of the content, and should read it contents
carefully.
.Sp
example: using \fIto()\fR to get all primar destination addresses
.Sp
.Vb 1
\& my @to = $message\->to;
.Ve
.SS "The body"
.IX Subsection "The body"
.ie n .IP "$obj\->\fBbody\fR( [$body] )" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR( [$body] )" 4
.IX Item "$obj->body( [$body] )"
Return the body of this message.  \s-1BE\s0 \s-1WARNED\s0 that this returns
you an object which may be encoded: use \fIdecoded()\fR to get a body
with usable data.
.Sp
With options, a new \f(CW$body\fR is set for this message.  This is \fBnot\fR
for normal use unless you understand the consequences: you change
the message content without changing the message-ID.  The right
way to go is via
.Sp
.Vb 3
\& $message = Mail::Message\->buildFromBody($body);  # or
\& $message = Mail::Message\->build($body);          # or
\& $message = $origmsg\->forward(body => $body);
.Ve
.Sp
The \f(CW$body\fR must be an (sub\-)class of Mail::Message::Body.  In this case,
information from the specified body will be copied into the header.  The
body object will be encoded if needed, because messages written to file
or transmitted shall not contain binary data.  The converted body
is returned.
.Sp
When \f(CW$body\fR is \f(CW\*(C`undef\*(C'\fR, the current message body will be dissected from
the message.  All relation will be cut.  The body is returned, and
can be connected to a different message.
.Sp
example:
.Sp
.Vb 2
\& my $body      = $msg\->body;
\& my @encoded   = $msg\->body\->lines;
\&
\& my $new       = Mail::Message::Body\->new(mime_type => \*(Aqtext/html\*(Aq);
\& my $converted = $msg\->body($new);
.Ve
.ie n .IP "$obj\->\fBcontentType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcontentType\fR()" 4
.IX Item "$obj->contentType()"
Returns the content type header line, or \f(CW\*(C`text/plain\*(C'\fR if it is not
defined.  The parameters will be stripped off.
.ie n .IP "$obj\->\fBdecoded\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBdecoded\fR(%options)" 4
.IX Item "$obj->decoded(%options)"
Decodes the body of this message, and returns it as a body object.
Short for \f(CW\*(C`<$msg\-\*(C'\fRbody\->decoded>>  All \f(CW%options\fR are passed-on.
.ie n .IP "$obj\->\fBencode\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBencode\fR(%options)" 4
.IX Item "$obj->encode(%options)"
Encode the message to a certain format.  Read the details in the
dedicated manual page Mail::Message::Body::Encode.  The \f(CW%options\fR which
can be specified here are those of the \fIMail::Message::Body::encode()\fR
method.
.ie n .IP "$obj\->\fBisMultipart\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisMultipart\fR()" 4
.IX Item "$obj->isMultipart()"
Check whether this message is a multipart message (has attachments).  To
find this out, we need at least the header of the message; there is no
need to read the body of the message to detect this.
.ie n .IP "$obj\->\fBisNested\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisNested\fR()" 4
.IX Item "$obj->isNested()"
Returns \f(CW\*(C`true\*(C'\fR for \f(CW\*(C`message/rfc822\*(C'\fR messages and message parts.
.ie n .IP "$obj\->\fBparts\fR( [<'\s-1ALL\s0'|'\s-1ACTIVE\s0'|'\s-1DELETED\s0'|'\s-1RECURSE\s0'|$filter>] )" 4
.el .IP "\f(CW$obj\fR\->\fBparts\fR( [<'\s-1ALL\s0'|'\s-1ACTIVE\s0'|'\s-1DELETED\s0'|'\s-1RECURSE\s0'|$filter>] )" 4
.IX Item "$obj->parts( [<'ALL'|'ACTIVE'|'DELETED'|'RECURSE'|$filter>] )"
Returns the \fIparts\fR of this message. Usually, the term \fIpart\fR is used
with \fImultipart\fR messages: messages which are encapsulated in the body
of a message.  To abstract this concept: this method will return you
all header-body combinations which are stored within this message
\&\fBexcept\fR the multipart and message/rfc822 wrappers.
Objects returned are \f(CW\*(C`Mail::Message\*(C'\fR's and Mail::Message::Part's.
.Sp
The option default to '\s-1ALL\s0', which will return the message itself for
single-parts, the nested content of a message/rfc822 object, respectively
the parts of a multipart without recursion.  In case of '\s-1RECURSE\s0', the
parts of multiparts will be collected recursively.  This option cannot
be combined with the other options, which you may want: it that case
you have to test yourself.
.Sp
\&'\s-1ACTIVE\s0' and '\s-1DELETED\s0' check for the deleted flag on messages and
message parts.  The \f(CW$filter\fR is a code reference, which is called for
each part of the message; each part as \f(CW\*(C`RECURSE\*(C'\fR would return.
.Sp
example:
.Sp
.Vb 2
\& my @parts = $msg\->parts;           # $msg not multipart: returns ($msg)
\& my $parts = $msg\->parts(\*(AqACTIVE\*(Aq); # returns ($msg)
\&
\& $msg\->delete;
\& my @parts = $msg\->parts;           # returns ($msg)
\& my $parts = $msg\->parts(\*(AqACTIVE\*(Aq); # returns ()
.Ve
.SS "Flags"
.IX Subsection "Flags"
.ie n .IP "$obj\->\fBdelete\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdelete\fR()" 4
.IX Item "$obj->delete()"
Flag the message to be deleted, which is a shortcut for
 \f(CW$msg\fR\->label(deleted => time);
The real deletion only takes place on a synchronization of the folder.
See \fIdeleted()\fR as well.
.Sp
The time stamp of the moment of deletion is stored as value, but that
is not always preserved in the folder (depends on the implementation).
When the same message is deleted more than once, the first time stamp
will stay.
.Sp
example:
.Sp
.Vb 4
\& $message\->delete;
\& $message\->deleted(1);  # exactly the same
\& $message\->label(deleted => 1);
\& delete $message;
.Ve
.ie n .IP "$obj\->\fBdeleted\fR( [\s-1BOOLEAN\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBdeleted\fR( [\s-1BOOLEAN\s0] )" 4
.IX Item "$obj->deleted( [BOOLEAN] )"
Set the delete flag for this message.  Without argument, the method
returns the same as \fIisDeleted()\fR, which is preferred.  When a true
value is given, \fIdelete()\fR is called.
.Sp
example:
.Sp
.Vb 2
\& $message\->deleted(1);          # delete
\& $message\->delete;              # delete (preferred)
\&
\& $message\->deleted(0);          # undelete
\&
\& if($message\->deleted) {...}    # check
\& if($message\->isDeleted) {...}  # check (preferred)
.Ve
.ie n .IP "$obj\->\fBisDeleted\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDeleted\fR()" 4
.IX Item "$obj->isDeleted()"
Short-cut for
 \f(CW$msg\fR\->label('deleted')
.Sp
For some folder types, you will get the time of deletion in return.  This
depends on the implementation.
.Sp
example:
.Sp
.Vb 1
\& next if $message\->isDeleted;
\&
\& if(my $when = $message\->isDeleted) {
\&    print scalar localtime $when;
\& }
.Ve
.ie n .IP "$obj\->\fBisModified\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisModified\fR()" 4
.IX Item "$obj->isModified()"
Returns whether this message is flagged as being modified.  Modifications
are changes in header lines, when a new body is set to the message
(dangerous), or when labels change.
.ie n .IP "$obj\->\fBlabel\fR($label|PAIRS)" 4
.el .IP "\f(CW$obj\fR\->\fBlabel\fR($label|PAIRS)" 4
.IX Item "$obj->label($label|PAIRS)"
Return the value of the \f(CW$label\fR, optionally after setting some values.  In
case of setting values, you specify key-value \s-1PAIRS\s0.
.Sp
Labels are used to store knowledge about handling of the message within
the folder.  Flags about whether a message was read, replied to, or
scheduled for deletion.
.Sp
Some labels are taken from the header's \f(CW\*(C`Status\*(C'\fR and \f(CW\*(C`X\-Status\*(C'\fR lines.
Folder types like \s-1MH\s0 define a separate label file, and Maildir adds
letters to the message filename.  But the MailBox labels are always the
same.
.Sp
example:
.Sp
.Vb 3
\& print $message\->label(\*(Aqseen\*(Aq);
\& if($message\->label(\*(Aqseen\*(Aq)) {...};
\& $message\->label(seen => 1);
\&
\& $message\->label(deleted => 1);  # same as $message\->delete
.Ve
.ie n .IP "$obj\->\fBlabels\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlabels\fR()" 4
.IX Item "$obj->labels()"
Returns all known labels. In \s-1SCALAR\s0 context, it returns the knowledge
as reference to a hash.  This is a reference to the original data, but
you shall *not* change that data directly: call \f(CW\*(C`label\*(C'\fR for
changes!
.Sp
In \s-1LIST\s0 context, you get a list of names which are defined.  Be warned
that they will not all evaluate to true, although most of them will.
.ie n .IP "$obj\->\fBlabelsToStatus\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlabelsToStatus\fR()" 4
.IX Item "$obj->labelsToStatus()"
When the labels were changed, that may effect the \f(CW\*(C`Status\*(C'\fR and/or
\&\f(CW\*(C`X\-Status\*(C'\fR header lines of mbox messages.  Read about the relation
between these fields and the labels in the \s-1DETAILS\s0 chapter.
.Sp
The method will carefully only affect the result of \fImodified()\fR when
there is a real change of flags, so not for each call to \fIlabel()\fR.
.ie n .IP "$obj\->\fBmodified\fR( [\s-1BOOLEAN\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR( [\s-1BOOLEAN\s0] )" 4
.IX Item "$obj->modified( [BOOLEAN] )"
Returns (optionally after setting) whether this message is flagged as
being modified.  See \fIisModified()\fR.
.ie n .IP "$obj\->\fBstatusToLabels\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstatusToLabels\fR()" 4
.IX Item "$obj->statusToLabels()"
Update the labels according the status lines in the header.  See the
description in the \s-1DETAILS\s0 chapter.
.SS "The whole message as text"
.IX Subsection "The whole message as text"
.ie n .IP "$obj\->\fBfile\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfile\fR()" 4
.IX Item "$obj->file()"
Inherited, see \*(L"The whole message as text\*(R" in Mail::Message::Construct::Text
.ie n .IP "$obj\->\fBlines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlines\fR()" 4
.IX Item "$obj->lines()"
Inherited, see \*(L"The whole message as text\*(R" in Mail::Message::Construct::Text
.ie n .IP "$obj\->\fBprintStructure\fR( [$fh|undef],[$indent] )" 4
.el .IP "\f(CW$obj\fR\->\fBprintStructure\fR( [$fh|undef],[$indent] )" 4
.IX Item "$obj->printStructure( [$fh|undef],[$indent] )"
Inherited, see \*(L"The whole message as text\*(R" in Mail::Message::Construct::Text
.ie n .IP "$obj\->\fBstring\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR()" 4
.IX Item "$obj->string()"
Inherited, see \*(L"The whole message as text\*(R" in Mail::Message::Construct::Text
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBclonedFrom\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclonedFrom\fR()" 4
.IX Item "$obj->clonedFrom()"
Returns the \f(CW$message\fR which is the source of this message, which was
created by a \fIclone()\fR operation.
.ie n .IP "Mail::Message\->\fBcoerce\fR($message, %options)" 4
.el .IP "Mail::Message\->\fBcoerce\fR($message, \f(CW%options\fR)" 4
.IX Item "Mail::Message->coerce($message, %options)"
Coerce a \f(CW$message\fR into a Mail::Message.  In some occasions, for instance
where you add a message to a folder, this coercion is automatically
called to ensure that the correct message type is stored.
.Sp
The coerced message is returned on success, otherwise \f(CW\*(C`undef\*(C'\fR.  The
coerced message may be a reblessed version of the original message
or a new object.  In case the message has to be specialized, for
instance from a general Mail::Message into a Mail::Box::Mbox::Message,
no copy is needed.  However, to coerce a Mail::Internet object into
a Mail::Message, a lot of copying and converting will take place.
.Sp
Valid MESSAGEs which can be coerced into Mail::Message objects
are of type
.RS 4
.IP "\(bu" 4
Any type of Mail::Box::Message
.IP "\(bu" 4
MIME::Entity objects, using Mail::Message::Convert::MimeEntity
.IP "\(bu" 4
Mail::Internet objects, using Mail::Message::Convert::MailInternet
.IP "\(bu" 4
Email::Simple objects, using Mail::Message::Convert::EmailSimple
.IP "\(bu" 4
Email::Abstract objects
.RE
.RS 4
.Sp
Mail::Message::Part's, which are extensions of \f(CW\*(C`Mail::Message\*(C'\fR's,
can also be coerced directly from a Mail::Message::Body.
.Sp
example:
.Sp
.Vb 2
\& my $folder  = Mail::Box::Mbox\->new;
\& my $message = Mail::Message\->build(...);
\&
\& my $coerced = Mail::Box::Mbox::Message\->coerce($message);
\& $folder\->addMessage($coerced);
.Ve
.Sp
Simpler replacement for the previous two lines:
.Sp
.Vb 1
\& my $coerced = $folder\->addMessage($message);
.Ve
.RE
.ie n .IP "$obj\->\fBisDelayed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDelayed\fR()" 4
.IX Item "$obj->isDelayed()"
Check whether the message is delayed (not yet read from file).  Returns
true or false, dependent on the body type.
.ie n .IP "$obj\->\fBreadBody\fR( $parser, $head, [$bodytype] )" 4
.el .IP "\f(CW$obj\fR\->\fBreadBody\fR( \f(CW$parser\fR, \f(CW$head\fR, [$bodytype] )" 4
.IX Item "$obj->readBody( $parser, $head, [$bodytype] )"
Read a body of a message.  The \f(CW$parser\fR is the access to the folder's
file, and the \f(CW$head\fR is already read.  Information from the \f(CW$head\fR is used
to create expectations about the message's length, but also to determine
the mime-type and encodings of the body data.
.Sp
The \f(CW$bodytype\fR determines which kind of body will be made and defaults to
the value specified by new(body_type).
\&\f(CW$bodytype\fR may be the name of a body class, or a reference
to a routine which returns the body's class when passed the \f(CW$head\fR as only
argument.
.ie n .IP "$obj\->\fBreadFromParser\fR( $parser, [$bodytype] )" 4
.el .IP "\f(CW$obj\fR\->\fBreadFromParser\fR( \f(CW$parser\fR, [$bodytype] )" 4
.IX Item "$obj->readFromParser( $parser, [$bodytype] )"
Read one message from file.  The \f(CW$parser\fR is opened on the file.  First
\&\fIreadHead()\fR is called, and the head is stored in the message.  Then
\&\fIreadBody()\fR is called, to produce a body.  Also the body is added to
the message without decodings being done.
.Sp
The optional \f(CW$bodytype\fR may be a body class or a reference to a code
which returns a body-class based on the header.
.ie n .IP "$obj\->\fBreadHead\fR( $parser, [$class] )" 4
.el .IP "\f(CW$obj\fR\->\fBreadHead\fR( \f(CW$parser\fR, [$class] )" 4
.IX Item "$obj->readHead( $parser, [$class] )"
Read a head into an object of the specified \f(CW$class\fR.  The \f(CW$class\fR defaults to
new(head_type).  The \f(CW$parser\fR is the access to the folder's file.
.ie n .IP "$obj\->\fBrecursiveRebuildPart\fR($part, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBrecursiveRebuildPart\fR($part, \f(CW%options\fR)" 4
.IX Item "$obj->recursiveRebuildPart($part, %options)"
Inherited, see \*(L"Internals\*(R" in Mail::Message::Construct::Rebuild
.ie n .IP "$obj\->\fBstoreBody\fR($body)" 4
.el .IP "\f(CW$obj\fR\->\fBstoreBody\fR($body)" 4
.IX Item "$obj->storeBody($body)"
Where the \fIbody()\fR method can be used to set and get a body, with all
the necessary checks, this method is bluntly adding the specified body
to the message.  No conversions, not checking.
.ie n .IP "$obj\->\fBtakeMessageId\fR( [\s-1STRING\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBtakeMessageId\fR( [\s-1STRING\s0] )" 4
.IX Item "$obj->takeMessageId( [STRING] )"
Take the message-id from the \s-1STRING\s0, or create one when the \f(CW\*(C`undef\*(C'\fR
is specified.  If not \s-1STRING\s0 nor \f(CW\*(C`undef\*(C'\fR is given, the current header
of the message is requested for the value of the \f(CW\*(AqMessage\-ID\*(Aq\fR field.
.Sp
Angles (if present) are removed from the id.
.SS "Error handling"
.IX Subsection "Error handling"
Extends \*(L"Error handling\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
Inherited, see \*(L"\s-1METHODS\s0\*(R" in Mail::Message::Construct
.ie n .IP "$obj\->\fBaddReport\fR($object)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR($object)" 4
.IX Item "$obj->addReport($object)"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "$obj->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD 0
.ie n .IP "Mail::Message\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "Mail::Message\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "Mail::Message->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR( [$level, [$strings]] )" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "$obj->log( [$level, [$strings]] )"
.PD 0
.IP "Mail::Message\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "Mail::Message->log( [$level, [$strings]] )"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR($level)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR($level)" 4
.IX Item "$obj->logPriority($level)"
.PD 0
.IP "Mail::Message\->\fBlogPriority\fR($level)" 4
.IX Item "Mail::Message->logPriority($level)"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR( [$level] )" 4
.IX Item "$obj->report( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR( [$level] )" 4
.IX Item "$obj->reportAll( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBshortSize\fR( [$value] )" 4
.el .IP "\f(CW$obj\fR\->\fBshortSize\fR( [$value] )" 4
.IX Item "$obj->shortSize( [$value] )"
.PD 0
.IP "Mail::Message\->\fBshortSize\fR( [$value] )" 4
.IX Item "Mail::Message->shortSize( [$value] )"
.PD
Represent an integer \f(CW$value\fR representing the size of file or memory,
(which can be large) into a short string using M and K (Megabytes
and Kilobytes).  Without \f(CW$value\fR, the size of the message head is used.
.ie n .IP "$obj\->\fBshortString\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBshortString\fR()" 4
.IX Item "$obj->shortString()"
Convert the message header to a short string (without trailing newline),
representing the most important facts (for debugging purposes only).  For
now, it only reports size and subject.
.ie n .IP "$obj\->\fBtrace\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR( [$level] )" 4
.IX Item "$obj->trace( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
Extends \*(L"Cleanup\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
Inherited, see \*(L"Cleanup\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBdestruct\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdestruct\fR()" 4
.IX Item "$obj->destruct()"
Remove the information contained in the message object.  This will be
ignored when more than one reference to the same message object exists,
because the method has the same effect as assigning \f(CW\*(C`undef\*(C'\fR to the
variable which contains the reference.  Normal garbage collection will
call \f(CW\*(C`DESTROY()\*(C'\fR when possible.
.Sp
This method is only provided to hide differences with messages which are
located in folders: their \fIMail::Box::Message::destruct()\fR works quite
differently.
.Sp
example: of Mail::Message destruct
.Sp
.Vb 3
\& my $msg = Mail::Message\->read;
\& $msg\->destruct;
\& $msg = undef;    # same
.Ve
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Structure of a Message"
.IX Subsection "Structure of a Message"
A MIME-compliant message is build upon two parts: the \fIheader\fR and the
\&\fIbody\fR.
.PP
\fIThe header\fR
.IX Subsection "The header"
.PP
The header is a list of fields, some spanning more than one line
(\fIfolded\fR) each telling something about the message. Information stored
in here are for instance the sender of the message, the receivers of
the message, when it was transported, how it was transported, etc.
Headers can grow quite large.
.PP
In MailBox, each message object manages exactly one header object
(a Mail::Message::Head) and one body object (a Mail::Message::Body).
The header contains a list of header fields, which are represented by
Mail::Message::Field objects.
.PP
\fIThe body\fR
.IX Subsection "The body"
.PP
The body contains the \*(L"payload\*(R": the data to be transferred.
The data can be encoded, only accessible with a specific application,
and may use some weird character-set, like Vietnamese; the MailBox
distribution tries to assist you with handling these e\-mails without
the need to know all the details.  This additional information
(\*(L"meta-information\*(R") about the body data is stored in the header.
The header contains more information, for instance about the message
transport and relations to other messages.
.SS "Message object implementation"
.IX Subsection "Message object implementation"
The general idea about the structure of a message is
.PP
.Vb 7
\& Mail::Message
\&  |  |
\&  |  \`\-has\-one\-\-Mail::Message::Body
\&  |
\&  \`\-\-\-\-has\-one\-\-Mail::Message::Head
\&                  |
\&                  \`\-has\-many\-\-Mail::Message::Field
.Ve
.PP
However: there are about 7 kinds of body objects, 3 kinds of headers and
3 kinds of fields.  You will usually not see too much of these kinds,
because they are merely created for performance reasons and can be used
all the same, with the exception of the multipart bodies.
.PP
A multipart body is either a Mail::Message::Body::Multipart
(mime type \f(CW\*(C`multipart/*\*(C'\fR) or a Mail::Message::Body::Nested
(mime type \f(CW\*(C`message/rfc822\*(C'\fR).  These bodies are more complex:
.PP
.Vb 7
\& Mail::Message::Body::Multipart
\&  |
\&  \`\-has\-many\-\-Mail::Message::Part
\&               |  |
\&               |  \`\-has\-one\-\-Mail::Message::Body
\&               |
\&               \`\-\-\-\-has\-one\-\-Mail::Message::Head
.Ve
.PP
Before you try to reconstruct multiparts or nested messages yourself,
you can better take a look at Mail::Message::Construct::Rebuild.
.SS "Message class implementation"
.IX Subsection "Message class implementation"
The class structure of messages is very close to that of folders.  For
instance, a Mail::Box::File::Message relates to a Mail::Box::File
folder.
.PP
As extra level of inheritance, it has a Mail::Message, which
is a message without location.  And there is a special case of
message: Mail::Message::Part is a message encapsulated in a
multipart body.
.PP
The message types are:
.PP
.Vb 10
\& Mail::Box::Mbox::Message            Mail::Box::POP3::Message
\& |  Mail::Box::Dbx::Message      Mail::Box::IMAP4::Message  |
\& |  |                                                    |  |
\& Mail::Box::File::Message             Mail::Box::Net::Message
\&         |                                      |
\&         |       Mail::Box::Maildir::Message    |
\&         |       |   Mail::Box::MH::Message     |
\&         |       |   |                          |
\&         |       Mail::Box::Dir::Message        |
\&         |                |                     |
\&         \`\-\-\-\-\-\-\-\-\-\-\-\-.   |   .\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&                      |   |   |
\&                   Mail::Box::Message    Mail::Message::Part
\&                          |                     |
\&                          |       .\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&                          |       |
\&                      Mail::Message
\&                          |
\&                          |
\&                    Mail::Reporter (general base class)
.Ve
.PP
By far most folder features are implemented in Mail::Box, so
available to all folder types.  Sometimes, features which appear
in only some of the folder types are simulated for folders that miss
them, like sub-folder support for \s-1MBOX\s0.
.PP
Two strange other message types are defined:
the Mail::Message::Dummy, which fills holes in
Mail::Box::Thread::Node lists, and a Mail::Box::Message::Destructed,
this is an on purpose demolished message to reduce memory consumption.
.SS "Labels"
.IX Subsection "Labels"
Labels (also named \*(L"Flags\*(R") are used to indicate some special condition on
the message, primary targeted on organizational issues: which messages are
already read or should be deleted.  There is a very strong user relation
to labels.
.PP
The main complication is that each folder type has its own way of storing
labels.  To give an indication: \s-1MBOX\s0 folders use \f(CW\*(C`Status\*(C'\fR and \f(CW\*(C`X\-Status\*(C'\fR
header fields, \s-1MH\s0 uses a \f(CW\*(C`.mh\-sequences\*(C'\fR file, \s-1MAILDIR\s0 encodes the flags
in the message's filename, and \s-1IMAP\s0 has flags as part of the protocol.
.PP
Besides, some folder types can store labels with user defined names,
where other lack that feature.  Some folders have case-insensitive
labels, other don't. Read all about the specifics in the manual page of
the message type you actually have.
.PP
\fIPredefined labels\fR
.IX Subsection "Predefined labels"
.PP
To standardize the folder types, MailBox has defined the following labels,
which can be used with the \fIlabel()\fR and \fIlabels()\fR methods on all kinds
of messages:
.IP "\(bu" 4
deleted
.Sp
This message is flagged to be deleted once the folder closes.  Be very
careful about the concept of 'delete' in a folder context : it is only a
flag, and does not involve immediate action!  This means, for instance,
that the memory which is used by Perl to store the message is not released
immediately (see \fIdestruct()\fR if you need to).
.Sp
The methods \fIdelete()\fR, \fIdeleted()\fR, and \fIisDeleted()\fR are only
short-cuts for managing the \f(CW\*(C`delete\*(C'\fR label (as of MailBox 2.052).
.IP "\(bu" 4
draft
.Sp
The user has prepared this message, but is has not been send (yet).  This
flag is not automatically added to a message by MailBox, and has only
a meaning in user applications.
.IP "\(bu" 4
flagged
.Sp
Messages can be \fIflagged\fR for some purpose, for instance as result of
a search for spam in a folder.  The \fIMail::Box::messages()\fR method
can be used to collect all these flagged messages from the folder.
.Sp
Probably it is more useful to use an understandable name (like \f(CW\*(C`spam\*(C'\fR)
for these selections, however these self-defined labels can not stored
in all folder types.
.IP "\(bu" 4
old
.Sp
The message was already in the folder when it was opened the last time,
so was not recently added to the folder.  This flag will never automatically
be set by MailBox, because it would probably conflict with the user's
idea of what is old.
.IP "\(bu" 4
passed
.Sp
Not often used or kept, this flag indicates that the message was bounced
or forwarded to someone else.
.IP "\(bu" 4
replied
.Sp
The user (or application) has sent a message back to the sender of
the message, as response of this one.  This flag is automatically
set if you use \fIreply()\fR, but not with \fIforward()\fR or \fIbounce()\fR.
.IP "\(bu" 4
seen
.Sp
When this flag is set, the receiver of the message has consumed the message.
A mail user agent (\s-1MUA\s0) will set this flag when the user has opened the
message once.
.PP
\fIStatus and X\-Status fields\fR
.IX Subsection "Status and X-Status fields"
.PP
Mbox folders have no special means of storing information about messages
(except the message separator line), and therefore have to revert to
adding fields to the message header when something special comes up.
This feature is also enabled for \s-1POP3\s0, although whether that works
depends on the \s-1POP\s0 server.
.PP
All applications which can handle mbox folders support the \f(CW\*(C`Status\*(C'\fR and
\&\f(CW\*(C`X\-Status\*(C'\fR field convensions.  The following encoding is used:
.PP
.Vb 5
\& Flag   Field       Label
\& R      Status   => seen    (Read)
\& O      Status   => old     (not recent)
\& A      X\-Status => replied (Answered)
\& F      X\-Status => flagged
.Ve
.PP
There is no special flag for \f(CW\*(C`deleted\*(C'\fR, which most other folders support:
messages flagged to be deleted will never be written to a folder file when
it is closed.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Cannot coerce a $class object into a $class object" 4
.el .IP "Error: Cannot coerce a \f(CW$class\fR object into a \f(CW$class\fR object" 4
.IX Item "Error: Cannot coerce a $class object into a $class object"
.PD 0
.ie n .IP "Error: Cannot include forward source as $include." 4
.el .IP "Error: Cannot include forward source as \f(CW$include\fR." 4
.IX Item "Error: Cannot include forward source as $include."
.PD
Unknown alternative for the forward(include).  Valid choices are
\&\f(CW\*(C`NO\*(C'\fR, \f(CW\*(C`INLINE\*(C'\fR, \f(CW\*(C`ATTACH\*(C'\fR, and \f(CW\*(C`ENCAPSULATE\*(C'\fR.
.ie n .IP "Error: Cannot include reply source as $include." 4
.el .IP "Error: Cannot include reply source as \f(CW$include\fR." 4
.IX Item "Error: Cannot include reply source as $include."
Unknown alternative for the \f(CW\*(C`include\*(C'\fR option of \fIreply()\fR.  Valid
choices are \f(CW\*(C`NO\*(C'\fR, \f(CW\*(C`INLINE\*(C'\fR, and \f(CW\*(C`ATTACH\*(C'\fR.
.IP "Error: Method bounce requires To, Cc, or Bcc" 4
.IX Item "Error: Method bounce requires To, Cc, or Bcc"
The message \fIbounce()\fR method forwards a received message off to someone
else without modification; you must specified it's new destination.
If you have the urge not to specify any destination, you probably
are looking for \fIreply()\fR. When you wish to modify the content, use
\&\fIforward()\fR.
.IP "Error: Method forwardAttach requires a preamble" 4
.IX Item "Error: Method forwardAttach requires a preamble"
.PD 0
.IP "Error: Method forwardEncapsulate requires a preamble" 4
.IX Item "Error: Method forwardEncapsulate requires a preamble"
.IP "Error: No address to create forwarded to." 4
.IX Item "Error: No address to create forwarded to."
.PD
If a forward message is created, a destination address must be specified.
.IP "Error: No default mailer found to send message." 4
.IX Item "Error: No default mailer found to send message."
The message \fIsend()\fR mechanism had not enough information to automatically
find a mail transfer agent to sent this message.  Specify a mailer
explicitly using the \f(CW\*(C`via\*(C'\fR options.
.ie n .IP "Error: No rebuild rule $name defined." 4
.el .IP "Error: No rebuild rule \f(CW$name\fR defined." 4
.IX Item "Error: No rebuild rule $name defined."
.PD 0
.IP "Error: Only \fIbuild()\fR Mail::Message's; they are not in a folder yet" 4
.IX Item "Error: Only build() Mail::Message's; they are not in a folder yet"
.PD
You may wish to construct a message to be stored in a some kind
of folder, but you need to do that in two steps.  First, create a
normal Mail::Message, and then add it to the folder.  During this
\&\fIMail::Box::addMessage()\fR process, the message will get \fIcoerce()\fR\-d
into the right message type, adding storage information and the like.
.ie n .IP "Error: Package $package does not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR does not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package does not implement $method."
Fatal error: the specific package (or one of its superclasses) does not
implement this method where it should. This message means that some other
related classes do implement this method however the class at hand does
not.  Probably you should investigate this and probably inform the author
of the package.
.IP "Error: coercion starts with some object" 4
.IX Item "Error: coercion starts with some object"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Box distribution version 2.117,
built on August 24, 2014. Website: \fIhttp://perl.overmeer.net/mailbox/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2014 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
