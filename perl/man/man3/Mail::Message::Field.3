.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::Message::Field 3"
.TH Mail::Message::Field 3 "2020-02-07" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Message::Field \- one line of a message header
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Message::Field
\&   is a Mail::Reporter
\&
\& Mail::Message::Field is extended by
\&   Mail::Message::Field::Fast
\&   Mail::Message::Field::Flex
\&   Mail::Message::Field::Full
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\& my $field = Mail::Message::Field\->new(From => \*(Aqfish@tux.aq\*(Aq);
\& print $field\->name;
\& print $field\->body;
\& print $field\->comment;
\& print $field\->content;  # body & comment
\& $field\->print(\e*OUT);
\& print $field\->string;
\& print "$field\en";
\& print $field\->attribute(\*(Aqcharset\*(Aq) || \*(Aqus\-ascii\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This implementation follows the guidelines of rfc2822 as close as possible,
and may there produce a different output than implementations based on
the obsolete rfc822.  However, the old output will still be accepted.
.PP
These objects each store one header line, and facilitates access routines to
the information hidden in it.  Also, you may want to have a look at the
added methods of a message:
.PP
.Vb 4
\& my @from    = $message\->from;
\& my $sender  = $message\->sender;
\& my $subject = $message\->subject;
\& my $msgid   = $message\->messageId;
\&
\& my @to      = $message\->to;
\& my @cc      = $message\->cc;
\& my @bcc     = $message\->bcc;
\& my @dest    = $message\->destinations;
\&
\& my $other   = $message\->get(\*(AqReply\-To\*(Aq);
.Ve
.PP
Extends \*(L"\s-1DESCRIPTION\*(R"\s0 in Mail::Reporter.
.SH "OVERLOADED"
.IX Header "OVERLOADED"
.ie n .IP "overload: \fB""""\fR" 4
.el .IP "overload: \fB``''\fR" 4
.IX Item "overload: """""
(stringification) produces the unfolded body of the field, which may
be what you expect.  This is what makes what the field object seems
to be a simple string. The string is produced by \fBunfoldedBody()\fR.
.Sp
example:
.Sp
.Vb 2
\& print $msg\->get(\*(Aqsubject\*(Aq);  # via overloading
\& print $msg\->get(\*(Aqsubject\*(Aq)\->unfoldedBody; # same
\&
\& my $subject = $msg\->get(\*(Aqsubject\*(Aq) || \*(Aqyour mail\*(Aq;
\& print "Re: $subject\en";
.Ve
.IP "overload: \fB0+\fR" 4
.IX Item "overload: 0+"
(numification) When the field is numeric, the value will be returned.
The result is produced by \fBtoInt()\fR.  If the value is not correct,
a \f(CW0\fR is produced, to simplify calculations.
.IP "overload: \fB<=\fR>" 4
.IX Item "overload: <=>"
(numeric comparison) Compare the integer field contents with something
else.
.Sp
example:
.Sp
.Vb 2
\& if($msg\->get(\*(AqContent\-Length\*(Aq) > 10000) ...
\& if($msg\->size > 10000) ... ; # same, but better
.Ve
.IP "overload: \fBbool\fR" 4
.IX Item "overload: bool"
Always true, to make it possible to say \f(CW\*(C`if($field)\*(C'\fR.
.IP "overload: \fBcmp\fR" 4
.IX Item "overload: cmp"
(string comparison) Compare the unfolded body of a field with another
field or a string, using the buildin \f(CW\*(C`cmp\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\*(R"\s0 in Mail::Reporter.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fBclone\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR()" 4
.IX Item "$obj->clone()"
Create a copy of this field object.
.IP "Mail::Message::Field\->\fBnew\fR($data)" 4
.IX Item "Mail::Message::Field->new($data)"
See \fBMail::Message::Field::Fast::new()\fR,
\&\fBMail::Message::Field::Flex::new()\fR,
and \fBMail::Message::Field::Full::new()\fR.
By default, a \f(CW\*(C`Fast\*(C'\fR field is produced.
.Sp
.Vb 3
\& \-Option\-\-Defined in     \-\-Default
\&  log     Mail::Reporter   \*(AqWARNINGS\*(Aq
\&  trace   Mail::Reporter   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "log => \s-1LEVEL\s0" 2
.IX Item "log => LEVEL"
.PD 0
.IP "trace => \s-1LEVEL\s0" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.PD
.SS "The field"
.IX Subsection "The field"
.ie n .IP "$obj\->\fBisStructured\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisStructured\fR()" 4
.IX Item "$obj->isStructured()"
.PD 0
.IP "Mail::Message::Field\->\fBisStructured\fR()" 4
.IX Item "Mail::Message::Field->isStructured()"
.PD
Some fields are described in the RFCs as being \fIstructured\fR: having a
well described syntax.  These fields have common ideas about comments
and the like, what they do not share with unstructured fields, like
the \f(CW\*(C`Subject\*(C'\fR field.
.Sp
example:
.Sp
.Vb 2
\& my $field = Mail::Message::Field\->new(From => \*(Aqme\*(Aq);
\& if($field\->isStructured)
\&
\& Mail::Message::Field\->isStructured(\*(AqFrom\*(Aq);
.Ve
.ie n .IP "$obj\->\fBlength\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlength\fR()" 4
.IX Item "$obj->length()"
Returns the total length of the field in characters, which includes the
field's name, body and folding characters.
.ie n .IP "$obj\->\fBnrLines\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrLines\fR()" 4
.IX Item "$obj->nrLines()"
Returns the number of lines needed to display this header-line.
.ie n .IP "$obj\->\fBprint\fR( [$fh] )" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR( [$fh] )" 4
.IX Item "$obj->print( [$fh] )"
Print the whole header-line to the specified file-handle. One line may
result in more than one printed line, because of the folding of long
lines.  The \f(CW$fh\fR defaults to the selected handle.
.ie n .IP "$obj\->\fBsize\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsize\fR()" 4
.IX Item "$obj->size()"
Returns the number of bytes needed to display this header-line, Same
as \fBlength()\fR.
.ie n .IP "$obj\->\fBstring\fR( [$wrap] )" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR( [$wrap] )" 4
.IX Item "$obj->string( [$wrap] )"
Returns the field as string.  By default, this returns the same as
\&\fBfolded()\fR. However, the optional \f(CW$wrap\fR will cause to re-fold to take
place (without changing the folding stored inside the field).
.ie n .IP "$obj\->\fBtoDisclose\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoDisclose\fR()" 4
.IX Item "$obj->toDisclose()"
Returns whether this field can be disclosed to other people, for instance
when sending the message to another party.  Returns a \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR
condition.
See also \fBMail::Message::Head::Complete::printUndisclosed()\fR.
.SS "Access to the name"
.IX Subsection "Access to the name"
.ie n .IP "$obj\->\fBName\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBName\fR()" 4
.IX Item "$obj->Name()"
Returns the name of this field in original casing.  See \fBname()\fR as well.
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Returns the name of this field, with all characters lower-cased for
ease of comparison.  See \fBName()\fR as well.
.ie n .IP "$obj\->\fBwellformedName\fR( [\s-1STRING\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBwellformedName\fR( [\s-1STRING\s0] )" 4
.IX Item "$obj->wellformedName( [STRING] )"
(Instance method class method)
As instance method, the current field's name is correctly formatted
and returned.  When a \s-1STRING\s0 is used, that one is formatted.
.Sp
example:
.Sp
.Vb 2
\& print Mail::Message::Field\->Name(\*(Aqcontent\-type\*(Aq)
\&   # \-\->  Content\-Type
\&
\& my $field = $head\->get(\*(Aqdate\*(Aq);
\& print $field\->Name;
\&   # \-\->  Date
.Ve
.SS "Access to the body"
.IX Subsection "Access to the body"
.ie n .IP "$obj\->\fBbody\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbody\fR()" 4
.IX Item "$obj->body()"
This method may be what you want, but usually, the \fBfoldedBody()\fR and
\&\fBunfoldedBody()\fR are what you are looking for.  This method is
cultural heritage, and should be avoided.
.Sp
Returns the body of the field.  When this field is structured, it will
be \fBstripped\fR from everything what is behind the first semi-color (\f(CW\*(C`;\*(C'\fR).
In any case, the string is unfolded.  
Whether the field is structured is defined by \fBisStructured()\fR.
.ie n .IP "$obj\->\fBfolded\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfolded\fR()" 4
.IX Item "$obj->folded()"
Returns the folded version of the whole header.  When the header is
shorter than the wrap length, a list of one line is returned.  Otherwise
more lines will be returned, all but the first starting with at least
one blank.  See also \fBfoldedBody()\fR to get the same information without
the field's name.
.Sp
In scalar context, the lines are delived into one string, which is
a little faster because that's the way they are stored internally...
.Sp
example:
.Sp
.Vb 3
\& my @lines = $field\->folded;
\& print $field\->folded;
\& print scalar $field\->folded; # faster
.Ve
.ie n .IP "$obj\->\fBfoldedBody\fR( [$body] )" 4
.el .IP "\f(CW$obj\fR\->\fBfoldedBody\fR( [$body] )" 4
.IX Item "$obj->foldedBody( [$body] )"
Returns the body as a set of lines. In scalar context, this will be
one line containing newlines.  Be warned about the newlines when you do
pattern matching on the result of this method.
.Sp
The optional \f(CW$body\fR argument changes the field's body.  The folding of the
argument must be correct.
.ie n .IP "$obj\->\fBstripCFWS\fR( [\s-1STRING\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBstripCFWS\fR( [\s-1STRING\s0] )" 4
.IX Item "$obj->stripCFWS( [STRING] )"
.PD 0
.IP "Mail::Message::Field\->\fBstripCFWS\fR( [\s-1STRING\s0] )" 4
.IX Item "Mail::Message::Field->stripCFWS( [STRING] )"
.PD
Remove the \fIcomments\fR and \fIfolding white spaces\fR from the \s-1STRING.\s0  Without
string and only as instance method, the \fBunfoldedBody()\fR is being stripped
and returned.
.Sp
\&\s-1WARNING:\s0 This operation is only allowed for structured header fields (which
are defined by the various RFCs as being so.  You don't want parts within
braces which are in the Subject header line to be removed, to give an
example.
.ie n .IP "$obj\->\fBunfoldedBody\fR( [$body, [$wrap]] )" 4
.el .IP "\f(CW$obj\fR\->\fBunfoldedBody\fR( [$body, [$wrap]] )" 4
.IX Item "$obj->unfoldedBody( [$body, [$wrap]] )"
Returns the body as one single line, where all folding information (if
available) is removed.  This line will also \s-1NOT\s0 end on a new-line.
.Sp
The optional \f(CW$body\fR argument changes the field's body.  The right folding is
performed before assignment.  The \f(CW$wrap\fR may be specified to enforce a
folding size.
.Sp
example:
.Sp
.Vb 2
\& my $body = $field\->unfoldedBody;
\& print "$field";   # via overloading
.Ve
.SS "Access to the content"
.IX Subsection "Access to the content"
.ie n .IP "$obj\->\fBaddresses\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddresses\fR()" 4
.IX Item "$obj->addresses()"
Returns a list of Mail::Address objects, which represent the
e\-mail addresses found in this header line.
.Sp
example:
.Sp
.Vb 2
\& my @addr = $message\->head\->get(\*(Aqto\*(Aq)\->addresses;
\& my @addr = $message\->to;
.Ve
.ie n .IP "$obj\->\fBattribute\fR( $name, [$value] )" 4
.el .IP "\f(CW$obj\fR\->\fBattribute\fR( \f(CW$name\fR, [$value] )" 4
.IX Item "$obj->attribute( $name, [$value] )"
Get the value of an attribute, optionally after setting it to a new value.
Attributes are part of some header lines, and hide themselves in the
comment field.  If the attribute does not exist, then \f(CW\*(C`undef\*(C'\fR is
returned.  The attribute is still encoded.
.Sp
example:
.Sp
.Vb 2
\& my $field = Mail::Message::Field\->new(
\&  \*(AqContent\-Type: text/plain; charset="us\-ascii"\*(Aq);
\&
\& print $field\->attribute(\*(Aqcharset\*(Aq);
\&   # \-\-> us\-ascii
\&
\& print $field\->attribute(\*(Aqbitmap\*(Aq) || \*(Aqno\*(Aq
\&   # \-\-> no
\&
\& $field\->atrribute(filename => \*(Aq/tmp/xyz\*(Aq);
\& $field\->print;
\&   # \-\-> Content\-Type: text/plain; charset="us\-ascii";
\&   #       filename="/tmp/xyz"
\&   # Automatically folded, and no doubles created.
.Ve
.ie n .IP "$obj\->\fBattributes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBattributes\fR()" 4
.IX Item "$obj->attributes()"
Returns a list of key-value pairs, where the values are not yet decoded.
Keys may appear more than once.
.Sp
example:
.Sp
.Vb 1
\& my @pairs = $head\->get(\*(AqContent\-Disposition\*(Aq)\->attributes;
.Ve
.ie n .IP "$obj\->\fBcomment\fR( [\s-1STRING\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBcomment\fR( [\s-1STRING\s0] )" 4
.IX Item "$obj->comment( [STRING] )"
Returns the unfolded comment (part after a semi-colon) in a structureed
header-line. optionally after setting it to a new \s-1STRING\s0 first.
When \f(CW\*(C`undef\*(C'\fR is specified as \s-1STRING,\s0 the comment is removed.
Whether the field is structured is defined by \fBisStructured()\fR.
.Sp
The \fIcomment\fR part of a header field often contains \f(CW\*(C`attributes\*(C'\fR.  Often
it is preferred to use \fBattribute()\fR on them.
.ie n .IP "$obj\->\fBstudy\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR()" 4
.IX Item "$obj->study()"
Study the header field in detail: turn on the full parsing and detailed
understanding of the content of the fields.  Mail::Message::Field::Fast
and Mail::Message::Field::Fast objects will be transformed into any
Mail::Message::Field::Full object.
.Sp
example:
.Sp
.Vb 3
\& my $subject = $msg\->head\->get(\*(Aqsubject\*(Aq)\->study;
\& my $subject = $msg\->head\->study(\*(Aqsubject\*(Aq);  # same
\& my $subject = $msg\->study(\*(Aqsubject\*(Aq);        # same
.Ve
.ie n .IP "$obj\->\fBtoDate\fR( [$time] )" 4
.el .IP "\f(CW$obj\fR\->\fBtoDate\fR( [$time] )" 4
.IX Item "$obj->toDate( [$time] )"
.PD 0
.IP "Mail::Message::Field\->\fBtoDate\fR( [$time] )" 4
.IX Item "Mail::Message::Field->toDate( [$time] )"
.PD
Convert a timestamp into an rfc2822 compliant date format.  This differs
from the default output of \f(CW\*(C`localtime\*(C'\fR in scalar context.  Without
argument, the \f(CW\*(C`localtime\*(C'\fR is used to get the current time. \f(CW$time\fR can
be specified as one numeric (like the result of \f(CW\*(C`time()\*(C'\fR) and as list
(like produced by c<\fBlocaltime()\fR> in list context).
.Sp
Be sure to have your timezone set right, especially when this script
runs automatically.
.Sp
example:
.Sp
.Vb 3
\& my $now = time;
\& Mail::Message::Field\->toDate($now);
\& Mail::Message::Field\->toDate(time);
\&
\& Mail::Message::Field\->toDate(localtime);
\& Mail::Message::Field\->toDate;      # same
\& # returns something like:
\& #     Wed, 28 Aug 2002 10:40:25 +0200
.Ve
.ie n .IP "$obj\->\fBtoInt\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtoInt\fR()" 4
.IX Item "$obj->toInt()"
Returns the value which is related to this field as integer.  A check is
performed whether this is right.
.SS "Other methods"
.IX Subsection "Other methods"
.ie n .IP "$obj\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.IX Item "$obj->dateToTimestamp(STRING)"
.PD 0
.IP "Mail::Message::Field\->\fBdateToTimestamp\fR(\s-1STRING\s0)" 4
.IX Item "Mail::Message::Field->dateToTimestamp(STRING)"
.PD
Convert a \s-1STRING\s0 which represents and \s-1RFC\s0 compliant time string into
a timestamp like is produced by the \f(CW\*(C`time\*(C'\fR function.
.SS "Internals"
.IX Subsection "Internals"
.ie n .IP "$obj\->\fBconsume\fR( $line | <$name,<$body|$objects>> )" 4
.el .IP "\f(CW$obj\fR\->\fBconsume\fR( \f(CW$line\fR | <$name,<$body|$objects>> )" 4
.IX Item "$obj->consume( $line | <$name,<$body|$objects>> )"
Accepts a whole field \f(CW$line\fR, or a pair with the field's \f(CW$name\fR and \f(CW$body\fR. In
the latter case, the \f(CW$body\fR data may be specified as array of \f(CW$objects\fR which
are stringified.  Returned is a nicely formatted pair of two strings: the
field's name and a folded body.
.Sp
This method is called by \fBnew()\fR, and usually not by an application
program. The details about converting the \f(CW$objects\fR to a field content
are explained in \*(L"Specifying field data\*(R".
.ie n .IP "$obj\->\fBdefaultWrapLength\fR( [$length] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultWrapLength\fR( [$length] )" 4
.IX Item "$obj->defaultWrapLength( [$length] )"
Any field from any header for any message will have this default wrapping.
This is maintained in one global variable.  Without a specified \f(CW$length\fR,
the current value is returned.  The default is 78.
.ie n .IP "$obj\->\fBfold\fR( $name, $body, [$maxchars] )" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR( \f(CW$name\fR, \f(CW$body\fR, [$maxchars] )" 4
.IX Item "$obj->fold( $name, $body, [$maxchars] )"
.PD 0
.ie n .IP "Mail::Message::Field\->\fBfold\fR( $name, $body, [$maxchars] )" 4
.el .IP "Mail::Message::Field\->\fBfold\fR( \f(CW$name\fR, \f(CW$body\fR, [$maxchars] )" 4
.IX Item "Mail::Message::Field->fold( $name, $body, [$maxchars] )"
.PD
Make the header field with \f(CW$name\fR fold into multiple lines.
Wrapping is performed by inserting newlines before a blanks in the
\&\f(CW$body\fR, such that no line exceeds the \f(CW$maxchars\fR and each line is as long
as possible.
.Sp
The \s-1RFC\s0 requests for folding on nice spots, but this request is
mainly ignored because it would make folding too slow.
.ie n .IP "$obj\->\fBsetWrapLength\fR( [$length] )" 4
.el .IP "\f(CW$obj\fR\->\fBsetWrapLength\fR( [$length] )" 4
.IX Item "$obj->setWrapLength( [$length] )"
Force the wrapping of this field to the specified \f(CW$length\fR characters. The
wrapping is performed with \fBfold()\fR and the results stored within
the field object.
.Sp
example: refolding the field
.Sp
.Vb 1
\& $field\->setWrapLength(99);
.Ve
.ie n .IP "$obj\->\fBstringifyData\fR(STRING|ARRAY|$objects)" 4
.el .IP "\f(CW$obj\fR\->\fBstringifyData\fR(STRING|ARRAY|$objects)" 4
.IX Item "$obj->stringifyData(STRING|ARRAY|$objects)"
This method implements the translation of user supplied objects into
ascii fields.  The process is explained in \*(L"Specifying field data\*(R".
.ie n .IP "$obj\->\fBunfold\fR(\s-1STRING\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBunfold\fR(\s-1STRING\s0)" 4
.IX Item "$obj->unfold(STRING)"
The reverse action of \fBfold()\fR: all lines which form the body of a field
are joined into one by removing all line terminators (even the last).
Possible leading blanks on the first line are removed as well.
.SS "Error handling"
.IX Subsection "Error handling"
Extends \*(L"Error handling\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fB\s-1AUTOLOAD\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1AUTOLOAD\s0\fR()" 4
.IX Item "$obj->AUTOLOAD()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBaddReport\fR($object)" 4
.el .IP "\f(CW$obj\fR\->\fBaddReport\fR($object)" 4
.IX Item "$obj->addReport($object)"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "$obj->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD 0
.ie n .IP "Mail::Message::Field\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "Mail::Message::Field\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "Mail::Message::Field->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBerrors\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBerrors\fR()" 4
.IX Item "$obj->errors()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR( [$level, [$strings]] )" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "$obj->log( [$level, [$strings]] )"
.PD 0
.IP "Mail::Message::Field\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "Mail::Message::Field->log( [$level, [$strings]] )"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlogPriority\fR($level)" 4
.el .IP "\f(CW$obj\fR\->\fBlogPriority\fR($level)" 4
.IX Item "$obj->logPriority($level)"
.PD 0
.IP "Mail::Message::Field\->\fBlogPriority\fR($level)" 4
.IX Item "Mail::Message::Field->logPriority($level)"
.PD
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBlogSettings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlogSettings\fR()" 4
.IX Item "$obj->logSettings()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBnotImplemented\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnotImplemented\fR()" 4
.IX Item "$obj->notImplemented()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR( [$level] )" 4
.IX Item "$obj->report( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR( [$level] )" 4
.IX Item "$obj->reportAll( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR( [$level] )" 4
.IX Item "$obj->trace( [$level] )"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.ie n .IP "$obj\->\fBwarnings\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBwarnings\fR()" 4
.IX Item "$obj->warnings()"
Inherited, see \*(L"Error handling\*(R" in Mail::Reporter
.SS "Cleanup"
.IX Subsection "Cleanup"
Extends \*(L"Cleanup\*(R" in Mail::Reporter.
.ie n .IP "$obj\->\fB\s-1DESTROY\s0\fR()" 4
.el .IP "\f(CW$obj\fR\->\fB\s-1DESTROY\s0\fR()" 4
.IX Item "$obj->DESTROY()"
Inherited, see \*(L"Cleanup\*(R" in Mail::Reporter
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Field syntax"
.IX Subsection "Field syntax"
Fields are stored in the header of a message, which are represented by
Mail::Message::Head objects. A field is a combination of a \fIname\fR,
\&\fIbody\fR, and \fIattributes\fR.  Especially the term \*(L"body\*(R" is cause for
confusion: sometimes the attributes are considered to be part of the body.
.PP
The name of the field is followed by a colon ("\f(CW\*(C`:\*(C'\fR\*(L", not preceded by
blanks, but followed by one blank).  Each attribute is preceded by
a separate semi-colon (\*(R"\f(CW\*(C`;\*(C'\fR").  Names of fields are case-insensitive and
cannot contain blanks.
.PP
\&\fB. Example: of fields\fR
.PP
Correct fields:
.PP
.Vb 2
\& Field: hi!
\& Content\-Type: text/html; charset=latin1
.Ve
.PP
Incorrect fields, but accepted:
.PP
.Vb 4
\& Field : wrong, blank before colon
\& Field:                 # wrong, empty
\& Field:not nice, blank preferred after colon
\& One Two: wrong, blank in name
.Ve
.PP
\fIFolding fields\fR
.IX Subsection "Folding fields"
.PP
Fields which are long can be folded to span more than one line.  The real
limit for lines in messages is only at 998 characters, however such long
lines are not easy to read without support of an application.  Therefore
rfc2822 (which defines the message syntax) specifies explicitly that
field lines can be re-formatted into multiple sorter lines without change
of meaning, by adding new-line characters to any field before any blank or
tab.
.PP
Usually, the lines are reformatted to create lines which are 78 characters
maximum. Some applications try harder to fold on nice spots, like before
attributes.  Especially the \f(CW\*(C`Received\*(C'\fR field is often manually folded into
some nice layout.  In most cases however, it is preferred to produce lines
which are as long as possible but max 78.
.PP
\&\s-1BE WARNED\s0 that all fields can be subjected to folding, and that you usually
want the unfolded value.
.PP
\&\fB. Example: of field folding\fR
.PP
.Vb 1
\& Subject: this is a short line, and not folded
\&
\& Subject: this subject field is much longer, and therefore
\&  folded into multiple
\&  lines, although one more than needed.
.Ve
.PP
\fIStructured fields\fR
.IX Subsection "Structured fields"
.PP
The rfc2822 describes a large number of header fields explicitly.  These
fields have a defined meaning.  For some of the fields, like the \f(CW\*(C`Subject\*(C'\fR
field, the meaning is straight forward the contents itself.  These fields
are the \fIUnstructured Fields\fR.
.PP
Other fields have a well defined internal syntax because their content is
needed by e\-mail applications. For instance, the \f(CW\*(C`To\*(C'\fR field contains
addresses which must be understood by all applications in the same way.
These are the \fIStructured Fields\fR, see \fBisStructured()\fR.
.PP
\fIComments in fields\fR
.IX Subsection "Comments in fields"
.PP
Stuctured fields can contain comments, which are pieces of text enclosed in
parenthesis.  These comments can be placed close to anywhere in the line
and must be ignored be the application.  Not all applications are capable
of handling comments correctly in all circumstances.
.PP
\&\fB. Example: of field comments\fR
.PP
.Vb 3
\& To: mailbox (Mail::Box mailinglist) <mailbox@overmeer.net>
\& Date: Thu, 13 Sep 2001 09:40:48 +0200 (CEST)
\& Subject: goodbye (was: hi!)
.Ve
.PP
On the first line, the text \*(L"Mail::Box mailinglist\*(R" is used as comment.
Be warned that rfc2822 explicitly states that comments in e\-mail address
specifications should not be considered to contain any usable information.
.PP
On the second line, the timezone is specified as comment. The \f(CW\*(C`Date\*(C'\fR
field format has no way to indicate the timezone of the sender, but only
contains the timezone difference to \s-1UTC,\s0 however one could decide to add
this as comment.  Application must ignore this data because the \f(CW\*(C`Date\*(C'\fR
field is structured.
.PP
The last field is unstructured.  The text between parentheses is an
integral part of the subject line.
.SS "Getting a field"
.IX Subsection "Getting a field"
As many programs as there are handling e\-mail, as many variations on
accessing the header information are requested.  Be careful which way
you access the data: read the variations described here and decide
which solution suites your needs best.
.PP
\fIUsing \f(BIget()\fI field\fR
.IX Subsection "Using get() field"
.PP
The \f(CW\*(C`get()\*(C'\fR interface is copied from other Perl modules which can
handle e\-mail messages.  Many applications which simply replace
Mail::Internet objects by Mail::Message objects will work
without modification.
.PP
There is more than one get method.  The exact results depend on which
get you use.  When \fBMail::Message::get()\fR is called, you will get the
unfolded, stripped from comments, stripped from attributes contents of
the field as \fBstring\fR.  Character-set encodings will still be in the
string.  If the same fieldname appears more than once in the header,
only the last value is returned.
.PP
When \fBMail::Message::Head::get()\fR is called in scalar context, the
last field with the specified name is returned as field \fBobject\fR.
This object strinigfies into the unfolded contents of the field, including
attributes and comments.  In list context, all appearances of the field
in the header are returned as objects.
.PP
\&\s-1BE WARNED\s0 that some lines seem unique, but are not according to the
official rfc.  For instance, \f(CW\*(C`To\*(C'\fR fields can appear more than once.
If your program calls \f(CW\*(C`get(\*(Aqto\*(Aq)\*(C'\fR in scalar context, some information
is lost.
.PP
\&\fB. Example: of using \fBget()\fB\fR
.PP
.Vb 2
\& print $msg\->get(\*(Aqsubject\*(Aq) || \*(Aqno subject\*(Aq;
\& print $msg\->head\->get(\*(Aqsubject\*(Aq) || \*(Aqno subject\*(Aq;
\&
\& my @to = $msg\->head\->get(\*(Aqto\*(Aq);
.Ve
.PP
\fIUsing \f(BIstudy()\fI field\fR
.IX Subsection "Using study() field"
.PP
As the name \f(CW\*(C`study\*(C'\fR already implies, this way of accessing the fields is
much more thorough but also slower.  The \f(CW\*(C`study\*(C'\fR of a field is like a
\&\f(CW\*(C`get\*(C'\fR, but provides easy access to the content of the field and handles
character-set decoding correctly.
.PP
The \fBMail::Message::study()\fR method will only return the last field
with that name as object.  \fBMail::Message::Head::study()\fR and
\&\fBMail::Message::Field::study()\fR return all fields when used in list
context.
.PP
\&\fB. Example: of using \fBstudy()\fB\fR
.PP
.Vb 2
\& print $msg\->study(\*(Aqsubject\*(Aq) || \*(Aqno subject\*(Aq;
\& my @rec  = $msg\->head\->study(\*(AqReceived\*(Aq);
\&
\& my $from = $msg\->head\->get(\*(AqFrom\*(Aq)\->study;
\& my $from = $msg\->head\->study(\*(AqFrom\*(Aq);  # same
\& my @addr = $from\->addresses;
.Ve
.PP
\fIUsing resent groups\fR
.IX Subsection "Using resent groups"
.PP
Some fields belong together in a group of fields.  For instance, a set
of lines is used to define one step in the mail transport process.  Each
step adds a \f(CW\*(C`Received\*(C'\fR line, and optionally some \f(CW\*(C`Resent\-*\*(C'\fR lines and
\&\f(CW\*(C`Return\-Path\*(C'\fR.  These groups of lines shall stay together and in order
when the message header is processed.
.PP
The \f(CW\*(C`Mail::Message::Head::ResentGroup\*(C'\fR object simplifies the access to
these related fields.  These resent groups can be deleted as a whole,
or correctly constructed.
.PP
\&\fB. Example: of using resent groups\fR
.PP
.Vb 2
\& my $rgs = $msg\->head\->resentGroups;
\& $rgs[0]\->delete if @rgs;
\&
\& $msg\->head\->removeResentGroups;
.Ve
.SS "The field's data"
.IX Subsection "The field's data"
There are many ways to get the fields info as object, and there are also
many ways to process this data within the field.
.PP
\fIAccess to the field\fR
.IX Subsection "Access to the field"
.IP "\(bu" 4
\&\fBstring()\fR
.Sp
Returns the text of the body exactly as will be printed to file when
\&\fBprint()\fR is called, so name, main body, and attributes.
.IP "\(bu" 4
\&\fBfoldedBody()\fR
.Sp
Returns the text of the body, like \fBstring()\fR, but without the name of
the field.
.IP "\(bu" 4
\&\fBunfoldedBody()\fR
.Sp
Returns the text of the body, like \fBfoldedBody()\fR, but then with all
new-lines removed.  This is the normal way to get the content of
unstructured fields.  Character-set encodings will still be in place.
Fields are stringified into their unfolded representation.
.IP "\(bu" 4
\&\fBstripCFWS()\fR
.Sp
Returns the text of structured fields, where new-lines and comments are
removed from the string.  This is a good start for parsing the field,
for instance to find e\-mail addresses in them.
.IP "\(bu" 4
\&\fBMail::Message::Field::Full::decodedBody()\fR
.Sp
Studied fields can produce the unfolded text decoded into utf8 strings.
This is an expensive process, but the only correct way to get the field's
data.  More useful for people who are not living in \s-1ASCII\s0 space.
.IP "\(bu" 4
Studied fields
.Sp
Studied fields have powerful methods to provide ways to access and produce
the contents of (structured) fields exactly as the involved rfcs prescribe.
.PP
\fIUsing simplified field access\fR
.IX Subsection "Using simplified field access"
.PP
Some fields are accessed that often that there are support methods to
provide simplified access.  All these methods are called upon a message
directly.
.PP
\&\fB. Example: of simplified field access\fR
.PP
.Vb 2
\& print $message\->subject;
\& print $message\->get(\*(Aqsubject\*(Aq) || \*(Aq\*(Aq;  # same
\&
\& my @from = $message\->from; # returns addresses
\& $message\->reply\->send if $message\->sender;
.Ve
.PP
The \f(CW\*(C`sender\*(C'\fR method will return the address specified in the \f(CW\*(C`Sender\*(C'\fR
field, or the first named in the \f(CW\*(C`From\*(C'\fR field.  It will return \f(CW\*(C`undef\*(C'\fR
in case no address is known.
.PP
\fISpecifying field data\fR
.IX Subsection "Specifying field data"
.PP
Field data can be anything, strongly dependent on the type
of field at hand. If you decide to construct the fields very
carefully via some Mail::Message::Field::Full extension (like via
Mail::Message::Field::Addresses objects), then you will have protection
build-in.  However, you can bluntly create any Mail::Message::Field
object based on some data.
.PP
When you create a field, you may specify a string, object, or an array
of strings and objects.  On the moment, objects are only used to help
the construction on e\-mail addresses, however you may add some of your
own.
.PP
The following rules (implemented in \fBstringifyData()\fR) are obeyed given
the argument is:
.IP "\(bu" 4
a string
.Sp
The string must be following the (complicated) rules of the rfc2822, and
is made field content as specified.  When the string is not terminated
by a new-line (\f(CW"\en"\fR) it will be folded according to the standard rules.
.IP "\(bu" 4
a Mail::Address object
.Sp
The most used Perl object to parse and produce address lines.  This object
does not understand character set encodings in phrases.
.IP "\(bu" 4
a Mail::Identity object
.Sp
As part of the User::Identity distribution, this object has full
understanding of the meaning of one e\-mail address, related to a person.
All features defined by rfc2822 are implemented.
.IP "\(bu" 4
a User::Identity object
.Sp
A person is specified, which may have more than one Mail::Identity's
defined.  Some methods, like \fBMail::Message::reply()\fR and
\&\fBMail::Message::forward()\fR try to select the right e\-mail address
smart (see their method descriptions), but in other cases the first
e\-mail address found is used.
.IP "\(bu" 4
a User::Identity::Collection::Emails object
.Sp
All Mail::Identity objects in the collection will be included in
the field as a group carying the name of the collection.
.IP "\(bu" 4
any other object
.Sp
For all other objects, the stringification overload is used to produce
the field content.
.IP "\(bu" 4
an \s-1ARRAY\s0
.Sp
You may also specify an array with a mixture of any of the above.  The
elements will be joined as comma-separated list.  If you do not want
comma's inbetween, you will have to process the array yourself.
.PP
\&\fB. Example: specifying simple field data\fR
.PP
.Vb 2
\& my $f = Mail::Message::Field\->new(Subject => \*(Aqhi!\*(Aq);
\& my $b = Mail::Message\->build(Subject => \*(Aqmonkey\*(Aq);
.Ve
.PP
\&\fB. Example: s specifying e\-mail addresses for a field\fR
.PP
.Vb 5
\& use Mail::Address;
\& my $fish = Mail::Address\->new(\*(AqMail::Box\*(Aq, \*(Aqfish@tux.aq\*(Aq);
\& print $fish\->format;   # ==> Mail::Box <fish@tux.aq>
\& my $exa  = Mail::Address\->new(undef, \*(Aqme@example.com\*(Aq);
\& print $exa\->format;    # ==> me@example.com
\&
\& my $b = $msg\->build(To => "you@example.com");
\& my $b = $msg\->build(To => $fish);
\& my $b = $msg\->build(To => [ $fish, $exa ]);
\&
\& my @all = ($fish, "you@example.com", $exa);
\& my $b = $msg\->build(To => \e@all);
\& my $b = $msg\->build(To => [ "xyz", @all ]);
.Ve
.PP
\&\fB. Example: specifying identities for a field\fR
.PP
.Vb 9
\& use User::Identity;
\& my $patrik = User::Identity\->new
\&  ( name      => \*(Aqpatrik\*(Aq
\&  , full_name => "Patrik Fältström"  # from rfc
\&  , charset   => "ISO\-8859\-1"
\&  );
\& $patrik\->add
\&  ( email    => "him@home.net"
\&  );
\&
\& my $b = $msg\->build(To => $patrik);
\&
\& $b\->get(\*(AqTo\*(Aq)\->print;
\&   # ==> =?ISO\-8859\-1?Q?Patrik_F=E4ltstr=F6m?=
\&   #     <him@home.net>
.Ve
.SS "Field class implementation"
.IX Subsection "Field class implementation"
For performance reasons only, there are three types of fields: the
fast, the flexible, and the full understander:
.IP "\(bu" 4
Mail::Message::Field::Fast
.Sp
\&\f(CW\*(C`Fast\*(C'\fR objects are not derived from a \f(CW\*(C`Mail::Reporter\*(C'\fR.  The consideration
is that fields are so often created, and such a small objects at the same
time, that setting-up a logging for each of the objects is relatively
expensive and not really useful.
The fast field implementation uses an array to store the data: that
will be faster than using a hash.  Fast fields are not easily inheritable,
because the object creation and initiation is merged into one method.
.IP "\(bu" 4
Mail::Message::Field::Flex
.Sp
The flexible implementation uses a hash to store the data.  The \fBnew()\fR
and \f(CW\*(C`init\*(C'\fR methods are split, so this object is extensible.
.IP "\(bu" 4
Mail::Message::Field::Full
.Sp
With a full implementation of all applicable RFCs (about 5), the best
understanding of the fields is reached.  However, this comes with
a serious memory and performance penalty.  These objects are created
from fast or flex header fields when \fBstudy()\fR is called.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Field content is not numerical: $content" 4
.el .IP "Warning: Field content is not numerical: \f(CW$content\fR" 4
.IX Item "Warning: Field content is not numerical: $content"
The numeric value of a field is requested (for instance the \f(CW\*(C`Lines\*(C'\fR or
\&\f(CW\*(C`Content\-Length\*(C'\fR fields should be numerical), however the data contains
weird characters.
.ie n .IP "Warning: Illegal character in field name $name" 4
.el .IP "Warning: Illegal character in field name \f(CW$name\fR" 4
.IX Item "Warning: Illegal character in field name $name"
A new field is being created which does contain characters not permitted
by the RFCs.  Using this field in messages may break other e\-mail clients
or transfer agents, and therefore mutulate or extinguish your message.
.ie n .IP "Error: Package $package does not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR does not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package does not implement $method."
Fatal error: the specific package (or one of its superclasses) does not
implement this method where it should. This message means that some other
related classes do implement this method however the class at hand does
not.  Probably you should investigate this and probably inform the author
of the package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Message distribution version 3.009,
built on February 07, 2020. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2001\-2020 by [Mark Overmeer <markov@cpan.org>]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
