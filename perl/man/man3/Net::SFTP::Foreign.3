.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::SFTP::Foreign 3"
.TH Net::SFTP::Foreign 3 "2020-06-24" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SFTP::Foreign \- SSH File Transfer Protocol client
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Net::SFTP::Foreign;
\&    my $sftp = Net::SFTP::Foreign\->new($host);
\&    $sftp\->die_on_error("Unable to establish SFTP connection");
\&
\&    $sftp\->setcwd($path) or die "unable to change cwd: " . $sftp\->error;
\&
\&    $sftp\->get("foo", "bar") or die "get failed: " . $sftp\->error;
\&
\&    $sftp\->put("bar", "baz") or die "put failed: " . $sftp\->error;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1SFTP\s0 stands for \s-1SSH\s0 File Transfer Protocol and is a method of
transferring files between machines over a secure, encrypted
connection (as opposed to regular \s-1FTP,\s0 which functions over an
insecure connection). The security in \s-1SFTP\s0 comes through its
integration with \s-1SSH,\s0 which provides an encrypted transport layer over
which the \s-1SFTP\s0 commands are executed.
.PP
Net::SFTP::Foreign is a Perl client for the \s-1SFTP\s0 version 3 as defined
in the \s-1SSH\s0 File Transfer Protocol \s-1IETF\s0 draft, which can be found at
<http://www.openssh.org/txt/draft\-ietf\-secsh\-filexfer\-02.txt> (also
included on this package distribution, on the \f(CW\*(C`rfc\*(C'\fR directory).
.PP
Net::SFTP::Foreign uses any compatible \f(CW\*(C`ssh\*(C'\fR command installed on
the system (for instance, OpenSSH \f(CW\*(C`ssh\*(C'\fR) to establish the secure
connection to the remote server.
.PP
A wrapper module Net::SFTP::Foreign::Compat is also provided for
compatibility with Net::SFTP.
.SS "Net::SFTP::Foreign Vs. Net::SFTP Vs. Net::SSH2::SFTP"
.IX Subsection "Net::SFTP::Foreign Vs. Net::SFTP Vs. Net::SSH2::SFTP"
Why should I prefer Net::SFTP::Foreign over Net::SFTP?
.PP
Well, both modules have their pros and cons:
.PP
Net::SFTP::Foreign does not require a bunch of additional modules and
external libraries to work, just the OpenBSD \s-1SSH\s0 client (or any other
client compatible enough).
.PP
I trust OpenSSH \s-1SSH\s0 client more than Net::SSH::Perl, there are lots
of paranoid people ensuring that OpenSSH doesn't have security
holes!!!
.PP
If you have an \s-1SSH\s0 infrastructure already deployed, by using the same
binary \s-1SSH\s0 client, Net::SFTP::Foreign ensures a seamless integration
within your environment (configuration files, keys, etc.).
.PP
Net::SFTP::Foreign is much faster transferring files, specially over
networks with high (relative) latency.
.PP
Net::SFTP::Foreign provides several high level methods not available
from Net::SFTP as for instance \f(CW\*(C`find\*(C'\fR, \f(CW\*(C`glob\*(C'\fR, \f(CW\*(C`rget\*(C'\fR, \f(CW\*(C`rput\*(C'\fR,
\&\f(CW\*(C`rremove\*(C'\fR, \f(CW\*(C`mget\*(C'\fR, \f(CW\*(C`mput\*(C'\fR.
.PP
On the other hand, using the external command means an additional
process being launched and running, depending on your \s-1OS\s0 this could
eat more resources than the in process pure perl implementation
provided by Net::SSH::Perl.
.PP
Net::SSH2 is a module wrapping libssh2, an \s-1SSH\s0 version 2 client
library written in C. It is a very active project that aims to replace
Net::SSH::Perl. Unfortunately, libssh2 \s-1SFTP\s0 functionality
(available in Perl via Net::SSH2::SFTP) is rather limited and its
performance very poor.
.PP
Later versions of Net::SFTP::Foreign can use Net::SSH2 as the
transport layer via the backend module
Net::SFTP::Foreign::Backend::Net_SSH2.
.SS "Error handling"
.IX Subsection "Error handling"
The method \f(CW\*(C`$sftp\->error\*(C'\fR can be used to check for errors
after every method call. For instance:
.PP
.Vb 2
\&  $sftp = Net::SFTP::Foreign\->new($host);
\&  $sftp\->error and die "unable to connect to remote host: " . $sftp\->error;
.Ve
.PP
Also, the \*(L"die_on_error\*(R" method provides a handy shortcut for the last line:
.PP
.Vb 2
\&  $sftp = Net::SFTP::Foreign\->new($host);
\&  $sftp\->die_on_error("unable to connect to remote host");
.Ve
.PP
The \f(CW\*(C`status\*(C'\fR method can also be used to get the value for the last
\&\s-1SFTP\s0 status response, but that is only useful when calling low level
methods mapping to single \s-1SFTP\s0 primitives. In any case, it should be
considered an implementation detail of the module usable only for
troubleshooting and error reporting.
.SS "autodie mode"
.IX Subsection "autodie mode"
When the \f(CW\*(C`autodie\*(C'\fR mode is set at construction time, non-recoverable
errors are automatically promoted to exceptions. For instance:
.PP
.Vb 3
\&  $sftp = Net::SFTP::Foreign\->new($host, autodie => 1);
\&  my $ls = $sftp\->ls("/bar");
\&  # dies as: "Couldn\*(Aqt open remote dir \*(Aq/bar\*(Aq: No such file"
.Ve
.PP
\fIError handling in non-recursive methods\fR
.IX Subsection "Error handling in non-recursive methods"
.PP
Most of the non-recursive methods available from this package return
undef on failure and a true value or the requested data on success.
.PP
For instance:
.PP
.Vb 1
\&  $sftp\->get($from, $to) or die "get failed!";
.Ve
.PP
\fIError handling in recursive methods\fR
.IX Subsection "Error handling in recursive methods"
.PP
Recursive methods (i.e. \f(CW\*(C`find\*(C'\fR, \f(CW\*(C`rget\*(C'\fR, \f(CW\*(C`rput\*(C'\fR, \f(CW\*(C`rremove\*(C'\fR) do not
stop on errors but just skip the affected files and directories and
keep going.
.PP
After a call to a recursive method, the error indicator is only set
when an unrecoverable error is found (i.e. a connection lost). For
instance, this code doesn't work as expected:
.PP
.Vb 2
\&  $sftp\->rremove($dir);
\&  $sftp\->error and die "rremove failed"; # this is wrong!!!
.Ve
.PP
This does:
.PP
.Vb 3
\&  my $errors;
\&  $sftp\->rremove($dir, on_error => sub { $errors++});
\&  $errors and die "rremove failed";
.Ve
.PP
The \f(CW\*(C`autodie\*(C'\fR mode is disabled when an \f(CW\*(C`on_error\*(C'\fR handler is passed
to methods accepting it:
.PP
.Vb 6
\&  my $sftp = Net::SFTP::Foreign\->new($host, autodie => 1);
\&  # prints "foo!" and does not die:
\&  $sftp\->find("/sdfjkalshfl", # nonexistent directory
\&              on_error => sub { print "foo!\en" });
\&  # dies:
\&  $sftp\->find("/sdfjkalshfl");
.Ve
.SS "\s-1API\s0"
.IX Subsection "API"
The methods available from this module are described below.
.PP
Don't forget to read also the \s-1FAQ\s0 and \s-1BUGS\s0 sections at the end of this
document!
.ie n .IP "Net::SFTP::Foreign\->new($host, %args)" 4
.el .IP "Net::SFTP::Foreign\->new($host, \f(CW%args\fR)" 4
.IX Item "Net::SFTP::Foreign->new($host, %args)"
.PD 0
.IP "Net::SFTP::Foreign\->new(%args)" 4
.IX Item "Net::SFTP::Foreign->new(%args)"
.PD
Opens a new \s-1SFTP\s0 connection with a remote host \f(CW$host\fR, and returns a
Net::SFTP::Foreign object representing that open connection.
.Sp
An explicit check for errors should be included always after the
constructor call:
.Sp
.Vb 2
\&  my $sftp = Net::SFTP::Foreign\->new(...);
\&  $sftp\->die_on_error("SSH connection failed");
.Ve
.Sp
The optional arguments accepted are as follows:
.RS 4
.ie n .IP "host => $hostname" 4
.el .IP "host => \f(CW$hostname\fR" 4
.IX Item "host => $hostname"
remote host name
.ie n .IP "user => $username" 4
.el .IP "user => \f(CW$username\fR" 4
.IX Item "user => $username"
username to log in to the remote server. This should be your \s-1SSH\s0
login, and can be empty, in which case the username is drawn from the
user executing the process.
.ie n .IP "port => $portnumber" 4
.el .IP "port => \f(CW$portnumber\fR" 4
.IX Item "port => $portnumber"
port number where the remote \s-1SSH\s0 server is listening
.IP "ssh1 => 1" 4
.IX Item "ssh1 => 1"
use old \s-1SSH1\s0 approach for starting the remote \s-1SFTP\s0 server.
.IP "more => [@more_ssh_args]" 4
.IX Item "more => [@more_ssh_args]"
additional args passed to \f(CW\*(C`ssh\*(C'\fR command.
.Sp
For debugging purposes you can run \f(CW\*(C`ssh\*(C'\fR in verbose mode passing it
the \f(CW\*(C`\-v\*(C'\fR option:
.Sp
.Vb 1
\&  my $sftp = Net::SFTP::Foreign\->new($host, more => \*(Aq\-v\*(Aq);
.Ve
.Sp
Note that this option expects a single command argument or a reference
to an array of arguments. For instance:
.Sp
.Vb 4
\&  more => \*(Aq\-v\*(Aq         # right
\&  more => [\*(Aq\-v\*(Aq]       # right
\&  more => "\-c $cipher"    # wrong!!!
\&  more => [\-c => $cipher] # right
.Ve
.ie n .IP "timeout => $seconds" 4
.el .IP "timeout => \f(CW$seconds\fR" 4
.IX Item "timeout => $seconds"
when this parameter is set, the connection is dropped if no data
arrives on the \s-1SSH\s0 socket for the given time while waiting for some
command to complete.
.Sp
When the timeout expires, the current method is aborted and
the \s-1SFTP\s0 connection becomes invalid.
.Sp
Note that the given value is used internally to time out low level
operations. The high level operations available through the \s-1API\s0 may
take longer to expire (sometimes up to 4 times longer).
.Sp
The \f(CW\*(C`Windows\*(C'\fR backend used by default when the operating system is \s-1MS\s0
Windows (though, not under Cygwin perl), does not support timeouts. To
overcome this limitation you can switch to the \f(CW\*(C`Net_SSH2\*(C'\fR backend or
use Net::SSH::Any that provides its own backend supporting
timeouts.
.ie n .IP "fs_encoding => $encoding" 4
.el .IP "fs_encoding => \f(CW$encoding\fR" 4
.IX Item "fs_encoding => $encoding"
Version 3 of the \s-1SFTP\s0 protocol (the one supported by this module)
knows nothing about the character encoding used on the remote
filesystem to represent file and directory names.
.Sp
This option allows one to select the encoding used in the remote
machine. The default value is \f(CW\*(C`utf8\*(C'\fR.
.Sp
For instance:
.Sp
.Vb 1
\&  $sftp = Net::SFTP::Foreign\->new(\*(Aquser@host\*(Aq, fs_encoding => \*(Aqlatin1\*(Aq);
.Ve
.Sp
will convert any path name passed to any method in this package to its
\&\f(CW\*(C`latin1\*(C'\fR representation before sending it to the remote side.
.Sp
Note that this option will not affect file contents in any way.
.Sp
This feature is not supported in perl 5.6 due to incomplete Unicode
support in the interpreter.
.ie n .IP "key_path => $filename" 4
.el .IP "key_path => \f(CW$filename\fR" 4
.IX Item "key_path => $filename"
.PD 0
.IP "key_path => \e@filenames" 4
.IX Item "key_path => @filenames"
.PD
asks \f(CW\*(C`ssh\*(C'\fR to use the key(s) in the given file(s) for authentication.
.ie n .IP "password => $password" 4
.el .IP "password => \f(CW$password\fR" 4
.IX Item "password => $password"
Logs into the remote host using password authentication with the given
password.
.Sp
Password authentication is only available if the module IO::Pty is
installed. Note also, that on Windows this module is only available
when running the Cygwin port of Perl.
.IP "asks_for_username_at_login => 0|'auto'|1" 4
.IX Item "asks_for_username_at_login => 0|'auto'|1"
During the interactive authentication dialog, most \s-1SSH\s0 servers only
ask for the user password as the login name is passed inside the \s-1SSH\s0
protocol. But under some uncommon servers or configurations it is
possible that a username is also requested.
.Sp
When this flag is set to \f(CW1\fR, the username will be send
unconditionally at the first remote prompt and then the password at
the second.
.Sp
When it is set to \f(CW\*(C`auto\*(C'\fR the module will use some heuristics in order
to determine if it is being asked for an username.
.Sp
When set to \f(CW0\fR, the username will never be sent during the
authentication dialog. This is the default.
.ie n .IP "password_prompt => $regex_or_str" 4
.el .IP "password_prompt => \f(CW$regex_or_str\fR" 4
.IX Item "password_prompt => $regex_or_str"
The module expects the password prompt from the remote server to end
in a colon or a question mark. This seems to cover correctly 99% of
real life cases.
.Sp
Otherwise this option can be used to handle the exceptional cases. For
instance:
.Sp
.Vb 2
\&  $sftp = Net::SFTP::Foreign\->new($host, password => $password,
\&                                  password_prompt => qr/\ebpassword>\es*$/);
.Ve
.Sp
Note that your script will hang at the login phase if the wrong prompt
is used.
.ie n .IP "passphrase => $passphrase" 4
.el .IP "passphrase => \f(CW$passphrase\fR" 4
.IX Item "passphrase => $passphrase"
Logs into the remote server using a passphrase protected private key.
.Sp
Requires also the module IO::Pty.
.ie n .IP "expect_log_user => $bool" 4
.el .IP "expect_log_user => \f(CW$bool\fR" 4
.IX Item "expect_log_user => $bool"
This feature is obsolete as Expect is not used anymore to handle
password authentication.
.ie n .IP "ssh_cmd => $sshcmd" 4
.el .IP "ssh_cmd => \f(CW$sshcmd\fR" 4
.IX Item "ssh_cmd => $sshcmd"
.PD 0
.IP "ssh_cmd => \e@sshcmd" 4
.IX Item "ssh_cmd => @sshcmd"
.PD
name of the external \s-1SSH\s0 client. By default \f(CW\*(C`ssh\*(C'\fR is used.
.Sp
For instance:
.Sp
.Vb 1
\&  $sftp = Net::SFTP::Foreign\->new($host, ssh_cmd => \*(Aqplink\*(Aq);
.Ve
.Sp
When an array reference is used, its elements are inserted at the
beginning of the system call. That allows one, for instance, to
connect to the target host through some \s-1SSH\s0 proxy:
.Sp
.Vb 2
\&  $sftp = Net::SFTP::Foreign\->new($host,
\&              ssh_cmd => [qw(ssh \-l user proxy.server ssh)]);
.Ve
.Sp
But note that the module will not handle password authentication for
those proxies.
.IP "ssh_cmd_interface => 'plink' or 'ssh' or 'tectia'" 4
.IX Item "ssh_cmd_interface => 'plink' or 'ssh' or 'tectia'"
declares the command line interface that the \s-1SSH\s0 client used to
connect to the remote host understands. Currently \f(CW\*(C`plink\*(C'\fR, \f(CW\*(C`ssh\*(C'\fR and
\&\f(CW\*(C`tectia\*(C'\fR are supported.
.Sp
This option would be rarely required as the module infers the
interface from the \s-1SSH\s0 command name.
.ie n .IP "transport => $fh" 4
.el .IP "transport => \f(CW$fh\fR" 4
.IX Item "transport => $fh"
.PD 0
.ie n .IP "transport => [$in_fh, $out_fh]" 4
.el .IP "transport => [$in_fh, \f(CW$out_fh\fR]" 4
.IX Item "transport => [$in_fh, $out_fh]"
.ie n .IP "transport => [$in_fh, $out_fh, $pid]" 4
.el .IP "transport => [$in_fh, \f(CW$out_fh\fR, \f(CW$pid\fR]" 4
.IX Item "transport => [$in_fh, $out_fh, $pid]"
.PD
allows one to use an already open pipe or socket as the transport for
the \s-1SFTP\s0 protocol.
.Sp
It can be (ab)used to make this module work with password
authentication or with keys requiring a passphrase.
.Sp
\&\f(CW\*(C`in_fh\*(C'\fR is the file handler used to read data from the remote server,
\&\f(CW\*(C`out_fh\*(C'\fR is the file handler used to write data.
.Sp
On some systems, when using a pipe as the transport, closing it, does
not cause the process at the other side to exit. The additional
\&\f(CW$pid\fR argument can be used to instruct this module to kill that
process if it doesn't exit by itself.
.IP "open2_cmd => [@cmd]" 4
.IX Item "open2_cmd => [@cmd]"
.PD 0
.ie n .IP "open2_cmd => $cmd;" 4
.el .IP "open2_cmd => \f(CW$cmd\fR;" 4
.IX Item "open2_cmd => $cmd;"
.PD
allows one to completely redefine how \f(CW\*(C`ssh\*(C'\fR is called. Its arguments
are passed to IPC::Open2::open2 to open a pipe to the remote
server.
.ie n .IP "stderr_fh => $fh" 4
.el .IP "stderr_fh => \f(CW$fh\fR" 4
.IX Item "stderr_fh => $fh"
redirects the output sent to stderr by the \s-1SSH\s0 subprocess to the given
file handle.
.Sp
It can be used to suppress banners:
.Sp
.Vb 3
\&  open my $ssherr, \*(Aq>\*(Aq, \*(Aq/dev/null\*(Aq or die "unable to open /dev/null";
\&  my $sftp = Net::SFTP::Foreign\->new($host,
\&                                     stderr_fh => $ssherr);
.Ve
.Sp
Or to send \s-1SSH\s0 stderr to a file in order to capture errors for later
analysis:
.Sp
.Vb 10
\&  my $ssherr = File::Temp\->new or die "File::Temp\->new failed";
\&  my $sftp = Net::SFTP::Foreign\->new($hostname, more => [\*(Aq\-v\*(Aq],
\&                                     stderr_fh => $ssherr);
\&  if ($sftp\->error) {
\&    print "sftp error: ".$sftp\->error."\en";
\&    seek($ssherr, 0, 0);
\&    while (<$ssherr>) {
\&      print "captured stderr: $_";
\&    }
\&  }
.Ve
.IP "stderr_discard => 1" 4
.IX Item "stderr_discard => 1"
redirects stderr to /dev/null
.ie n .IP "block_size => $default_block_size" 4
.el .IP "block_size => \f(CW$default_block_size\fR" 4
.IX Item "block_size => $default_block_size"
.PD 0
.ie n .IP "queue_size => $default_queue_size" 4
.el .IP "queue_size => \f(CW$default_queue_size\fR" 4
.IX Item "queue_size => $default_queue_size"
.PD
default \f(CW\*(C`block_size\*(C'\fR and \f(CW\*(C`queue_size\*(C'\fR used for read and write
operations (see the \f(CW\*(C`put\*(C'\fR or \f(CW\*(C`get\*(C'\fR documentation).
.ie n .IP "autoflush => $bool" 4
.el .IP "autoflush => \f(CW$bool\fR" 4
.IX Item "autoflush => $bool"
by default, and for performance reasons, write operations are cached,
and only when the write buffer becomes big enough is the data written to
the remote file. Setting this flag makes the write operations immediate.
.ie n .IP "write_delay => $bytes" 4
.el .IP "write_delay => \f(CW$bytes\fR" 4
.IX Item "write_delay => $bytes"
This option determines how many bytes are buffered before the real
\&\s-1SFTP\s0 write operation is performed.
.ie n .IP "read_ahead => $bytes" 4
.el .IP "read_ahead => \f(CW$bytes\fR" 4
.IX Item "read_ahead => $bytes"
On read operations this option determines how many bytes to read in
advance so that later read operations can be fulfilled from the
buffer.
.Sp
Using a high value will increase the performance of the module for a
sequential reads access pattern but degrade it for a short random
reads access pattern. It can also cause synchronization problems if
the file is concurrently modified by other parties (\*(L"flush\*(R" can be
used to discard all the data inside the read buffer on demand).
.Sp
The default value is set dynamically considering some runtime
parameters and given options, though it tends to favor the sequential
read access pattern.
.ie n .IP "autodisconnect => $ad" 4
.el .IP "autodisconnect => \f(CW$ad\fR" 4
.IX Item "autodisconnect => $ad"
by default, the \s-1SSH\s0 connection is closed from the \s-1DESTROY\s0 method when
the object goes out of scope on the process and thread where it was
created. This option allows one to customize this behaviour.
.Sp
The acceptable values for \f(CW$ad\fR are:
.RS 4
.IP "'0'" 4
.IX Item "'0'"
Never try to disconnect this object when exiting from any process.
.Sp
On most operating systems, the \s-1SSH\s0 process will exit when the last
process connected to it ends, but this is not guaranteed.
.Sp
You can always call the \f(CW\*(C`disconnect\*(C'\fR method explicitly to end the
connection at the right time from the right place.
.IP "'1'" 4
.IX Item "'1'"
Disconnect on exit from any thread or process.
.IP "'2'" 4
.IX Item "'2'"
Disconnect on exit from the current process/thread only. This is the
default.
.RE
.RS 4
.Sp
See also the \f(CW\*(C`disconnect\*(C'\fR and \f(CW\*(C`autodisconnect\*(C'\fR methods.
.RE
.ie n .IP "late_set_perm => $bool" 4
.el .IP "late_set_perm => \f(CW$bool\fR" 4
.IX Item "late_set_perm => $bool"
See the \s-1FAQ\s0 below.
.ie n .IP "dirty_cleanup => $bool" 4
.el .IP "dirty_cleanup => \f(CW$bool\fR" 4
.IX Item "dirty_cleanup => $bool"
Sets the \f(CW\*(C`dirty_cleanup\*(C'\fR flag in a per object basis (see the \s-1BUGS\s0
section).
.ie n .IP "backend => $backend" 4
.el .IP "backend => \f(CW$backend\fR" 4
.IX Item "backend => $backend"
From version 1.57 Net::SFTP::Foreign supports plugable backends in
order to allow other ways to communicate with the remote server in
addition to the default \fIpipe-to-ssh-process\fR.
.Sp
Custom backends may change the set of options supported by the \f(CW\*(C`new\*(C'\fR
method.
.ie n .IP "autodie => $bool" 4
.el .IP "autodie => \f(CW$bool\fR" 4
.IX Item "autodie => $bool"
Enables the autodie mode that will cause the module to die when any
error is found (a la autodie).
.RE
.RS 4
.RE
.ie n .IP "$sftp\->error" 4
.el .IP "\f(CW$sftp\fR\->error" 4
.IX Item "$sftp->error"
Returns the error code from the last executed command. The value
returned is similar to \f(CW$!\fR, when used as a string it yields the
corresponding error string.
.Sp
See Net::SFTP::Foreign::Constants for a list of possible error
codes and how to import them on your scripts.
.ie n .IP "$sftp\->die_on_error($msg)" 4
.el .IP "\f(CW$sftp\fR\->die_on_error($msg)" 4
.IX Item "$sftp->die_on_error($msg)"
Convenience method:
.Sp
.Vb 3
\&  $sftp\->die_on_error("Something bad happened");
\&  # is a shortcut for...
\&  $sftp\->error and die "Something bad happened: " . $sftp\->error;
.Ve
.ie n .IP "$sftp\->status" 4
.el .IP "\f(CW$sftp\fR\->status" 4
.IX Item "$sftp->status"
Returns the code from the last \s-1SSH2_FXP_STATUS\s0 response. It is also a
dualvar that yields the status string when used as a string.
.Sp
Usually \f(CW\*(C`$sftp\->error\*(C'\fR should be checked first to see if there was
any error and then \f(CW\*(C`$sftp\->status\*(C'\fR to find out its low level cause.
.ie n .IP "$sftp\->cwd" 4
.el .IP "\f(CW$sftp\fR\->cwd" 4
.IX Item "$sftp->cwd"
Returns the remote current working directory.
.Sp
When a relative remote path is passed to any of the methods on this
package, this directory is used to compose the absolute path.
.ie n .IP "$sftp\->setcwd($dir, %opts)" 4
.el .IP "\f(CW$sftp\fR\->setcwd($dir, \f(CW%opts\fR)" 4
.IX Item "$sftp->setcwd($dir, %opts)"
Changes the remote current working directory. The remote directory
should exist, otherwise the call fails.
.Sp
Returns the new remote current working directory or undef on failure.
.Sp
Passing \f(CW\*(C`undef\*(C'\fR as the \f(CW$dir\fR argument resets the cwd to the server
default which is usually the user home but not always.
.Sp
The method accepts the following options:
.RS 4
.IP "check => 0" 4
.IX Item "check => 0"
By default the given target directory is checked against the remote
server to ensure that it actually exists and that it is a
directory. Some servers may fail to honor those requests even for
valid directories (i.e. when the directory has the hidden flag set).
.Sp
This option allows one to disable those checks and just sets the cwd
to the given value blindly.
.RE
.RS 4
.RE
.ie n .IP "$sftp\->get($remote, $local, %options)" 4
.el .IP "\f(CW$sftp\fR\->get($remote, \f(CW$local\fR, \f(CW%options\fR)" 4
.IX Item "$sftp->get($remote, $local, %options)"
Copies remote file \f(CW$remote\fR to local \f(CW$local\fR. By default file
attributes are also copied (permissions, atime and mtime). For
instance:
.IX Xref "get"
.Sp
.Vb 2
\&  $sftp\->get(\*(Aq/var/log/messages\*(Aq, \*(Aq/tmp/messages\*(Aq)
\&    or die "file transfer failed: " . $sftp\->error;
.Ve
.Sp
A file handle can also be used as the local target. In that case, the
remote file contents are retrieved and written to the given file
handle. Note also that the handle is not closed when the transmission
finish.
.Sp
.Vb 4
\&  open F, \*(Aq| gzip \-c > /tmp/foo\*(Aq or die ...;
\&  $sftp\->get("/etc/passwd", \e*F)
\&    or die "get failed: " . $sftp\->error;
\&  close F or die ...;
.Ve
.Sp
Accepted options (not all combinations are possible):
.RS 4
.ie n .IP "copy_time => $bool" 4
.el .IP "copy_time => \f(CW$bool\fR" 4
.IX Item "copy_time => $bool"
determines if access and modification time attributes have to be
copied from remote file. Default is to copy them.
.ie n .IP "copy_perm => $bool" 4
.el .IP "copy_perm => \f(CW$bool\fR" 4
.IX Item "copy_perm => $bool"
determines if permission attributes have to be copied from remote
file. Default is to copy them after applying the local process umask.
.ie n .IP "umask => $umask" 4
.el .IP "umask => \f(CW$umask\fR" 4
.IX Item "umask => $umask"
allows one to select the umask to apply when setting the permissions
of the copied file. Default is to use the umask for the current
process or \f(CW0\fR if the \f(CW\*(C`perm\*(C'\fR option is also used.
.ie n .IP "perm => $perm" 4
.el .IP "perm => \f(CW$perm\fR" 4
.IX Item "perm => $perm"
sets the permission mask of the file to be \f(CW$perm\fR, remote
permissions are ignored.
.IP "resume => 1 | 'auto'" 4
.IX Item "resume => 1 | 'auto'"
resumes an interrupted transfer.
.Sp
If the \f(CW\*(C`auto\*(C'\fR value is given, the transfer will be resumed only when
the local file is newer than the remote one.
.Sp
\&\f(CW\*(C`get\*(C'\fR transfers can not be resumed when a data conversion is in
place.
.IP "append => 1" 4
.IX Item "append => 1"
appends the contents of the remote file at the end of the local one
instead of overwriting it. If the local file does not exist a new one
is created.
.IP "overwrite => 0" 4
.IX Item "overwrite => 0"
setting this option to zero cancels the transfer when a local file of
the same name already exists.
.IP "numbered => 1" 4
.IX Item "numbered => 1"
modifies the local file name inserting a sequence number when required
in order to avoid overwriting local files.
.Sp
For instance:
.Sp
.Vb 3
\&  for (1..2) {
\&    $sftp\->get("data.txt", "data.txt", numbered => 1);
\&  }
.Ve
.Sp
will copy the remote file as \f(CW\*(C`data.txt\*(C'\fR the first time and as
\&\f(CW\*(C`data(1).txt\*(C'\fR the second one.
.Sp
If a scalar reference is passed as the numbered value, the final
target will be stored in the value pointed by the reference. For
instance:
.Sp
.Vb 3
\&  my $target;
\&  $sftp\->get("data.txt", "data.txt", numbered => \e$target);
\&  say "file was saved as $target" unless $sftp\->error
.Ve
.IP "atomic => 1" 4
.IX Item "atomic => 1"
The remote file contents are transferred into a temporal file that
once the copy completes is renamed to the target destination.
.Sp
If not-overwrite of remote files is also requested, an empty file may
appear at the target destination before the rename operation is
performed. This is due to limitations of some operating/file systems.
.IP "mkpath => 0" 4
.IX Item "mkpath => 0"
By default the method creates any non-existent parent directory for
the given target path. That feature can be disabled setting this flag
to 0.
.IP "cleanup => 1" 4
.IX Item "cleanup => 1"
If the transfer fails, remove the incomplete file.
.Sp
This option is set to by default when there is not possible to resume
the transfer afterwards (i.e., when using `atomic` or `numbered`
options).
.IP "best_effort => 1" 4
.IX Item "best_effort => 1"
Ignore minor errors as setting time or permissions.
.ie n .IP "conversion => $conversion" 4
.el .IP "conversion => \f(CW$conversion\fR" 4
.IX Item "conversion => $conversion"
on the fly data conversion of the file contents can be performed with
this option. See \*(L"On the fly data conversion\*(R" below.
.ie n .IP "callback => $callback" 4
.el .IP "callback => \f(CW$callback\fR" 4
.IX Item "callback => $callback"
\&\f(CW$callback\fR is a reference to a subroutine that will be called after
every iteration of the download process.
.Sp
The callback function will receive as arguments: the current
Net::SFTP::Foreign object; the data read from the remote file; the
offset from the beginning of the file in bytes; and the total size of
the file in bytes.
.Sp
This mechanism can be used to provide status messages, download
progress meters, etc.:
.Sp
.Vb 4
\&    sub callback {
\&        my($sftp, $data, $offset, $size) = @_;
\&        print "Read $offset / $size bytes\er";
\&    }
.Ve
.Sp
The \f(CW\*(C`abort\*(C'\fR method can be called from inside the callback to abort
the transfer:
.Sp
.Vb 6
\&    sub callback {
\&        my($sftp, $data, $offset, $size) = @_;
\&        if (want_to_abort_transfer()) {
\&            $sftp\->abort("You wanted to abort the transfer");
\&        }
\&    }
.Ve
.Sp
The callback will be called one last time with an empty data argument
to indicate the end of the file transfer.
.Sp
The size argument can change between different calls as data is
transferred (for instance, when on-the-fly data conversion is being
performed or when the size of the file can not be retrieved with the
\&\f(CW\*(C`stat\*(C'\fR \s-1SFTP\s0 command before the data transfer starts).
.ie n .IP "block_size => $bytes" 4
.el .IP "block_size => \f(CW$bytes\fR" 4
.IX Item "block_size => $bytes"
size of the blocks the file is being split on for transfer.
Incrementing this value can improve performance but most servers limit
the maximum size.
.ie n .IP "queue_size => $size" 4
.el .IP "queue_size => \f(CW$size\fR" 4
.IX Item "queue_size => $size"
read and write requests are pipelined in order to maximize transfer
throughput. This option allows one to set the maximum number of
requests that can be concurrently waiting for a server response.
.RE
.RS 4
.RE
.ie n .IP "$sftp\->get_content($remote)" 4
.el .IP "\f(CW$sftp\fR\->get_content($remote)" 4
.IX Item "$sftp->get_content($remote)"
Returns the content of the remote file.
.ie n .IP "$sftp\->get_symlink($remote, $local, %opts)" 4
.el .IP "\f(CW$sftp\fR\->get_symlink($remote, \f(CW$local\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->get_symlink($remote, $local, %opts)"
copies a symlink from the remote server to the local file system
.Sp
The accepted options are \f(CW\*(C`overwrite\*(C'\fR and \f(CW\*(C`numbered\*(C'\fR. They have the
same effect as for the \f(CW\*(C`get\*(C'\fR method.
.ie n .IP "$sftp\->put($local, $remote, %opts)" 4
.el .IP "\f(CW$sftp\fR\->put($local, \f(CW$remote\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->put($local, $remote, %opts)"
Uploads a file \f(CW$local\fR from the local host to the remote host saving
it as \f(CW$remote\fR. By default file attributes are also copied. For
instance:
.Sp
.Vb 2
\&  $sftp\->put("test.txt", "test.txt")
\&    or die "put failed: " . $sftp\->error;
.Ve
.Sp
A file handle can also be passed in the \f(CW$local\fR argument. In that
case, data is read from there and stored in the remote file. \s-1UTF8\s0 data
is not supported unless a custom converter callback is used to
transform it to bytes. The method will croak if it encounters any data
in perl internal \s-1UTF8\s0 format. Note also that the handle is not closed
when the transmission finish.
.Sp
Example:
.Sp
.Vb 3
\&  binmode STDIN;
\&  $sftp\->put(\e*STDIN, "stdin.dat") or die "put failed";
\&  close STDIN;
.Ve
.Sp
This method accepts several options:
.RS 4
.ie n .IP "copy_time => $bool" 4
.el .IP "copy_time => \f(CW$bool\fR" 4
.IX Item "copy_time => $bool"
determines if access and modification time attributes have to be
copied from remote file. Default is to copy them.
.ie n .IP "copy_perm => $bool" 4
.el .IP "copy_perm => \f(CW$bool\fR" 4
.IX Item "copy_perm => $bool"
determines if permission attributes have to be copied from remote
file. Default is to copy them after applying the local process umask.
.ie n .IP "umask => $umask" 4
.el .IP "umask => \f(CW$umask\fR" 4
.IX Item "umask => $umask"
allows one to select the umask to apply when setting the permissions
of the copied file. Default is to use the umask for the current
process.
.ie n .IP "perm => $perm" 4
.el .IP "perm => \f(CW$perm\fR" 4
.IX Item "perm => $perm"
sets the permission mask of the file to be \f(CW$perm\fR, umask and local
permissions are ignored.
.IP "overwrite => 0" 4
.IX Item "overwrite => 0"
by default \f(CW\*(C`put\*(C'\fR will overwrite any pre-existent file with the same
name at the remote side. Setting this flag to zero will make the
method fail in that case.
.IP "numbered => 1" 4
.IX Item "numbered => 1"
when set, a sequence number is added to the remote file name in order
to avoid overwriting pre-existent files. Off by default.
.IP "append => 1" 4
.IX Item "append => 1"
appends the local file at the end of the remote file instead of
overwriting it. If the remote file does not exist a new one is
created. Off by default.
.IP "resume => 1 | 'auto'" 4
.IX Item "resume => 1 | 'auto'"
resumes an interrupted transfer.
.Sp
If the \f(CW\*(C`auto\*(C'\fR value is given, the transfer will be resumed only when
the remote file is newer than the local one.
.IP "sparse => 1" 4
.IX Item "sparse => 1"
Blocks that are all zeros are skipped possibly creating an sparse file
on the remote host.
.IP "mkpath => 0" 4
.IX Item "mkpath => 0"
By default the method creates any non-existent parent directory for
the given target path. That feature can be disabled setting this flag
to 0.
.IP "atomic => 1" 4
.IX Item "atomic => 1"
The local file contents are transferred into a temporal file that
once the copy completes is renamed to the target destination.
.Sp
This operation relies on the \s-1SSH\s0 server to perform an
overwriting/non\-overwriting atomic rename operation free of race
conditions.
.Sp
OpenSSH server does it correctly on top of Linux/UNIX native file
systems (i.e. ext[234]>, ffs or zfs) but has problems on file systems
not supporting hard links (i.e. \s-1FAT\s0) or on operating systems with
broken \s-1POSIX\s0 semantics as Windows.
.IP "cleanup => 1" 4
.IX Item "cleanup => 1"
If the transfer fails, attempts to remove the incomplete file. Cleanup
may fail (for example, if the \s-1SSH\s0 connection gets broken).
.Sp
This option is set by default when the transfer is not resumable
(i.e., when using `atomic` or `numbered` options).
.IP "best_effort => 1" 4
.IX Item "best_effort => 1"
Ignore minor errors, as setting time and permissions on the remote
file.
.ie n .IP "conversion => $conversion" 4
.el .IP "conversion => \f(CW$conversion\fR" 4
.IX Item "conversion => $conversion"
on the fly data conversion of the file contents can be performed with
this option. See \*(L"On the fly data conversion\*(R" below.
.ie n .IP "callback => $callback" 4
.el .IP "callback => \f(CW$callback\fR" 4
.IX Item "callback => $callback"
\&\f(CW$callback\fR is a reference to a subroutine that will be called after
every iteration of the upload process.
.Sp
The callback function will receive as arguments: the current
Net::SFTP::Foreign object; the data that is going to be written to the
remote file; the offset from the beginning of the file in bytes; and
the total size of the file in bytes.
.Sp
The callback will be called one last time with an empty data argument
to indicate the end of the file transfer.
.Sp
The size argument can change between calls as data is transferred (for
instance, when on the fly data conversion is being performed).
.Sp
This mechanism can be used to provide status messages, download
progress meters, etc.
.Sp
The \f(CW\*(C`abort\*(C'\fR method can be called from inside the callback to abort
the transfer.
.ie n .IP "block_size => $bytes" 4
.el .IP "block_size => \f(CW$bytes\fR" 4
.IX Item "block_size => $bytes"
size of the blocks the file is being split on for transfer.
Incrementing this value can improve performance but some servers limit
its size and if this limit is overpassed the command will fail.
.ie n .IP "queue_size => $size" 4
.el .IP "queue_size => \f(CW$size\fR" 4
.IX Item "queue_size => $size"
read and write requests are pipelined in order to maximize transfer
throughput. This option allows one to set the maximum number of
requests that can be concurrently waiting for a server response.
.ie n .IP "late_set_perm => $bool" 4
.el .IP "late_set_perm => \f(CW$bool\fR" 4
.IX Item "late_set_perm => $bool"
See the \s-1FAQ\s0 below.
.RE
.RS 4
.RE
.ie n .IP "$sftp\->put_content($bytes, $remote, %opts)" 4
.el .IP "\f(CW$sftp\fR\->put_content($bytes, \f(CW$remote\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->put_content($bytes, $remote, %opts)"
Creates (or overwrites) a remote file whose content is the passed
data.
.ie n .IP "$sftp\->put_symlink($local, $remote, %opts)" 4
.el .IP "\f(CW$sftp\fR\->put_symlink($local, \f(CW$remote\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->put_symlink($local, $remote, %opts)"
Copies a local symlink to the remote host.
.Sp
The accepted options are \f(CW\*(C`overwrite\*(C'\fR and \f(CW\*(C`numbered\*(C'\fR.
.ie n .IP "$sftp\->\fBabort()\fR" 4
.el .IP "\f(CW$sftp\fR\->\fBabort()\fR" 4
.IX Item "$sftp->abort()"
.PD 0
.ie n .IP "$sftp\->abort($msg)" 4
.el .IP "\f(CW$sftp\fR\->abort($msg)" 4
.IX Item "$sftp->abort($msg)"
.PD
This method, when called from inside a callback sub, causes the
current transfer to be aborted
.Sp
The error state is set to \s-1SFTP_ERR_ABORTED\s0 and the optional \f(CW$msg\fR
argument is used as its textual value.
.ie n .IP "$sftp\->ls($remote, %opts)" 4
.el .IP "\f(CW$sftp\fR\->ls($remote, \f(CW%opts\fR)" 4
.IX Item "$sftp->ls($remote, %opts)"
Fetches a listing of the remote directory \f(CW$remote\fR. If \f(CW$remote\fR is
not given, the current remote working directory is listed.
.Sp
Returns a reference to a list of entries. Every entry is a reference
to a hash with three keys: \f(CW\*(C`filename\*(C'\fR, the name of the entry;
\&\f(CW\*(C`longname\*(C'\fR, an entry in a \*(L"long\*(R" listing like \f(CW\*(C`ls \-l\*(C'\fR; and \f(CW\*(C`a\*(C'\fR, a
Net::SFTP::Foreign::Attributes object containing file atime, mtime,
permissions and size.
.Sp
.Vb 2
\&    my $ls = $sftp\->ls(\*(Aq/home/foo\*(Aq)
\&        or die "unable to retrieve directory: ".$sftp\->error;
\&
\&    print "$_\->{filename}\en" for (@$ls);
.Ve
.Sp
The options accepted by this method are as follows (note that usage of
some of them can degrade the method performance when reading large
directories):
.RS 4
.IP "wanted => qr/.../" 4
.IX Item "wanted => qr/.../"
Only elements whose name matches the given regular expression are
included on the listing.
.IP "wanted => sub {...}" 4
.IX Item "wanted => sub {...}"
Only elements for which the callback returns a true value are included
on the listing. The callback is called with two arguments: the
\&\f(CW$sftp\fR object and the current entry (a hash reference as described
before). For instance:
.Sp
.Vb 1
\&  use Fcntl \*(Aq:mode\*(Aq;
\&
\&  my $files = $sftp\->ls ( \*(Aq/home/hommer\*(Aq,
\&                          wanted => sub {
\&                              my $entry = $_[1];
\&                              S_ISREG($entry\->{a}\->perm)
\&                          } )
\&        or die "ls failed: ".$sftp\->error;
.Ve
.IP "no_wanted => qr/.../" 4
.IX Item "no_wanted => qr/.../"
.PD 0
.IP "no_wanted => sub {...}" 4
.IX Item "no_wanted => sub {...}"
.PD
those options have the opposite result to their \f(CW\*(C`wanted\*(C'\fR counterparts:
.Sp
.Vb 3
\&  my $no_hidden = $sftp\->ls( \*(Aq/home/homer\*(Aq,
\&                             no_wanted => qr/^\e./ )
\&        or die "ls failed";
.Ve
.Sp
When both \f(CW\*(C`no_wanted\*(C'\fR and \f(CW\*(C`wanted\*(C'\fR rules are used, the \f(CW\*(C`no_wanted\*(C'\fR
rule is applied first and then the \f(CW\*(C`wanted\*(C'\fR one (order is important
if the callbacks have side effects, experiment!).
.IP "ordered => 1" 4
.IX Item "ordered => 1"
the list of entries is ordered by filename.
.IP "follow_links => 1" 4
.IX Item "follow_links => 1"
by default, the attributes on the listing correspond to a \f(CW\*(C`lstat\*(C'\fR
operation, setting this option causes the method to perform \f(CW\*(C`stat\*(C'\fR
requests instead. \f(CW\*(C`lstat\*(C'\fR attributes will still appear for links
pointing to non existent places.
.IP "atomic_readdir => 1" 4
.IX Item "atomic_readdir => 1"
reading a directory is not an atomic \s-1SFTP\s0 operation and the protocol
draft does not define what happens if \f(CW\*(C`readdir\*(C'\fR requests and write
operations (for instance \f(CW\*(C`remove\*(C'\fR or \f(CW\*(C`open\*(C'\fR) affecting the same
directory are intermixed.
.Sp
This flag ensures that no callback call (\f(CW\*(C`wanted\*(C'\fR, \f(CW\*(C`no_wanted\*(C'\fR) is
performed in the middle of reading a directory and has to be set if
any of the callbacks can modify the file system.
.IP "realpath => 1" 4
.IX Item "realpath => 1"
for every file object, performs a realpath operation and populates the
\&\f(CW\*(C`realpath\*(C'\fR entry.
.IP "names_only => 1" 4
.IX Item "names_only => 1"
makes the method return a simple array containing the file names from
the remote directory only. For instance, these two sentences are
equivalent:
.Sp
.Vb 1
\&  my @ls1 = @{ $sftp\->ls(\*(Aq.\*(Aq, names_only => 1) };
\&
\&  my @ls2 = map { $_\->{filename} } @{$sftp\->ls(\*(Aq.\*(Aq)};
.Ve
.RE
.RS 4
.RE
.ie n .IP "$sftp\->find($path, %opts)" 4
.el .IP "\f(CW$sftp\fR\->find($path, \f(CW%opts\fR)" 4
.IX Item "$sftp->find($path, %opts)"
.PD 0
.ie n .IP "$sftp\->find(\e@paths, %opts)" 4
.el .IP "\f(CW$sftp\fR\->find(\e@paths, \f(CW%opts\fR)" 4
.IX Item "$sftp->find(@paths, %opts)"
.PD
Does a recursive search over the given directory \f(CW$path\fR (or
directories \f(CW@path\fR) and returns a list of the entries found or the
total number of them on scalar context.
.IX Xref "find"
.Sp
Every entry is a reference to a hash with two keys: \f(CW\*(C`filename\*(C'\fR, the
full path of the entry; and \f(CW\*(C`a\*(C'\fR, a Net::SFTP::Foreign::Attributes
object containing file atime, mtime, permissions and size.
.Sp
This method tries to recover and continue under error conditions.
.Sp
The options accepted:
.RS 4
.IP "on_error => sub { ... }" 4
.IX Item "on_error => sub { ... }"
the callback is called when some error is detected, two arguments are
passed: the \f(CW$sftp\fR object and the entry that was being processed
when the error happened. For instance:
.Sp
.Vb 6
\&  my @find = $sftp\->find( \*(Aq/\*(Aq,
\&                          on_error => sub {
\&                              my ($sftp, $e) = @_;
\&                              print STDERR "error processing $e\->{filename}: "
\&                                   . $sftp\->error;
\&                          } );
.Ve
.IP "realpath => 1" 4
.IX Item "realpath => 1"
calls method \f(CW\*(C`realpath\*(C'\fR for every entry, the result is stored under
the key \f(CW\*(C`realpath\*(C'\fR. This option slows down the process as a new
remote query is performed for every entry, specially on networks with
high latency.
.IP "follow_links => 1" 4
.IX Item "follow_links => 1"
By default symbolic links are not resolved and appear as that on the
final listing. This option causes then to be resolved and substituted
by the target file system object. Dangling links are ignored, though
they generate a call to the \f(CW\*(C`on_error\*(C'\fR callback when stat fails on
them.
.Sp
Following symbolic links can introduce loops on the search. Infinite
loops are detected and broken but files can still appear repeated on
the final listing under different names unless the option \f(CW\*(C`realpath\*(C'\fR
is also active.
.IP "ordered => 1" 4
.IX Item "ordered => 1"
By default, the file system is searched in an implementation dependent
order (actually optimized for low memory consumption). If this option
is included, the file system is searched in a deep-first, sorted by
filename fashion.
.IP "wanted => qr/.../" 4
.IX Item "wanted => qr/.../"
.PD 0
.IP "wanted => sub { ... }" 4
.IX Item "wanted => sub { ... }"
.IP "no_wanted => qr/.../" 4
.IX Item "no_wanted => qr/.../"
.IP "no_wanted => sub { ... }" 4
.IX Item "no_wanted => sub { ... }"
.PD
These options have the same effect as on the \f(CW\*(C`ls\*(C'\fR method, allowing to
filter out unwanted entries (note that filename keys contain \fBfull
paths\fR here).
.Sp
The callbacks can also be used to perform some action instead of
creating the full listing of entries in memory (that could use huge
amounts of \s-1RAM\s0 for big file trees):
.Sp
.Vb 6
\&  $sftp\->find($src_dir,
\&              wanted => sub {
\&                  my $fn = $_[1]\->{filename}
\&                  print "$fn\en" if $fn =~ /\e.p[ml]$/;
\&                  return undef # so it is discarded
\&              });
.Ve
.IP "descend => qr/.../" 4
.IX Item "descend => qr/.../"
.PD 0
.IP "descend => sub { ... }" 4
.IX Item "descend => sub { ... }"
.IP "no_descend => qr/.../" 4
.IX Item "no_descend => qr/.../"
.IP "no_descend => sub { ... }" 4
.IX Item "no_descend => sub { ... }"
.PD
These options, similar to the \f(CW\*(C`wanted\*(C'\fR ones, allow one to prune the
search, discarding full subdirectories. For instance:
.Sp
.Vb 6
\&    use Fcntl \*(Aq:mode\*(Aq;
\&    my @files = $sftp\->find( \*(Aq.\*(Aq,
\&                             no_descend => qr/\e.svn$/,
\&                             wanted => sub {
\&                                 S_ISREG($_[1]\->{a}\->perm)
\&                             } );
.Ve
.Sp
\&\f(CW\*(C`descend\*(C'\fR and \f(CW\*(C`wanted\*(C'\fR rules are unrelated. A directory discarded by
a \f(CW\*(C`wanted\*(C'\fR rule will still be recursively searched unless it is also
discarded on a \f(CW\*(C`descend\*(C'\fR rule and vice versa.
.IP "atomic_readdir => 1" 4
.IX Item "atomic_readdir => 1"
see \f(CW\*(C`ls\*(C'\fR method documentation.
.IP "names_only => 1" 4
.IX Item "names_only => 1"
makes the method return a list with the names of the files only (see \f(CW\*(C`ls\*(C'\fR
method documentation).
.Sp
equivalent:
.Sp
.Vb 1
\&  my $ls1 = $sftp\->ls(\*(Aq.\*(Aq, names_only => 1);
.Ve
.RE
.RS 4
.RE
.ie n .IP "$sftp\->glob($pattern, %opts)" 4
.el .IP "\f(CW$sftp\fR\->glob($pattern, \f(CW%opts\fR)" 4
.IX Item "$sftp->glob($pattern, %opts)"
performs a remote glob and returns the list of matching entries
in the same format as the \*(L"find\*(R" method.
.IX Xref "glob"
.Sp
This method tries to recover and continue under error conditions.
.Sp
The given pattern can be a \s-1UNIX\s0 style pattern (see \fBglob\fR\|(7)) or a
Regexp object (i.e \f(CW\*(C`qr/foo/\*(C'\fR). In the later case, only files on the
current working directory will be matched against the Regexp.
.Sp
Accepted options:
.RS 4
.IP "ignore_case => 1" 4
.IX Item "ignore_case => 1"
by default the matching over the file system is carried out in a case
sensitive fashion, this flag changes it to be case insensitive.
.Sp
This flag is ignored when a Regexp object is used as the pattern.
.IP "strict_leading_dot => 0" 4
.IX Item "strict_leading_dot => 0"
by default, a dot character at the beginning of a file or directory
name is not matched by wildcards (\f(CW\*(C`*\*(C'\fR or \f(CW\*(C`?\*(C'\fR). Setting this flags to
a false value changes this behaviour.
.Sp
This flag is ignored when a Regexp object is used as the pattern.
.IP "follow_links => 1" 4
.IX Item "follow_links => 1"
.PD 0
.IP "ordered => 1" 4
.IX Item "ordered => 1"
.IP "names_only => 1" 4
.IX Item "names_only => 1"
.IP "realpath => 1" 4
.IX Item "realpath => 1"
.IP "on_error => sub { ... }" 4
.IX Item "on_error => sub { ... }"
.IP "wanted => ..." 4
.IX Item "wanted => ..."
.IP "no_wanted => ..." 4
.IX Item "no_wanted => ..."
.PD
these options perform as on the \f(CW\*(C`ls\*(C'\fR method.
.RE
.RS 4
.Sp
Some usage samples:
.Sp
.Vb 1
\&  my $files = $sftp\->glob("*/lib");
\&
\&  my $files = $sftp\->glob("/var/log/dmesg.*.gz");
\&
\&  $sftp\->set_cwd("/var/log");
\&  my $files = $sftp\->glob(qr/^dmesg\e.[\ed+]\e.gz$/);
\&
\&  my $files = $sftp\->glob("*/*.pdf", strict_leading_dot => 0);
.Ve
.RE
.ie n .IP "$sftp\->rget($remote, $local, %opts)" 4
.el .IP "\f(CW$sftp\fR\->rget($remote, \f(CW$local\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->rget($remote, $local, %opts)"
Recursively copies the contents of remote directory \f(CW$remote\fR to
local directory \f(CW$local\fR. Returns the total number of elements
(files, directories and symbolic links) successfully copied.
.Sp
This method tries to recover and continue when some error happens.
.Sp
The options accepted are:
.RS 4
.ie n .IP "umask => $umask" 4
.el .IP "umask => \f(CW$umask\fR" 4
.IX Item "umask => $umask"
use umask \f(CW$umask\fR to set permissions on the files and directories
created.
.ie n .IP "copy_perm => $bool;" 4
.el .IP "copy_perm => \f(CW$bool\fR;" 4
.IX Item "copy_perm => $bool;"
if set to a true value, file and directory permissions are copied to
the remote server (after applying the umask). On by default.
.ie n .IP "copy_time => $bool;" 4
.el .IP "copy_time => \f(CW$bool\fR;" 4
.IX Item "copy_time => $bool;"
if set to a true value, file atime and mtime are copied from the
remote server. By default it is on.
.ie n .IP "overwrite => $bool" 4
.el .IP "overwrite => \f(CW$bool\fR" 4
.IX Item "overwrite => $bool"
if set to a true value, when a local file with the same name
already exists it is overwritten. On by default.
.ie n .IP "numbered => $bool" 4
.el .IP "numbered => \f(CW$bool\fR" 4
.IX Item "numbered => $bool"
when required, adds a sequence number to local file names in order to
avoid overwriting pre-existent remote files. Off by default.
.ie n .IP "newer_only => $bool" 4
.el .IP "newer_only => \f(CW$bool\fR" 4
.IX Item "newer_only => $bool"
if set to a true value, when a local file with the same name
already exists it is overwritten only if the remote file is newer.
.ie n .IP "ignore_links => $bool" 4
.el .IP "ignore_links => \f(CW$bool\fR" 4
.IX Item "ignore_links => $bool"
if set to a true value, symbolic links are not copied.
.IP "on_error => sub { ... }" 4
.IX Item "on_error => sub { ... }"
the passed sub is called when some error happens. It is called with two
arguments, the \f(CW$sftp\fR object and the entry causing the error.
.IP "wanted => ..." 4
.IX Item "wanted => ..."
.PD 0
.IP "no_wanted => ..." 4
.IX Item "no_wanted => ..."
.PD
This option allows one to select which files and directories have to
be copied. See also \f(CW\*(C`ls\*(C'\fR method docs.
.Sp
If a directory is discarded all of its contents are also discarded (as
it is not possible to copy child files without creating the directory
first!).
.IP "atomic => 1" 4
.IX Item "atomic => 1"
.PD 0
.ie n .IP "block_size => $block_size" 4
.el .IP "block_size => \f(CW$block_size\fR" 4
.IX Item "block_size => $block_size"
.ie n .IP "queue_size => $queue_size" 4
.el .IP "queue_size => \f(CW$queue_size\fR" 4
.IX Item "queue_size => $queue_size"
.ie n .IP "conversion => $conversion" 4
.el .IP "conversion => \f(CW$conversion\fR" 4
.IX Item "conversion => $conversion"
.ie n .IP "resume => $resume" 4
.el .IP "resume => \f(CW$resume\fR" 4
.IX Item "resume => $resume"
.ie n .IP "best_effort => $best_effort" 4
.el .IP "best_effort => \f(CW$best_effort\fR" 4
.IX Item "best_effort => $best_effort"
.PD
See \f(CW\*(C`get\*(C'\fR method docs.
.RE
.RS 4
.RE
.ie n .IP "$sftp\->rput($local, $remote, %opts)" 4
.el .IP "\f(CW$sftp\fR\->rput($local, \f(CW$remote\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->rput($local, $remote, %opts)"
Recursively copies the contents of local directory \f(CW$local\fR to
remote directory \f(CW$remote\fR.
.Sp
This method tries to recover and continue when some error happens.
.Sp
Accepted options are:
.RS 4
.ie n .IP "umask => $umask" 4
.el .IP "umask => \f(CW$umask\fR" 4
.IX Item "umask => $umask"
use umask \f(CW$umask\fR to set permissions on the files and directories
created.
.ie n .IP "copy_perm => $bool;" 4
.el .IP "copy_perm => \f(CW$bool\fR;" 4
.IX Item "copy_perm => $bool;"
if set to a true value, file and directory permissions are copied
to the remote server (after applying the umask). On by default.
.ie n .IP "copy_time => $bool;" 4
.el .IP "copy_time => \f(CW$bool\fR;" 4
.IX Item "copy_time => $bool;"
if set to a true value, file atime and mtime are copied to the
remote server. On by default.
.ie n .IP "perm => $perm" 4
.el .IP "perm => \f(CW$perm\fR" 4
.IX Item "perm => $perm"
Sets the permission of the copied files to \f(CW$perm\fR. For directories the
value \f(CW\*(C`$perm|0300\*(C'\fR is used.
.Sp
Note that when this option is used, umask and local permissions are
ignored.
.ie n .IP "overwrite => $bool" 4
.el .IP "overwrite => \f(CW$bool\fR" 4
.IX Item "overwrite => $bool"
if set to a true value, when a remote file with the same name already
exists it is overwritten. On by default.
.ie n .IP "newer_only => $bool" 4
.el .IP "newer_only => \f(CW$bool\fR" 4
.IX Item "newer_only => $bool"
if set to a true value, when a remote file with the same name already
exists it is overwritten only if the local file is newer.
.ie n .IP "ignore_links => $bool" 4
.el .IP "ignore_links => \f(CW$bool\fR" 4
.IX Item "ignore_links => $bool"
if set to a true value, symbolic links are not copied
.IP "on_error => sub { ... }" 4
.IX Item "on_error => sub { ... }"
the passed sub is called when some error happens. It is called with two
arguments, the \f(CW$sftp\fR object and the entry causing the error.
.IP "wanted => ..." 4
.IX Item "wanted => ..."
.PD 0
.IP "no_wanted => ..." 4
.IX Item "no_wanted => ..."
.PD
This option allows one to select which files and directories have to
be copied. See also \f(CW\*(C`ls\*(C'\fR method docs.
.Sp
If a directory is discarded all of its contents are also discarded (as
it is not possible to copy child files without creating the directory
first!).
.IP "atomic => 1" 4
.IX Item "atomic => 1"
.PD 0
.ie n .IP "block_size => $block_size" 4
.el .IP "block_size => \f(CW$block_size\fR" 4
.IX Item "block_size => $block_size"
.ie n .IP "queue_size => $queue_size" 4
.el .IP "queue_size => \f(CW$queue_size\fR" 4
.IX Item "queue_size => $queue_size"
.ie n .IP "conversion => $conversion" 4
.el .IP "conversion => \f(CW$conversion\fR" 4
.IX Item "conversion => $conversion"
.ie n .IP "resume => $resume" 4
.el .IP "resume => \f(CW$resume\fR" 4
.IX Item "resume => $resume"
.ie n .IP "best_effort => $best_effort" 4
.el .IP "best_effort => \f(CW$best_effort\fR" 4
.IX Item "best_effort => $best_effort"
.ie n .IP "late_set_perm => $bool" 4
.el .IP "late_set_perm => \f(CW$bool\fR" 4
.IX Item "late_set_perm => $bool"
.PD
see \f(CW\*(C`put\*(C'\fR method docs.
.RE
.RS 4
.RE
.ie n .IP "$sftp\->rremove($dir, %opts)" 4
.el .IP "\f(CW$sftp\fR\->rremove($dir, \f(CW%opts\fR)" 4
.IX Item "$sftp->rremove($dir, %opts)"
.PD 0
.ie n .IP "$sftp\->rremove(\e@dirs, %opts)" 4
.el .IP "\f(CW$sftp\fR\->rremove(\e@dirs, \f(CW%opts\fR)" 4
.IX Item "$sftp->rremove(@dirs, %opts)"
.PD
recursively remove directory \f(CW$dir\fR (or directories \f(CW@dirs\fR) and its
contents. Returns the number of elements successfully removed.
.Sp
This method tries to recover and continue when some error happens.
.Sp
The options accepted are:
.RS 4
.IP "on_error => sub { ... }" 4
.IX Item "on_error => sub { ... }"
This callback is called when some error is occurs. The arguments
passed are the \f(CW$sftp\fR object and the current entry (a hash
containing the file object details, see \f(CW\*(C`ls\*(C'\fR docs for more
information).
.IP "wanted => ..." 4
.IX Item "wanted => ..."
.PD 0
.IP "no_wanted => ..." 4
.IX Item "no_wanted => ..."
.PD
Allows one to select which file system objects have to be deleted.
.RE
.RS 4
.RE
.ie n .IP "$sftp\->mget($remote, $localdir, %opts)" 4
.el .IP "\f(CW$sftp\fR\->mget($remote, \f(CW$localdir\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->mget($remote, $localdir, %opts)"
.PD 0
.ie n .IP "$sftp\->mget(\e@remote, $localdir, %opts)" 4
.el .IP "\f(CW$sftp\fR\->mget(\e@remote, \f(CW$localdir\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->mget(@remote, $localdir, %opts)"
.PD
expands the wildcards on \f(CW$remote\fR or \f(CW@remote\fR and retrieves
all the matching files.
.IX Xref "mget"
.Sp
For instance:
.Sp
.Vb 1
\&  $sftp\->mget([\*(Aq/etc/hostname.*\*(Aq, \*(Aq/etc/init.d/*\*(Aq], \*(Aq/tmp\*(Aq);
.Ve
.Sp
The method accepts all the options valid for \*(L"glob\*(R" and for \*(L"get\*(R"
(except those that do not make sense :\-)
.Sp
\&\f(CW$localdir\fR is optional and defaults to the process current working
directory (\f(CW\*(C`cwd\*(C'\fR).
.Sp
Files are saved with the same name they have in the remote server
excluding the directory parts.
.Sp
Note that name collisions are not detected. For instance:
.Sp
.Vb 1
\& $sftp\->mget(["foo/file.txt", "bar/file.txt"], "/tmp")
.Ve
.Sp
will transfer the first file to \*(L"/tmp/file.txt\*(R" and later overwrite it
with the second one. The \f(CW\*(C`numbered\*(C'\fR option can be used to avoid this
issue.
.ie n .IP "$sftp\->mput($local, $remotedir, %opts)" 4
.el .IP "\f(CW$sftp\fR\->mput($local, \f(CW$remotedir\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->mput($local, $remotedir, %opts)"
.PD 0
.ie n .IP "$sftp\->mput(\e@local, $remotedir, %opts)" 4
.el .IP "\f(CW$sftp\fR\->mput(\e@local, \f(CW$remotedir\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->mput(@local, $remotedir, %opts)"
.PD
similar to \*(L"mget\*(R" but works in the opposite direction transferring
files from the local side to the remote one.
.ie n .IP "$sftp\->join(@paths)" 4
.el .IP "\f(CW$sftp\fR\->join(@paths)" 4
.IX Item "$sftp->join(@paths)"
returns the given path fragments joined in one path (currently the
remote file system is expected to be \s-1UNIX\s0 like).
.ie n .IP "$sftp\->open($path, $flags [, $attrs ])" 4
.el .IP "\f(CW$sftp\fR\->open($path, \f(CW$flags\fR [, \f(CW$attrs\fR ])" 4
.IX Item "$sftp->open($path, $flags [, $attrs ])"
Sends the \f(CW\*(C`SSH_FXP_OPEN\*(C'\fR command to open a remote file \f(CW$path\fR,
and returns an open handle on success. On failure returns
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
The returned value is a tied handle (see Tie::Handle) that can be
used to access the remote file both with the methods available from
this module and with perl built-ins. For instance:
.Sp
.Vb 4
\&  # reading from the remote file
\&  my $fh1 = $sftp\->open("/etc/passwd")
\&    or die $sftp\->error;
\&  while (<$fh1>) { ... }
\&
\&  # writing to the remote file
\&  use Net::SFTP::Foreign::Constants qw(:flags);
\&  my $fh2 = $sftp\->open("/foo/bar", SSH2_FXF_WRITE|SSH2_FXF_CREAT)
\&    or die $sftp\->error;
\&  print $fh2 "printing on the remote file\en";
\&  $sftp\->write($fh2, "writing more");
.Ve
.Sp
The \f(CW$flags\fR bitmap determines how to open the remote file as defined
in the \s-1SFTP\s0 protocol draft (the following constants can be imported
from Net::SFTP::Foreign::Constants):
.RS 4
.IP "\s-1SSH2_FXF_READ\s0" 4
.IX Item "SSH2_FXF_READ"
Open the file for reading. It is the default mode.
.IP "\s-1SSH2_FXF_WRITE\s0" 4
.IX Item "SSH2_FXF_WRITE"
Open the file for writing.  If both this and \f(CW\*(C`SSH2_FXF_READ\*(C'\fR are
specified, the file is opened for both reading and writing.
.IP "\s-1SSH2_FXF_APPEND\s0" 4
.IX Item "SSH2_FXF_APPEND"
Force all writes to append data at the end of the file.
.Sp
As OpenSSH \s-1SFTP\s0 server implementation ignores this flag, the module
emulates it (I will appreciate receiving feedback about the
inter-operation of this module with other server implementations when
this flag is used).
.IP "\s-1SSH2_FXF_CREAT\s0" 4
.IX Item "SSH2_FXF_CREAT"
If this flag is specified, then a new file will be created if one does
not already exist.
.IP "\s-1SSH2_FXF_TRUNC\s0" 4
.IX Item "SSH2_FXF_TRUNC"
Forces an existing file with the same name to be truncated to zero
length when creating a file. \f(CW\*(C`SSH2_FXF_CREAT\*(C'\fR must also be specified
if this flag is used.
.IP "\s-1SSH2_FXF_EXCL\s0" 4
.IX Item "SSH2_FXF_EXCL"
Causes the request to fail if the named file already exists.
\&\f(CW\*(C`SSH2_FXF_CREAT\*(C'\fR must also be specified if this flag is used.
.RE
.RS 4
.Sp
When creating a new remote file, \f(CW$attrs\fR allows one to set its
initial attributes. \f(CW$attrs\fR has to be an object of class
Net::SFTP::Foreign::Attributes.
.RE
.ie n .IP "$sftp\->close($handle)" 4
.el .IP "\f(CW$sftp\fR\->close($handle)" 4
.IX Item "$sftp->close($handle)"
Closes the remote file handle \f(CW$handle\fR.
.Sp
Files are automatically closed on the handle \f(CW\*(C`DESTROY\*(C'\fR method when
not done explicitly.
.Sp
Returns true on success and undef on failure.
.ie n .IP "$sftp\->read($handle, $length)" 4
.el .IP "\f(CW$sftp\fR\->read($handle, \f(CW$length\fR)" 4
.IX Item "$sftp->read($handle, $length)"
reads \f(CW$length\fR bytes from an open file handle \f(CW$handle\fR. On success
returns the data read from the remote file and undef on failure
(including \s-1EOF\s0).
.ie n .IP "$sftp\->write($handle, $data)" 4
.el .IP "\f(CW$sftp\fR\->write($handle, \f(CW$data\fR)" 4
.IX Item "$sftp->write($handle, $data)"
writes \f(CW$data\fR to the remote file \f(CW$handle\fR. Returns the number of
bytes written or undef on failure.
.ie n .IP "$sftp\->readline($handle)" 4
.el .IP "\f(CW$sftp\fR\->readline($handle)" 4
.IX Item "$sftp->readline($handle)"
.PD 0
.ie n .IP "$sftp\->readline($handle, $sep)" 4
.el .IP "\f(CW$sftp\fR\->readline($handle, \f(CW$sep\fR)" 4
.IX Item "$sftp->readline($handle, $sep)"
.PD
in scalar context reads and returns the next line from the remote
file. In list context, it returns all the lines from the current
position to the end of the file.
.Sp
By default \*(L"\en\*(R" is used as the separator between lines, but a
different one can be used passing it as the second method argument. If
the empty string is used, it returns all the data from the current
position to the end of the file as one line.
.ie n .IP "$sftp\->getc($handle)" 4
.el .IP "\f(CW$sftp\fR\->getc($handle)" 4
.IX Item "$sftp->getc($handle)"
returns the next character from the file.
.ie n .IP "$sftp\->seek($handle, $pos, $whence)" 4
.el .IP "\f(CW$sftp\fR\->seek($handle, \f(CW$pos\fR, \f(CW$whence\fR)" 4
.IX Item "$sftp->seek($handle, $pos, $whence)"
sets the current position for the remote file handle \f(CW$handle\fR. If
\&\f(CW$whence\fR is 0, the position is set relative to the beginning of the
file; if \f(CW$whence\fR is 1, position is relative to current position and
if $<$whence> is 2, position is relative to the end of the file.
.Sp
returns a trues value on success, undef on failure.
.ie n .IP "$sftp\->tell($fh)" 4
.el .IP "\f(CW$sftp\fR\->tell($fh)" 4
.IX Item "$sftp->tell($fh)"
returns the current position for the remote file handle \f(CW$handle\fR.
.ie n .IP "$sftp\->eof($fh)" 4
.el .IP "\f(CW$sftp\fR\->eof($fh)" 4
.IX Item "$sftp->eof($fh)"
reports whether the remote file handler points at the end of the file.
.ie n .IP "$sftp\->flush($fh)" 4
.el .IP "\f(CW$sftp\fR\->flush($fh)" 4
.IX Item "$sftp->flush($fh)"
writes to the remote file any pending data and discards the
read cache.
.IX Xref "flush"
.Sp
Note that this operation just sends data cached locally to the remote
server. You may like to call \f(CW\*(C`fsync\*(C'\fR (when supported) afterwards to
ensure that data is actually flushed to disc.
.ie n .IP "$sftp\->fsync($fh)" 4
.el .IP "\f(CW$sftp\fR\->fsync($fh)" 4
.IX Item "$sftp->fsync($fh)"
On servers supporting the \f(CW\*(C`fsync@openssh.com\*(C'\fR extension, this method
calls \fBfysnc\fR\|(2) on the remote side, which usually flushes buffered
changes to disk.
.ie n .IP "$sftp\->sftpread($handle, $offset, $length)" 4
.el .IP "\f(CW$sftp\fR\->sftpread($handle, \f(CW$offset\fR, \f(CW$length\fR)" 4
.IX Item "$sftp->sftpread($handle, $offset, $length)"
low level method that sends a \s-1SSH2_FXP_READ\s0 request to read from an
open file handle \f(CW$handle\fR, \f(CW$length\fR bytes starting at \f(CW$offset\fR.
.Sp
Returns the data read on success and undef on failure.
.Sp
Some servers (for instance OpenSSH \s-1SFTP\s0 server) limit the size of the
read requests and so the length of data returned can be smaller than
requested.
.ie n .IP "$sftp\->sftpwrite($handle, $offset, $data)" 4
.el .IP "\f(CW$sftp\fR\->sftpwrite($handle, \f(CW$offset\fR, \f(CW$data\fR)" 4
.IX Item "$sftp->sftpwrite($handle, $offset, $data)"
low level method that sends a \f(CW\*(C`SSH_FXP_WRITE\*(C'\fR request to write to an
open file handle \f(CW$handle\fR, starting at \f(CW$offset\fR, and where the
data to be written is in \f(CW$data\fR.
.Sp
Returns true on success and undef on failure.
.ie n .IP "$sftp\->opendir($path)" 4
.el .IP "\f(CW$sftp\fR\->opendir($path)" 4
.IX Item "$sftp->opendir($path)"
Sends a \f(CW\*(C`SSH_FXP_OPENDIR\*(C'\fR command to open the remote directory
\&\f(CW$path\fR, and returns an open handle on success (unfortunately,
current versions of perl does not support directory operations via
tied handles, so it is not possible to use the returned handle as a
native one).
.Sp
On failure returns \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$sftp\->closedir($handle)" 4
.el .IP "\f(CW$sftp\fR\->closedir($handle)" 4
.IX Item "$sftp->closedir($handle)"
closes the remote directory handle \f(CW$handle\fR.
.Sp
Directory handles are closed from their \f(CW\*(C`DESTROY\*(C'\fR method when not
done explicitly.
.Sp
Return true on success, undef on failure.
.ie n .IP "$sftp\->readdir($handle)" 4
.el .IP "\f(CW$sftp\fR\->readdir($handle)" 4
.IX Item "$sftp->readdir($handle)"
returns the next entry from the remote directory \f(CW$handle\fR (or all
the remaining entries when called in list context).
.Sp
The return values are a hash with three keys: \f(CW\*(C`filename\*(C'\fR, \f(CW\*(C`longname\*(C'\fR and
\&\f(CW\*(C`a\*(C'\fR. The \f(CW\*(C`a\*(C'\fR value contains a Net::SFTP::Foreign::Attributes
object describing the entry.
.Sp
Returns undef on error or when no more entries exist on the directory.
.ie n .IP "$sftp\->stat($path_or_fh)" 4
.el .IP "\f(CW$sftp\fR\->stat($path_or_fh)" 4
.IX Item "$sftp->stat($path_or_fh)"
performs a \f(CW\*(C`stat\*(C'\fR on the remote file and returns a
Net::SFTP::Foreign::Attributes object with the result values. Both
paths and open remote file handles can be passed to this method.
.Sp
Returns undef on failure.
.ie n .IP "$sftp\->fstat($handle)" 4
.el .IP "\f(CW$sftp\fR\->fstat($handle)" 4
.IX Item "$sftp->fstat($handle)"
this method is deprecated.
.ie n .IP "$sftp\->lstat($path)" 4
.el .IP "\f(CW$sftp\fR\->lstat($path)" 4
.IX Item "$sftp->lstat($path)"
this method is similar to \f(CW\*(C`stat\*(C'\fR method but stats a symbolic link
instead of the file the symbolic links points to.
.ie n .IP "$sftp\->setstat($path_or_fh, $attrs)" 4
.el .IP "\f(CW$sftp\fR\->setstat($path_or_fh, \f(CW$attrs\fR)" 4
.IX Item "$sftp->setstat($path_or_fh, $attrs)"
sets file attributes on the remote file. Accepts both paths and open
remote file handles.
.Sp
Returns true on success and undef on failure.
.ie n .IP "$sftp\->fsetstat($handle, $attrs)" 4
.el .IP "\f(CW$sftp\fR\->fsetstat($handle, \f(CW$attrs\fR)" 4
.IX Item "$sftp->fsetstat($handle, $attrs)"
this method is deprecated.
.ie n .IP "$sftp\->truncate($path_or_fh, $size)" 4
.el .IP "\f(CW$sftp\fR\->truncate($path_or_fh, \f(CW$size\fR)" 4
.IX Item "$sftp->truncate($path_or_fh, $size)"
.PD 0
.ie n .IP "$sftp\->chown($path_or_fh, $uid, $gid)" 4
.el .IP "\f(CW$sftp\fR\->chown($path_or_fh, \f(CW$uid\fR, \f(CW$gid\fR)" 4
.IX Item "$sftp->chown($path_or_fh, $uid, $gid)"
.ie n .IP "$sftp\->chmod($path_or_fh, $perm)" 4
.el .IP "\f(CW$sftp\fR\->chmod($path_or_fh, \f(CW$perm\fR)" 4
.IX Item "$sftp->chmod($path_or_fh, $perm)"
.ie n .IP "$sftp\->utime($path_or_fh, $atime, $mtime)" 4
.el .IP "\f(CW$sftp\fR\->utime($path_or_fh, \f(CW$atime\fR, \f(CW$mtime\fR)" 4
.IX Item "$sftp->utime($path_or_fh, $atime, $mtime)"
.PD
Shortcuts around \f(CW\*(C`setstat\*(C'\fR method.
.ie n .IP "$sftp\->remove($path)" 4
.el .IP "\f(CW$sftp\fR\->remove($path)" 4
.IX Item "$sftp->remove($path)"
Sends a \f(CW\*(C`SSH_FXP_REMOVE\*(C'\fR command to remove the remote file
\&\f(CW$path\fR. Returns a true value on success and undef on failure.
.ie n .IP "$sftp\->mkdir($path, $attrs)" 4
.el .IP "\f(CW$sftp\fR\->mkdir($path, \f(CW$attrs\fR)" 4
.IX Item "$sftp->mkdir($path, $attrs)"
Sends a \f(CW\*(C`SSH_FXP_MKDIR\*(C'\fR command to create a remote directory \f(CW$path\fR
whose attributes are initialized to \f(CW$attrs\fR (a
Net::SFTP::Foreign::Attributes object).
.Sp
Returns a true value on success and undef on failure.
.Sp
The \f(CW$attrs\fR argument is optional.
.ie n .IP "$sftp\->mkpath($path, $attrs, $parent)" 4
.el .IP "\f(CW$sftp\fR\->mkpath($path, \f(CW$attrs\fR, \f(CW$parent\fR)" 4
.IX Item "$sftp->mkpath($path, $attrs, $parent)"
This method is similar to \f(CW\*(C`mkdir\*(C'\fR but also creates any non-existent
parent directories recursively.
.Sp
When the optional argument \f(CW$parent\fR has a true value, just the
parent directory of the given path (and its ancestors as required) is
created.
.Sp
For instance:
.Sp
.Vb 3
\&  $sftp\->mkpath("/tmp/work", undef, 1);
\&  my $fh = $sftp\->open("/tmp/work/data.txt",
\&                       SSH2_FXF_WRITE|SSH2_FXF_CREAT);
.Ve
.ie n .IP "$sftp\->rmdir($path)" 4
.el .IP "\f(CW$sftp\fR\->rmdir($path)" 4
.IX Item "$sftp->rmdir($path)"
Sends a \f(CW\*(C`SSH_FXP_RMDIR\*(C'\fR command to remove a remote directory
\&\f(CW$path\fR. Returns a true value on success and undef on failure.
.ie n .IP "$sftp\->realpath($path)" 4
.el .IP "\f(CW$sftp\fR\->realpath($path)" 4
.IX Item "$sftp->realpath($path)"
Sends a \f(CW\*(C`SSH_FXP_REALPATH\*(C'\fR command to canonicalise \f(CW$path\fR
to an absolute path. This can be useful for turning paths
containing \f(CW\*(Aq..\*(Aq\fR into absolute paths.
.Sp
Returns the absolute path on success, \f(CW\*(C`undef\*(C'\fR on failure.
.Sp
When the given path points to an nonexistent location, what one
gets back is server dependent. Some servers return a failure message
and others a canonical version of the path.
.ie n .IP "$sftp\->rename($old, $new, %opts)" 4
.el .IP "\f(CW$sftp\fR\->rename($old, \f(CW$new\fR, \f(CW%opts\fR)" 4
.IX Item "$sftp->rename($old, $new, %opts)"
Sends a \f(CW\*(C`SSH_FXP_RENAME\*(C'\fR command to rename \f(CW$old\fR to \f(CW$new\fR.
Returns a true value on success and undef on failure.
.Sp
Accepted options are:
.RS 4
.ie n .IP "overwrite => $bool" 4
.el .IP "overwrite => \f(CW$bool\fR" 4
.IX Item "overwrite => $bool"
By default, the rename operation fails when a file \f(CW$new\fR already
exists. When this options is set, any previous existent file is
deleted first (the \f(CW\*(C`atomic_rename\*(C'\fR operation will be used if
available).
.Sp
Note than under some conditions the target file could be deleted and
afterwards the rename operation fail.
.RE
.RS 4
.RE
.ie n .IP "$sftp\->atomic_rename($old, $new)" 4
.el .IP "\f(CW$sftp\fR\->atomic_rename($old, \f(CW$new\fR)" 4
.IX Item "$sftp->atomic_rename($old, $new)"
Renames a file using the \f(CW\*(C`posix\-rename@openssh.com\*(C'\fR extension when
available.
.Sp
Unlike the \f(CW\*(C`rename\*(C'\fR method, it overwrites any previous \f(CW$new\fR file.
.ie n .IP "$sftp\->readlink($path)" 4
.el .IP "\f(CW$sftp\fR\->readlink($path)" 4
.IX Item "$sftp->readlink($path)"
Sends a \f(CW\*(C`SSH_FXP_READLINK\*(C'\fR command to read the path where the
symbolic link is pointing.
.Sp
Returns the target path on success and undef on failure.
.ie n .IP "$sftp\->symlink($sl, $target)" 4
.el .IP "\f(CW$sftp\fR\->symlink($sl, \f(CW$target\fR)" 4
.IX Item "$sftp->symlink($sl, $target)"
Sends a \f(CW\*(C`SSH_FXP_SYMLINK\*(C'\fR command to create a new symbolic link
\&\f(CW$sl\fR pointing to \f(CW$target\fR.
.Sp
\&\f(CW$target\fR is stored as-is, without any path expansion taken place on
it. Use \f(CW\*(C`realpath\*(C'\fR to normalize it:
.Sp
.Vb 1
\&  $sftp\->symlink("foo.lnk" => $sftp\->realpath("../bar"))
.Ve
.ie n .IP "$sftp\->hardlink($hl, $target)" 4
.el .IP "\f(CW$sftp\fR\->hardlink($hl, \f(CW$target\fR)" 4
.IX Item "$sftp->hardlink($hl, $target)"
Creates a hardlink on the server.
.Sp
This command requires support for the 'hardlink@openssh.com' extension
on the server (available in OpenSSH from version 5.7).
.ie n .IP "$sftp\->statvfs($path)" 4
.el .IP "\f(CW$sftp\fR\->statvfs($path)" 4
.IX Item "$sftp->statvfs($path)"
.PD 0
.ie n .IP "$sftp\->fstatvfs($fh)" 4
.el .IP "\f(CW$sftp\fR\->fstatvfs($fh)" 4
.IX Item "$sftp->fstatvfs($fh)"
.PD
On servers supporting \f(CW\*(C`statvfs@openssh.com\*(C'\fR and
\&\f(CW\*(C`fstatvfs@openssh.com\*(C'\fR extensions respectively, these methods return
a hash reference with information about the file system where the file
named \f(CW$path\fR or the open file \f(CW$fh\fR resides.
.Sp
The hash entries are:
.Sp
.Vb 11
\&  bsize   => file system block size
\&  frsize  => fundamental fs block size
\&  blocks  => number of blocks (unit f_frsize)
\&  bfree   => free blocks in file system
\&  bavail  => free blocks for non\-root
\&  files   => total file inodes
\&  ffree   => free file inodes
\&  favail  => free file inodes for to non\-root
\&  fsid    => file system id
\&  flag    => bit mask of f_flag values
\&  namemax => maximum filename length
.Ve
.Sp
The values of the f_flag bit mask are as follows:
.Sp
.Vb 2
\&  SSH2_FXE_STATVFS_ST_RDONLY => read\-only
\&  SSH2_FXE_STATVFS_ST_NOSUID => no setuid
.Ve
.ie n .IP "$sftp\->test_d($path)" 4
.el .IP "\f(CW$sftp\fR\->test_d($path)" 4
.IX Item "$sftp->test_d($path)"
Checks whether the given path corresponds to a directory.
.ie n .IP "$sftp\->test_e($path)" 4
.el .IP "\f(CW$sftp\fR\->test_e($path)" 4
.IX Item "$sftp->test_e($path)"
Checks whether a file system object (file, directory, etc.) exists at
the given path.
.ie n .IP "$sftp\->disconnect" 4
.el .IP "\f(CW$sftp\fR\->disconnect" 4
.IX Item "$sftp->disconnect"
Closes the \s-1SSH\s0 connection to the remote host. From this point the
object becomes mostly useless.
.Sp
Usually, this method should not be called explicitly, but implicitly
from the \s-1DESTROY\s0 method when the object goes out of scope.
.Sp
See also the documentation for the \f(CW\*(C`autodiscconnect\*(C'\fR constructor
argument.
.ie n .IP "$sftp\->autodisconnect($ad)" 4
.el .IP "\f(CW$sftp\fR\->autodisconnect($ad)" 4
.IX Item "$sftp->autodisconnect($ad)"
Sets the \f(CW\*(C`autodisconnect\*(C'\fR behaviour.
.Sp
See also the documentation for the \f(CW\*(C`autodiscconnect\*(C'\fR constructor
argument. The values accepted here are the same as there.
.SS "On the fly data conversion"
.IX Subsection "On the fly data conversion"
Some of the methods on this module allow one to perform on the fly
data conversion via the \f(CW\*(C`conversion\*(C'\fR option that accepts the
following values:
.IP "conversion => 'dos2unix'" 4
.IX Item "conversion => 'dos2unix'"
Converts \s-1CR+LF\s0 line endings (as commonly used under MS-DOS) to \s-1LF\s0
(\s-1UNIX\s0).
.IP "conversion => 'unix2dos'" 4
.IX Item "conversion => 'unix2dos'"
Converts \s-1LF\s0 line endings (\s-1UNIX\s0) to \s-1CR+LF\s0 (\s-1DOS\s0).
.ie n .IP "conversion => sub { \s-1CONVERT\s0 $_[0] }" 4
.el .IP "conversion => sub { \s-1CONVERT\s0 \f(CW$_\fR[0] }" 4
.IX Item "conversion => sub { CONVERT $_[0] }"
When a callback is given, it is invoked repeatedly as chunks of data
become available. It has to change \f(CW$_[0]\fR in place in order to
perform the conversion.
.Sp
Also, the subroutine is called one last time with and empty data
string to indicate that the transfer has finished, so that
intermediate buffers can be flushed.
.Sp
Note that when writing conversion subroutines, special care has to be
taken to handle sequences crossing chunk borders.
.PP
The data conversion is always performed before any other callback
subroutine is called.
.PP
See the Wikipedia entry on line endings
<http://en.wikipedia.org/wiki/Newline> or the article Understanding
Newlines by Xavier Noria
(<http://www.onlamp.com/pub/a/onlamp/2006/08/17/understanding\-newlines.html>)
for details about the different conventions.
.SH "FAQ"
.IX Header "FAQ"
.IP "Closing the connection:" 4
.IX Item "Closing the connection:"
\&\fBQ\fR: How do I close the connection to the remote server?
.Sp
\&\fBA\fR: let the \f(CW$sftp\fR object go out of scope or just undefine it:
.Sp
.Vb 1
\&  undef $sftp;
.Ve
.IP "Using Net::SFTP::Foreign from a cron script:" 4
.IX Item "Using Net::SFTP::Foreign from a cron script:"
\&\fBQ\fR: I wrote a script for performing sftp file transfers that works
beautifully from the command line. However when I try to run the same
script from cron it fails with a broken pipe error:
.Sp
.Vb 2
\&  open2: exec of ssh \-l user some.location.com \-s sftp
\&    failed at Net/SFTP/Foreign.pm line 67
.Ve
.Sp
\&\fBA\fR: \f(CW\*(C`ssh\*(C'\fR is not on your cron \s-1PATH.\s0
.Sp
The remedy is either to add the location of the \f(CW\*(C`ssh\*(C'\fR application to
your cron \s-1PATH\s0 or to use the \f(CW\*(C`ssh_cmd\*(C'\fR option of the \f(CW\*(C`new\*(C'\fR method to
hardcode the location of \f(CW\*(C`ssh\*(C'\fR inside your script, for instance:
.Sp
.Vb 2
\&  my $ssh = Net::SFTP::Foreign\->new($host,
\&                                    ssh_cmd => \*(Aq/usr/local/ssh/bin/ssh\*(Aq);
.Ve
.ie n .IP """more"" constructor option expects an array reference:" 4
.el .IP "\f(CWmore\fR constructor option expects an array reference:" 4
.IX Item "more constructor option expects an array reference:"
\&\fBQ\fR: I'm trying to pass in the private key file using the \-i option,
but it keep saying it couldn't find the key. What I'm doing wrong?
.Sp
\&\fBA\fR: The \f(CW\*(C`more\*(C'\fR argument on the constructor expects a single option
or a reference to an array of options. It will not split an string
containing several options.
.Sp
Arguments to \s-1SSH\s0 options have to be also passed as different entries
on the array:
.Sp
.Vb 2
\&  my $sftp = Net::SFTP::Foreign\->new($host,
\&                                      more => [qw(\-i /home/foo/.ssh/id_dsa)]);
.Ve
.Sp
Note also that latest versions of Net::SFTP::Foreign support the
\&\f(CW\*(C`key_path\*(C'\fR argument:
.Sp
.Vb 2
\&  my $sftp = Net::SFTP::Foreign\->new($host,
\&                                      key_path => \*(Aq/home/foo/.ssh/id_dsa\*(Aq);
.Ve
.IP "Plink and password authentication" 4
.IX Item "Plink and password authentication"
\&\fBQ\fR: Why password authentication is not supported for the plink \s-1SSH\s0
client?
.Sp
\&\fBA\fR: A bug in plink breaks it.
.Sp
Newer versions of Net::SFTP::Foreign pass the password to \f(CW\*(C`plink\*(C'\fR
using its \f(CW\*(C`\-pw\*(C'\fR option. As this feature is not completely secure a
warning is generated.
.Sp
It can be silenced (though, don't do it without understanding why it
is there, please!) as follows:
.Sp
.Vb 5
\&  no warnings \*(AqNet::SFTP::Foreign\*(Aq;
\&  my $sftp = Net::SFTP::Foreign\->new(\*(Aqfoo@bar\*(Aq,
\&                                     ssh_cmd => \*(Aqplink\*(Aq,
\&                                     password => $password);
\&  $sftp\->die_on_error;
.Ve
.IP "Plink" 4
.IX Item "Plink"
\&\fBQ\fR: What is \f(CW\*(C`plink\*(C'\fR?
.Sp
\&\fBA\fR: Plink is a command line tool distributed with the
PuTTY <http://the.earth.li/~sgtatham/putty/> \s-1SSH\s0 client. Very popular
between \s-1MS\s0 Windows users, it is also available for Linux and other
\&\s-1UNIX\s0 now.
.IP "Put method fails" 4
.IX Item "Put method fails"
\&\fBQ\fR: put fails with the following error:
.Sp
.Vb 2
\&  Couldn\*(Aqt setstat remote file: The requested operation cannot be
\&  performed because there is a file transfer in progress.
.Ve
.Sp
\&\fBA\fR: Try passing the \f(CW\*(C`late_set_perm\*(C'\fR option to the put method:
.Sp
.Vb 2
\&  $sftp\->put($local, $remote, late_set_perm => 1)
\&     or die "unable to transfer file: " . $sftp\->error;
.Ve
.Sp
Some servers do not support the \f(CW\*(C`fsetstat\*(C'\fR operation on open file
handles. Setting this flag allows one to delay that operation until
the file has been completely transferred and the remote file handle
closed.
.Sp
Also, send me a bug report containing a dump of your \f(CW$sftp\fR object so I
can add code for your particular server software to activate the
work-around automatically.
.IP "Put method fails even with late_set_perm set" 4
.IX Item "Put method fails even with late_set_perm set"
\&\fBQ\fR: I added \f(CW\*(C`late_set_perm => 1\*(C'\fR to the put call, but we are still
receiving the error \f(CW\*(C`Couldn\*(Aqt setstat remote file (setstat)\*(C'\fR.
.Sp
\&\fBA\fR: Some servers forbid the \s-1SFTP\s0 \f(CW\*(C`setstat\*(C'\fR operation used by the
\&\f(CW\*(C`put\*(C'\fR method for replicating the file permissions and time-stamps on
the remote side.
.Sp
As a work around you can just disable the feature:
.Sp
.Vb 2
\&  $sftp\->put($local_file, $remote_file,
\&             copy_perm => 0, copy_time => 0);
.Ve
.IP "Disable password authentication completely" 4
.IX Item "Disable password authentication completely"
\&\fBQ\fR: When we try to open a session and the key either doesn't exist
or is invalid, the child \s-1SSH\s0 hangs waiting for a password to be
entered.  Is there a way to make this fail back to the Perl program to
be handled?
.Sp
\&\fBA\fR: Disable anything but public key \s-1SSH\s0 authentication calling the
new method as follows:
.Sp
.Vb 2
\&  $sftp = Net::SFTP::Foreign\->new($host,
\&                more => [qw(\-o PreferredAuthentications=publickey)])
.Ve
.Sp
See \fBssh_config\fR\|(5) for the details.
.ie n .IP "Understanding ""$attr\->perm"" bits" 4
.el .IP "Understanding \f(CW$attr\->perm\fR bits" 4
.IX Item "Understanding $attr->perm bits"
\&\fBQ\fR: How can I know if a directory entry is a (directory|link|file|...)?
.Sp
\&\fBA\fR: Use the \f(CW\*(C`S_IS*\*(C'\fR functions from Fcntl. For instance:
.Sp
.Vb 7
\&  use Fcntl qw(S_ISDIR);
\&  my $ls = $sftp\->ls or die $sftp\->error;
\&  for my $entry (@$ls) {
\&    if (S_ISDIR($entry\->{a}\->perm)) {
\&      print "$entry\->{filename} is a directory\en";
\&    }
\&  }
.Ve
.IP "Host key checking" 4
.IX Item "Host key checking"
\&\fBQ\fR: Connecting to a remote server with password authentication fails
with the following error:
.Sp
.Vb 2
\&  The authenticity of the target host can not be established,
\&  connect from the command line first
.Ve
.Sp
\&\fBA\fR: That probably means that the public key from the remote server
is not stored in the \f(CW\*(C`~/.ssh/known_hosts\*(C'\fR file. Run an \s-1SSH\s0 Connection
from the command line as the same user as the script and answer \f(CW\*(C`yes\*(C'\fR
when asked to confirm the key supplied.
.Sp
Example:
.Sp
.Vb 4
\&  $ ssh pluto /bin/true
\&  The authenticity of host \*(Aqpluto (172.25.1.4)\*(Aq can\*(Aqt be established.
\&  RSA key fingerprint is 41:b1:a7:86:d2:a9:7b:b0:7f:a1:00:b7:26:51:76:52.
\&  Are you sure you want to continue connecting (yes/no)? yes
.Ve
.Sp
Your \s-1SSH\s0 client may also support some flag to disable this check, but
doing it can ruin the security of the \s-1SSH\s0 protocol so I advise against
its usage.
.Sp
Example:
.Sp
.Vb 5
\&  # Warning: don\*(Aqt do that unless you fully understand
\&  # its security implications!!!
\&  $sftp = Net::SFTP::Foreign\->new($host,
\&                                  more => [\-o => \*(AqStrictHostKeyChecking no\*(Aq],
\&                                  ...);
.Ve
.SH "BUGS"
.IX Header "BUGS"
These are the currently known bugs:
.IP "\- Doesn't work on \s-1VMS:\s0" 4
.IX Item "- Doesn't work on VMS:"
The problem is related to IPC::Open3 not working on \s-1VMS.\s0 Patches
are welcome!
.IP "\- Dirty cleanup:" 4
.IX Item "- Dirty cleanup:"
On some operating systems, closing the pipes used to communicate with
the slave \s-1SSH\s0 process does not terminate it and a work around has to
be applied. If you find that your scripts hung when the \f(CW$sftp\fR object
gets out of scope, try setting \f(CW$Net::SFTP::Foreign::dirty_cleanup\fR
to a true value and also send me a report including the value of
\&\f(CW$^O\fR on your machine and the OpenSSH version.
.Sp
From version 0.90_18 upwards, a dirty cleanup is performed anyway when
the \s-1SSH\s0 process does not terminate by itself in 8 seconds or less.
.IP "\- Reversed symlink arguments:" 4
.IX Item "- Reversed symlink arguments:"
This package uses the non-conforming OpenSSH argument order for the
\&\s-1SSH_FXP_SYMLINK\s0 command that seems to be the de facto standard. When
interacting with \s-1SFTP\s0 servers that follow the \s-1SFTP\s0 specification, the
\&\f(CW\*(C`symlink\*(C'\fR method will interpret its arguments in reverse order.
.IP "\- IPC::Open3 bugs on Windows" 4
.IX Item "- IPC::Open3 bugs on Windows"
On Windows the IPC::Open3 module is used to spawn the slave \s-1SSH\s0
process. That module has several nasty bugs (related to \s-1STDIN, STDOUT\s0
and \s-1STDERR\s0 being closed or not being assigned to file descriptors 0, 1
and 2 respectively) that will cause the connection to fail.
.Sp
Specifically this is known to happen under mod_perl/mod_perl2.
.IP "\- Password authentication on HP-UX" 4
.IX Item "- Password authentication on HP-UX"
For some unknown reason, it seems that when using the module on HP-UX,
number signs (\f(CW\*(C`#\*(C'\fR) in password need to be escaped (\f(CW\*(C`\e#\*(C'\fR). For
instance:
.Sp
.Vb 4
\&  my $password = "foo#2014";
\&  $password =~ s/#/\e\e#/g if $running_in_hp_ux;
\&  my $ssh = Net::OpenSSH\->new($host, user => $user,
\&                              password => $password);
.Ve
.Sp
I don't have access to an HP-UX machine, and so far nobody using it
has been able to explain this behaviour. Patches welcome!
.IP "\- Taint mode and data coming through \s-1SFTP\s0" 4
.IX Item "- Taint mode and data coming through SFTP"
When the module finds it is being used from a script started in taint
mode, on every method call it checks all the arguments passed and dies
if any of them is tainted. Also, any data coming through the \s-1SFTP\s0
connection is marked as tainted.
.Sp
That generates an internal conflict for those methods that under the
hood query the remote server multiple times, using data from responses
to previous queries (tainted) to build new ones (die!).
.Sp
I don't think a generic solution could be applied to this issue while
honoring the taint-mode spirit (and erring on the safe side), so my
plan is to fix that in a case by case manner.
.Sp
So, please report any issue you find with taint mode!
.PP
Also, the following features should be considered experimental:
.PP
\&\- support for Tectia server
.PP
\&\- numbered feature
.PP
\&\- autodie mode
.PP
\&\- best_effort feature
.SH "SUPPORT"
.IX Header "SUPPORT"
To report bugs, send me and email or use the \s-1CPAN\s0 bug tracking system
at <http://rt.cpan.org>.
.SS "Commercial support"
.IX Subsection "Commercial support"
Commercial support, professional services and custom software
development around this module are available through my current
company. Drop me an email with a rough description of your
requirements and we will get back to you \s-1ASAP.\s0
.SS "My wishlist"
.IX Subsection "My wishlist"
If you like this module and you're feeling generous, take a look at my
Amazon Wish List: <http://amzn.com/w/1WU1P6IR5QZ42>
.PP
Also consider contributing to the OpenSSH project this module builds
upon: <http://www.openssh.org/donations.html>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Information about the constants used on this module is available from
Net::SFTP::Foreign::Constants. Information about attribute objects
is available from Net::SFTP::Foreign::Attributes.
.PP
General information about \s-1SSH\s0 and the OpenSSH implementation is
available from the OpenSSH web site at <http://www.openssh.org/> and
from the \fBsftp\fR\|(1) and \fBsftp\-server\fR\|(8) manual pages.
.PP
Net::SFTP::Foreign integrates nicely with my other module
Net::OpenSSH.
.PP
Net::SFTP::Foreign::Backend::Net_SSH2 allows one to run
Net::SFTP::Foreign on top of Net::SSH2 (nowadays, this combination
is probably the best option under Windows).
.PP
Modules offering similar functionality available from \s-1CPAN\s0 are
Net::SFTP and Net::SSH2.
.PP
Test::SFTP allows one to run tests against a remote \s-1SFTP\s0 server.
.PP
autodie.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005\-2020 Salvador Fandiño (sfandino@yahoo.com).
.PP
Copyright (c) 2001 Benjamin Trott, Copyright (c) 2003 David Rolsky.
.PP
_glob_to_regex method based on code (c) 2002 Richard Clamp.
.PP
All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the \s-1LICENSE\s0 file included
with this module.
