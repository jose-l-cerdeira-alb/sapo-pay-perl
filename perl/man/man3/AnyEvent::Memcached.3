.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Memcached 3"
.TH AnyEvent::Memcached 3 "2010-07-11" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Memcached \- AnyEvent memcached client
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use AnyEvent::Memcached;
\&
\&    my $memd = AnyEvent::Memcached\->new(
\&        servers => [ "10.0.0.15:11211", "10.0.0.15:11212" ], # same as in Cache::Memcached
\&        debug   => 1,
\&        compress_threshold => 10000,
\&        namespace => \*(Aqmy\-namespace:\*(Aq,
\&        
\&        # May use another hashing algo:
\&        hasher  => \*(AqAnyEvent::Memcached::Hash::WithNext\*(Aq,
\&
\&        cv      => $cv, # AnyEvent\->condvar: group callback
\&    );
\&    
\&    $memd\->set_servers([ "10.0.0.15:11211", "10.0.0.15:11212" ]);
\&    
\&    # Basic methods are like in Cache::Memcached, but with additional cb => sub { ... };
\&    # first argument to cb is return value, second is the error(s)
\&    
\&    $memd\->set( key => $value, cb => sub {
\&        shift or warn "Set failed: @_"
\&    } );
\&
\&    # Single get
\&    $memd\->get( \*(Aqkey\*(Aq, cb => sub {
\&        my ($value,$err) = shift;
\&        $err and return warn "Get failed: @_";
\&        warn "Value for key is $value";
\&    } );
\&
\&    # Multi\-get
\&    $memd\->get( [ \*(Aqkey1\*(Aq, \*(Aqkey2\*(Aq ], cb => sub {
\&        my ($values,$err) = shift;
\&        $err and return warn "Get failed: @_";
\&        warn "Value for key1 is $values\->{key1} and value for key2 is $values\->{key2}"
\&    } );
\&
\&    # Additionally there is rget (see memcachedb\-1.2.1\-beta)
\&
\&    $memd\->rget( \*(Aqfromkey\*(Aq, \*(Aqtokey\*(Aq, cb => sub {
\&        my ($values,$err) = shift;
\&        $err and warn "Get failed: @_";
\&        while (my ($key,$value) = each %$values) {
\&            # ...
\&        }
\&    } );
\&    
\&    # Rget with sorted responce values
\&    $memd\->rget( \*(Aqfromkey\*(Aq, \*(Aqtokey\*(Aq, rv => \*(Aqarray\*(Aq cb => sub {
\&        my ($values,$err) = shift;
\&        $err and warn "Get failed: @_";
\&        for (0 .. $#values/2) {
\&            my ($key,$value) = @$values[$_*2,$_*2+1];
\&        }
\&    } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Asyncronous \f(CW\*(C`memcached/memcachedb\*(C'\fR client for AnyEvent framework
.SH "NOTICE"
.IX Header "NOTICE"
There is a notices in Cache::Memcached::AnyEvent related to this module. They all has been fixed
.IP "Prerequisites" 4
.IX Item "Prerequisites"
We no longer need Object::Event and Devel::Leak::Cb. At all, the dependency list is like in Cache::Memcached + AnyEvent
.IP "Binary protocol" 4
.IX Item "Binary protocol"
It seems to me, that usage of binary protocol from pure perl gives very little advantage. So for now I don't implement it
.IP "Unimplemented Methods" 4
.IX Item "Unimplemented Methods"
There is a note, that get_multi is not implementeted. In fact, it was implemented by method \*(L"get\*(R", but the documentation was wrong.
.PP
In general, this module follows the spirit of AnyEvent rather than correspondence to Cache::Memcached interface.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new %args"
.el .SS "new \f(CW%args\fP"
.IX Subsection "new %args"
Currently supported options:
.IP "servers =item namespace =item debug =item cv =item compress_threshold =item compress_enable =item timeout =item hasher" 4
.IX Item "servers =item namespace =item debug =item cv =item compress_threshold =item compress_enable =item timeout =item hasher"
If set, will use instance of this class for hashing instead of default.
For implementing your own hashing, see sources of AnyEvent::Memcached::Hash and AnyEvent::Memcached::Hash::With::Next
.IP "noreply" 4
.IX Item "noreply"
If true, additional connection will established for noreply commands.
.IP "cas" 4
.IX Item "cas"
If true, will enable cas/gets commands (since they are not suppotred in memcachedb)
.SS "set_servers"
.IX Subsection "set_servers"
.Vb 1
\&    Setup server list
.Ve
.SS "connect"
.IX Subsection "connect"
.Vb 1
\&    Establish connection to all servers and invoke event C<connected>, when ready
.Ve
.ie n .SS "set( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "set( \f(CW$key\fP, \f(CW$value\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "set( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Unconditionally sets a key to a given value in the memcache.
.PP
\&\f(CW$rc\fR is
.IP "'1'" 4
.IX Item "'1'"
Successfully stored
.IP "'0'" 4
.IX Item "'0'"
Item was not stored
.IP "undef" 4
.IX Item "undef"
Error happens, see \f(CW$err\fR
.ie n .SS "cas( $key, $cas, $value, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "cas( \f(CW$key\fP, \f(CW$cas\fP, \f(CW$value\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "cas( $key, $cas, $value, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
.Vb 10
\&    $memd\->gets($key, cb => sub {
\&        my $value = shift;
\&        unless (@_) { # No errors
\&            my ($cas,$val) = @$value;
\&            # Change your value in $val
\&            $memd\->cas( $key, $cas, $value, cb => sub {
\&                my $rc = shift;
\&                if ($rc) {
\&                    # stored
\&                } else {
\&                    # ...
\&                }
\&            });
\&        }
\&    })
.Ve
.PP
\&\f(CW$rc\fR is the same, as for \*(L"set\*(R"
.PP
Store the \f(CW$value\fR on the server under the \f(CW$key\fR, but only if \s-1CAS\s0 value associated with this key is equal to \f(CW$cas\fR. See also \*(L"gets\*(R"
.ie n .SS "add( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "add( \f(CW$key\fP, \f(CW$value\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "add( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Like \f(CW\*(C`set\*(C'\fR, but only stores in memcache if the key doesn't already exist.
.ie n .SS "replace( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "replace( \f(CW$key\fP, \f(CW$value\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "replace( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Like \f(CW\*(C`set\*(C'\fR, but only stores in memcache if the key already exists. The opposite of add.
.ie n .SS "append( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "append( \f(CW$key\fP, \f(CW$value\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "append( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Append the \f(CW$value\fR to the current value on the server under the \f(CW$key\fR.
.PP
\&\fBappend\fR command first appeared in memcached 1.2.4.
.ie n .SS "prepend( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "prepend( \f(CW$key\fP, \f(CW$value\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "prepend( $key, $value, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Prepend the \f(CW$value\fR to the current value on the server under the \f(CW$key\fR.
.PP
\&\fBprepend\fR command first appeared in memcached 1.2.4.
.ie n .SS "get( $key, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "get( \f(CW$key\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "get( $key, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Retrieve the value for a \f(CW$key\fR. \f(CW$key\fR should be a scalar
.ie n .SS "get( $keys : \s-1ARRAYREF\s0, [cv => $cv], [ expire => $expire ], cb => $cb\->( $values_hash, $err ) )"
.el .SS "get( \f(CW$keys\fP : \s-1ARRAYREF\s0, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$values_hash\fP, \f(CW$err\fP ) )"
.IX Subsection "get( $keys : ARRAYREF, [cv => $cv], [ expire => $expire ], cb => $cb->( $values_hash, $err ) )"
Retrieve the values for a \f(CW$keys\fR. Return a hash with keys/values
.ie n .SS "gets( $key, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "gets( \f(CW$key\fP, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "gets( $key, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Retrieve the value and its \s-1CAS\s0 for a \f(CW$key\fR. \f(CW$key\fR should be a scalar.
.PP
\&\f(CW$rc\fR is a reference to an array [$cas, \f(CW$value\fR], or nothing for non-existent key
.ie n .SS "gets( $keys : \s-1ARRAYREF\s0, [cv => $cv], [ expire => $expire ], cb => $cb\->( $rc, $err ) )"
.el .SS "gets( \f(CW$keys\fP : \s-1ARRAYREF\s0, [cv => \f(CW$cv\fP], [ expire => \f(CW$expire\fP ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "gets( $keys : ARRAYREF, [cv => $cv], [ expire => $expire ], cb => $cb->( $rc, $err ) )"
Retrieve the values and their \s-1CAS\s0 for a \f(CW$keys\fR.
.PP
\&\f(CW$rc\fR is a hash reference with \f(CW$rc\fR\->{$key} is a reference to an array [$cas, \f(CW$value\fR]
.ie n .SS "delete( $key, [cv => $cv], [ noreply => 1 ], cb => $cb\->( $rc, $err ) )"
.el .SS "delete( \f(CW$key\fP, [cv => \f(CW$cv\fP], [ noreply => 1 ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "delete( $key, [cv => $cv], [ noreply => 1 ], cb => $cb->( $rc, $err ) )"
Delete \f(CW$key\fR and its value from the cache.
.PP
If \f(CW\*(C`noreply\*(C'\fR is true, cb doesn't required
.SS "del"
.IX Subsection "del"
Alias for \*(L"delete\*(R"
.SS "remove"
.IX Subsection "remove"
Alias for \*(L"delete\*(R"
.ie n .SS "incr( $key, $increment, [cv => $cv], [ noreply => 1 ], cb => $cb\->( $rc, $err ) )"
.el .SS "incr( \f(CW$key\fP, \f(CW$increment\fP, [cv => \f(CW$cv\fP], [ noreply => 1 ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "incr( $key, $increment, [cv => $cv], [ noreply => 1 ], cb => $cb->( $rc, $err ) )"
Increment the value for the \f(CW$key\fR by \f(CW$delta\fR. Starting with memcached 1.3.3 \f(CW$key\fR should be set to a number or the command will fail.
Note that the server doesn't check for overflow.
.PP
If \f(CW\*(C`noreply\*(C'\fR is true, cb doesn't required, and if passed, simply called with rc = 1
.PP
Similar to \s-1DBI\s0, zero is returned as \*(L"0E0\*(R", and evaluates to true in a boolean context.
.ie n .SS "decr( $key, $decrement, [cv => $cv], [ noreply => 1 ], cb => $cb\->( $rc, $err ) )"
.el .SS "decr( \f(CW$key\fP, \f(CW$decrement\fP, [cv => \f(CW$cv\fP], [ noreply => 1 ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "decr( $key, $decrement, [cv => $cv], [ noreply => 1 ], cb => $cb->( $rc, $err ) )"
Opposite to \f(CW\*(C`incr\*(C'\fR
.ie n .SS "rget( $from, $till, [ max => 100 ], [ '+left' => 1 ], [ '+right' => 1 ], [cv => $cv], [ rv => 'array' ], cb => $cb\->( $rc, $err ) )"
.el .SS "rget( \f(CW$from\fP, \f(CW$till\fP, [ max => 100 ], [ '+left' => 1 ], [ '+right' => 1 ], [cv => \f(CW$cv\fP], [ rv => 'array' ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "rget( $from, $till, [ max => 100 ], [ '+left' => 1 ], [ '+right' => 1 ], [cv => $cv], [ rv => 'array' ], cb => $cb->( $rc, $err ) )"
Memcachedb 1.2.1\-beta implements rget method, that allows to look through the whole storage
.ie n .IP "$from" 4
.el .IP "\f(CW$from\fR" 4
.IX Item "$from"
the starting key
.ie n .IP "$till" 4
.el .IP "\f(CW$till\fR" 4
.IX Item "$till"
finishing key
.IP "+left" 4
.IX Item "+left"
If true, then starting key will be included in results. true by default
.IP "+right" 4
.IX Item "+right"
If true, then finishing key will be included in results. true by default
.IP "max" 4
.IX Item "max"
Maximum number of results to fetch. 100 is the maximum and is the default
.IP "rv" 4
.IX Item "rv"
If passed rv => 'array', then the return value will be arrayref with values in order, returned by memcachedb.
.ie n .SS "incadd ( $key, $increment, [cv => $cv], [ noreply => 1 ], cb => $cb\->( $rc, $err ) )"
.el .SS "incadd ( \f(CW$key\fP, \f(CW$increment\fP, [cv => \f(CW$cv\fP], [ noreply => 1 ], cb => \f(CW$cb\fP\->( \f(CW$rc\fP, \f(CW$err\fP ) )"
.IX Subsection "incadd ( $key, $increment, [cv => $cv], [ noreply => 1 ], cb => $cb->( $rc, $err ) )"
Increment key, and if it not exists, add it with initial value. If add fails, try again to incr or fail
.SS "destroy"
.IX Subsection "destroy"
Shutdown object as much, as possible, incl cleaning of incapsulated objects
.SH "BUGS"
.IX Header "BUGS"
Feature requests are welcome
.PP
Bug reports are welcome
.SH "AUTHOR"
.IX Header "AUTHOR"
Mons Anderson, \f(CW\*(C`<mons at cpan.org>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009 Mons Anderson, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
