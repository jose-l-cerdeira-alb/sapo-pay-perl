.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perlbal::Manual::ReverseProxy 3"
.TH Perlbal::Manual::ReverseProxy 3 "2011-09-03" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perlbal::Manual::ReverseProxy \- Configuring Perlbal as a Reverse Proxy
.SS "\s-1VERSION\s0"
.IX Subsection "VERSION"
Perlbal 1.78.
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
How to configure a Perlbal Reverse Proxy service.
.SS "\s-1READ\s0 \s-1ME\s0 \s-1FIRST\s0"
.IX Subsection "READ ME FIRST"
Please read Perlbal::Manual::Configuration first for a better explanation on how to configure Perlbal. This document will make much more sense after reading that.
.SS "Configuring Perlbal as a Reverse Proxy"
.IX Subsection "Configuring Perlbal as a Reverse Proxy"
Configuration of Perlbal as a Reverse Proxy is similar to configuration as a Load Balancer.
.PP
Check Perlbal::Manual::LoadBalancer under \f(CW\*(C`Using Perlbal as a Load Balancer\*(C'\fR for a sample configuration file and for a brief explanation of the differences between a Load Balancer and a Reverse Proxy.
.SS "Parameters"
.IX Subsection "Parameters"
You can set parameters via commands of either forms:
.PP
.Vb 2
\&    SET <service\-name> <param> = <value>
\&    SET <param> = <value>
.Ve
.IP "\fBalways_trusted\fR = bool" 8
.IX Item "always_trusted = bool"
Whether to trust all incoming requests' X\-Forwarded-For and related headers. Set to true only if you know that all incoming requests from your own proxy servers that clean/set those headers.
.Sp
Default is false.
.IP "\fBbackend_persist_cache\fR = int" 8
.IX Item "backend_persist_cache = int"
The number of backend connections to keep alive on reserve while there are no clients.
.Sp
Default is 2.
.IP "\fBblind_proxy\fR = bool" 8
.IX Item "blind_proxy = bool"
Flag to disable any modification of X\-Forwarded-For, X\-Host, and X\-Forwarded-Host headers.
.Sp
Default is false.
.IP "\fBbuffer_backend_connect\fR = size" 8
.IX Item "buffer_backend_connect = size"
How much content-body (POST/PUT/etc) data we read from a client before we start sending it to a backend web node. If \f(CW\*(C`buffer_uploads\*(C'\fR is enabled, this value is used to determine how many bytes are read before Perlbal makes a determination on whether or not to spool the upload to disk.
.Sp
Default is 100k.
.IP "\fBbuffer_size\fR = size" 8
.IX Item "buffer_size = size"
How much ahead of a client we'll get while copying from a backend to a client. If a client gets behind this much, we stop reading from the backend for a bit. Once all remaining data fits in the buffer, the backend is released and may be reused.
.Sp
Default is 256k.
.IP "\fBbuffer_size_reproxy_url\fR = size" 8
.IX Item "buffer_size_reproxy_url = size"
How much ahead of a client we'll get while copying from a reproxied \s-1URL\s0 to a client. If a client gets behind this much, we stop reading from the reproxied \s-1URL\s0 for a bit. The default is lower than the regular \f(CW\*(C`buffer_size\*(C'\fR (50k instead of 256k) because it's assumed that you're only reproxying to large files on event-based webservers, which are less sensitive to many open connections, whereas the 256k buffer size is good for keeping heavy process-based free of slow clients.
.Sp
Default if 50k.
.IP "\fBbuffer_upload_threshold_rate\fR = int" 8
.IX Item "buffer_upload_threshold_rate = int"
If an upload is coming in at a rate less than this value in bytes per second, it will be buffered to disk. A value of 0 means the rate will not be checked.
.Sp
Default is 0.
.IP "\fBbuffer_upload_threshold_size\fR = size" 8
.IX Item "buffer_upload_threshold_size = size"
If an upload is larger than this size in bytes, it will be buffered to disk. A value of 0 means the size will not be checked.
.Sp
Default is 250k.
.IP "\fBbuffer_upload_threshold_time\fR = int" 8
.IX Item "buffer_upload_threshold_time = int"
If an upload is estimated to take more than this number of seconds, it will be buffered to disk. A value of 0 means the time will not be estimated.
.Sp
Default is 5.
.IP "\fBbuffer_uploads\fR = bool" 8
.IX Item "buffer_uploads = bool"
Used to enable or disable the buffer uploads to disk system. If enabled, \f(CW\*(C`buffer_backend_connect\*(C'\fR bytes worth of the upload will be stored in memory. At that point, the buffer upload thresholds will be checked to see if we should just send this upload to the backend or if we should spool it to the disk.
.Sp
Default if false.
.IP "\fBbuffer_uploads_path\fR = path/to/directory" 8
.IX Item "buffer_uploads_path = path/to/directory"
Directory root for storing files used to buffer uploads.
.IP "\fBclient_sndbuf_size\fR = \fIsize\fR" 8
.IX Item "client_sndbuf_size = size"
How large to set the client's socket \s-1SNDBUF\s0.
.Sp
Default is 0.
.IP "\fBconnect_ahead\fR = int" 8
.IX Item "connect_ahead = int"
How many extra backend connections we keep alive in addition to the current ones, in anticipation of new client connections.
.Sp
Default is 0.
.IP "\fBenable_error_retries\fR = bool" 8
.IX Item "enable_error_retries = bool"
Whether Perlbal should transparently retry requests to backends if a backend returns a 500 server error.
.Sp
Default is false.
.IP "\fBenable_reproxy\fR = bool" 8
.IX Item "enable_reproxy = bool"
Enable 'reproxying' (end-user-transparent internal redirects) to either local files or other URLs. When enabled, the backend servers in the pool that this service is configured for will have access to tell this Perlbal instance to serve any local readable file, or connect to any other \s-1URL\s0 that this Perlbal can connect to. Only enable this if you trust the backend web nodes.
.Sp
Default is false.
.Sp
See the section \f(CW\*(C`Reproxying\*(C'\fR in this document for more information.
.IP "\fBerror_retry_schedule\fR = string of comma-separated seconds (full or partial)" 8
.IX Item "error_retry_schedule = string of comma-separated seconds (full or partial)"
String of comma-separated seconds (full or partial) to delay between retries. For example \*(L"0,2\*(R" would mean do at most two retries, the first zero seconds after the first failure, and the second 2 seconds after the second failure. You probably don't need to modify the default value.
.Sp
Default it 0,0.25,0.50,1,1,1,1,1
.IP "\fBenable_ssl\fR = bool" 8
.IX Item "enable_ssl = bool"
Enable \s-1SSL\s0 to the client.
.Sp
Default is false.
.IP "\fBhigh_priority_cookie\fR = cookie_name" 8
.IX Item "high_priority_cookie = cookie_name"
The cookie name to inspect to determine if the client goes onto the high-priority queue.
.Sp
See Perlbal::Manual::HighPriority for more information.
.IP "\fBhigh_priority_cookie_contents\fR = string" 8
.IX Item "high_priority_cookie_contents = string"
A string that the \f(CW\*(C`high_priority_cookie\*(C'\fR must contain to go onto the high-priority queue.
.Sp
See Perlbal::Manual::HighPriority for more information.
.IP "\fBidle_timeout\fR = int" 8
.IX Item "idle_timeout = int"
Timeout in seconds for idle connections to the end user. It's also the limit for how long a backend may take to respond or transfer data.
.Sp
Default is 30.
.IP "\fBlisten\fR = ip:port" 8
.IX Item "listen = ip:port"
The ip:port to listen on. For a service to work, you must either make it listen, or make another selector service map to a non-listening service.
.IP "\fBmax_backend_uses\fR = int" 8
.IX Item "max_backend_uses = int"
The maximum number of requests to be made on a single persistent backend connection before releasing the connection.
.Sp
A value of 0 means there is no limit and the connection will only be discarded once the backend asks it to be or when Perlbal is sufficiently idle.
.Sp
Default is 0.
.IP "\fBmax_chunked_request_size\fR = size" 8
.IX Item "max_chunked_request_size = size"
The maximum size that will be accepted for a chunked request (which is written to disk, buffered uploads must be on). A value of 0 means no limit.
.Sp
Default is 209715200 (200MB).
.IP "\fBpersist_client\fR = bool" 8
.IX Item "persist_client = bool"
Whether to enable \s-1HTTP\s0 keep-alives to the end user.
.Sp
Default is false.
.IP "\fBpersist_backend\fR = bool" 8
.IX Item "persist_backend = bool"
Whether to enable \s-1HTTP\s0 keep-alives to the backend webnodes.
.Sp
Default is false, but setting it to true is highly recommended if Perlbal is the only client to your backends. If not, beware that Perlbal will hog the connections, starving other clients.
.IP "\fBpersist_client_idle_timeout\fR = int" 8
.IX Item "persist_client_idle_timeout = int"
Timeout in seconds for \s-1HTTP\s0 persist_client_idle_timeout keep-alives to the end user.
.Sp
Default is 30.
.IP "\fBpersist_client_timeout\fR = int (\fB\s-1DEPRECATED\s0\fR)" 8
.IX Item "persist_client_timeout = int (DEPRECATED)"
Set both the persist_client_timeout persist_client_idle_timeout and idle_timeout.
.Sp
Deprecated.
.IP "\fBpool\fR" 8
.IX Item "pool"
Name of previously-created pool object containing the backend nodes that this reverse proxy sends requests to.
.IP "\fBqueue_relief_chance\fR = int:0\-100" 8
.IX Item "queue_relief_chance = int:0-100"
Chance (percentage) to take a standard priority request when we're in pressure relief mode.
.Sp
Default is 0.
.Sp
See Perlbal::Manual::HighPriority for more information.
.IP "\fBqueue_relief_size\fR = int" 8
.IX Item "queue_relief_size = int"
Number of outstanding standard priority connections to activate pressure relief at.
.Sp
A value of 0 disables the high priority queue system entirely.
.Sp
Default is 0.
.Sp
See Perlbal::Manual::HighPriority for more information.
.IP "\fBreproxy_cache_maxsize\fR = int" 8
.IX Item "reproxy_cache_maxsize = int"
Set the maximum number of cached reproxy results (X\-REPROXY-CACHE-FOR) that may be kept in the service cache. These cached requests take up about 1.25KB of \s-1RAM\s0 each (on Linux x86), but will vary with usage. Perlbal still starts with 0 in the cache and will grow over time. Be careful when adjusting this and watch your \s-1RAM\s0 usage like a hawk.
.Sp
Default is 0, which means cache is disabled.
.IP "\fBrole\fR = reverse_proxy|web_server|management|selector" 8
.IX Item "role = reverse_proxy|web_server|management|selector"
What type of service. One of 'reverse_proxy' for a service that load balances to a pool of backend webserver nodes, 'web_server' for a typical webserver', 'management' for a Perlbal management interface (speaks both command-line or \s-1HTTP\s0, auto-detected), or 'selector', for a virtual service that maps onto other services.
.IP "\fBserver_process\fR" 8
.IX Item "server_process"
Executable which will be the \s-1HTTP\s0 server on stdin/stdout. (\fB\s-1ALPHA\s0\fR, \fB\s-1EXPERIMENTAL\s0\fR)
.IP "\fBssl_cert_file\fR = path/to/file" 8
.IX Item "ssl_cert_file = path/to/file"
Path to certificate \s-1PEM\s0 file for \s-1SSL\s0.
.Sp
Default is \f(CW\*(C`certs/server\-cert.pem\*(C'\fR.
.IP "\fBssl_cipher_list\fR = cipher list" 8
.IX Item "ssl_cipher_list = cipher list"
OpenSSL-style cipher list.
.Sp
Default is \f(CW\*(C`ALL:!LOW:!EXP\*(C'\fR.
.IP "\fBssl_key_file\fR = path/to/file" 8
.IX Item "ssl_key_file = path/to/file"
Path to private key \s-1PEM\s0 file for \s-1SSL\s0.
.Sp
Default is \f(CW\*(C`certs/server\-key.pem\*(C'\fR.
.IP "\fBtrusted_upstream_proxies\fR = Net::Netmask filter" 8
.IX Item "trusted_upstream_proxies = Net::Netmask filter"
A comma separated list of Net::Netmask filters (e.g. 10.0.0.0/24, see Net::Netmask) that determines whether upstream clients are trusted or not, where trusted means their X\-Forwarded\-For/etc headers are not munged.
.IP "\fBupload_status_listeners\fR = comma separated list of hosts" 8
.IX Item "upload_status_listeners = comma separated list of hosts"
Comma separated list of hosts in form 'a.b.c.d:port' which will receive \s-1UDP\s0 upload status packets no faster than once a second per \s-1HTTP\s0 request (\s-1PUT/POST\s0) from clients that have requested an upload status bar, which they request by appending the \s-1URL\s0 get argument ?client_up_sess=[xxxxx] where xxxxx is 5\-50 'word' characters (a\-z, A\-Z, 0\-9, underscore).
.IP "\fBverify_backend\fR = bool" 8
.IX Item "verify_backend = bool"
Whether Perlbal should send a quick \s-1OPTIONS\s0 request to the backends before sending an actual client request to them. If your backend is Apache or some other process-based webserver, this is highly recommended. All too often a loaded backend box will reply to new \s-1TCP\s0 connections, but it's the kernel's \s-1TCP\s0 stack Perlbal is talking to, not and actual Apache process yet. Using this option reduces end-user latency a ton on loaded sites.
.Sp
Default if false.
.IP "\fBverify_backend_path\fR = path" 8
.IX Item "verify_backend_path = path"
What path the \s-1OPTIONS\s0 request sent by \f(CW\*(C`verify_backend\*(C'\fR should use.
.Sp
Default is \f(CW\*(C`*\*(C'\fR.
.IP "\fBserver_tokens\fR = bool" 8
.IX Item "server_tokens = bool"
Whether to provide a \*(L"Server\*(R" header.
.Sp
Perlbal by default adds a header to all replies (such as the web_server role). By setting this default to \*(L"off\*(R", you can prevent Perlbal from identifying itself.
.Sp
Default is \f(CW\*(C`on\*(C'\fR.
.SS "More on Parameters"
.IX Subsection "More on Parameters"
\fIbackend_persist_cache vs. connect_ahead\fR
.IX Subsection "backend_persist_cache vs. connect_ahead"
.PP
The \f(CW\*(C`backend_persist_cache\*(C'\fR parameter refers to connections kept alive after being used, while \f(CW\*(C`connect_ahead\*(C'\fR refers to connections opened in anticipation.
.PP
For instance:
.PP
.Vb 2
\&    SET backend_persist_cache = 2
\&    SET connect_ahead         = 1
.Ve
.PP
Let's assume, for simplification purposes, that your service only has one server. Here's an example of what could happen:
.IP "\(bu" 4
Perlbal starts
.Sp
No connections open until the very first request comes in (this may change in the future).
.IP "\(bu" 4
one requests arrives
.Sp
This request starts being served on the open connection; Perlbal opens another connection because \f(CW\*(C`connect_ahead\*(C'\fR's value tells it to always open one in anticipation.
.IP "\(bu" 4
a second request arrives
.Sp
(the first request hasn't concluded yet)
.Sp
The second connection is used, a third one is created so we still have one in anticipation.
.IP "\(bu" 4
the first request finishes
.Sp
The connection is kept open; this means we now have three open connections: two being used and one free (the first and the third one are free).
.IP "\(bu" 4
the second request finishes
.Sp
The connection is killed, as we already have two other open connections (the first and the third), and that's the number set by \f(CW\*(C`backend_persist_cache\*(C'\fR for the number of connections to be kept alive.
.PP
\fIReproxying\fR
.IX Subsection "Reproxying"
.PP
Perlbal supports the concept of reproxying. Basically, this gives it the ability to ask a backend node for a file and get back a specific header that says \*(L"this file is really over there, get it there.\*(R" Perlbal will then load that file or \s-1URL\s0 and send it to the user transparently, without them ever knowing that they got reproxied to another location.
.PP
Add the following line to your \fIperlbal.conf\fR to enable reproxying on a per service basis ( reproxying is disabled by default in >= 1.38 ):
.PP
.Vb 1
\&    SET enable_reproxy  = true
.Ve
.PP
This can be useful for having URLs that get mapped to files on disk without giving users enough information to map out your directory structure. For example, you can create a file structure such as:
.PP
.Vb 1
\&    /home/pics/$userid/$pic
.Ve
.PP
Then you can have URLs such as:
.PP
.Vb 1
\&    http://foo.com/mysite/users/$userid/picture/$pic
.Ve
.PP
When this \s-1URL\s0 gets passed to the backend web node, it could return a simple response that includes this header:
.PP
.Vb 1
\&    X\-REPROXY\-FILE: /home/pics/$userid/$pic
.Ve
.PP
Perlbal will then use asynchronous \s-1IO\s0 to send the file to the user without slowing down Perlbal at all.
.PP
This support also extends to URLs that can be located anywhere Perlbal has access to. It's the same syntax, nearly:
.PP
.Vb 1
\&    X\-REPROXY\-URL: http://foo.com:80/resource.html
.Ve
.PP
You can also specify multiple URLs:
.PP
.Vb 1
\&    X\-REPROXY\-URL: http://foo.com:80/resource.html http://baz.com:8080/res.htm
.Ve
.PP
Just specify any number of space separated URLs. Perlbal will request them one by one until one returns a response code of 200. At that point Perlbal will proxy the response back to the user just like normal.
.PP
Note that the user's headers are \s-1NOT\s0 passed through to the web server. To the target server, it looks simply like Perlbal is requesting the resource for itself. This behavior may change at some point.
.PP
One final note: the server that returns the reproxy header can also return a \f(CW\*(C`X\-REPROXY\-EXPECTED\-SIZE\*(C'\fR header. If present, Perlbal will consider a reproxy a failure if the file returned by the target system is of a different size than what the expected size header says. On failure, Perlbal tries the next \s-1URI\s0 in the list. If it's a file being reproxied, a 404 is returned if the file size is different.
.SS "\s-1SEE\s0 \s-1ALSO\s0"
.IX Subsection "SEE ALSO"
Perlbal::Manual::Configuration,
Perlbal::Manual::FailOver,
Perlbal::Manual::LoadBalancer,
Perlbal::Manual::Management.
