.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Object::Event 3"
.TH Object::Event 3 "2011-08-04" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Event \- A class that provides an event callback interface
.SH "VERSION"
.IX Header "VERSION"
Version 1.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   package foo;
\&   use Object::Event;
\&
\&   our @ISA = qw/Object::Event/;
\&
\&   package main;
\&   my $o = foo\->new;
\&
\&   my $regguard = $o\->reg_cb (foo => sub {
\&      print "I got an event, with these args: $_[1], $_[2], $_[3]\en";
\&   });
\&
\&   $o\->event (foo => 1, 2, 3);
\&
\&   $o\->unreg_cb ($regguard);
\&   # or just:
\&   $regguard = undef;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module was mainly written for AnyEvent::XMPP, AnyEvent::IRC,
AnyEvent::HTTPD and \s-1BK\s0 to provide a consistent \s-1API\s0 for registering and
emitting events.  Even though I originally wrote it for those modules I released
it separately in case anyone may find this module useful.
.PP
For more comprehensive event handling see also Glib and \s-1POE\s0.
.PP
This class provides a simple way to extend a class, by inheriting from
this class, with an event callback interface.
.PP
You will be able to register callbacks for events, identified by their names (a
string) and call them later by invoking the \f(CW\*(C`event\*(C'\fR method with the event name
and some arguments.
.PP
There is even a syntactic sugar which allows to call methods on the instances
of Object::Event\-derived classes, to invoke events.  For this feature see
the \*(L"\s-1EVENT METHODS\*(R"\s0 section of this document.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
In the first version as presented here no special performance optimisations
have been applied. So take care that it is fast enough for your purposes.  At
least for modules like AnyEvent::XMPP the overhead is probably not
noticeable, as other technologies like \s-1XML\s0 already waste a lot more \s-1CPU\s0 cycles.
Also I/O usually introduces _much_ larger/longer overheads than this simple
event interface.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "Object::Event::register_priority_alias ($alias, $priority)" 4
.el .IP "Object::Event::register_priority_alias ($alias, \f(CW$priority\fR)" 4
.IX Item "Object::Event::register_priority_alias ($alias, $priority)"
This package function will add a global priority alias.
If \f(CW$priority\fR is undef the alias will be removed.
.Sp
There are 4 predefined aliases:
.Sp
.Vb 4
\&   before     =>  1000
\&   ext_before =>   500
\&   ext_after  =>  \-500
\&   after      => \-1000
.Ve
.Sp
See also the \f(CW\*(C`reg_cb\*(C'\fR method for more information about aliases.
.SH "METHODS"
.IX Header "METHODS"
.IP "Object::Event\->new (%args)" 4
.IX Item "Object::Event->new (%args)"
.PD 0
.IP "Your::Subclass::Of::Object::Event\->new (%args)" 4
.IX Item "Your::Subclass::Of::Object::Event->new (%args)"
.PD
This is the constructor for Object::Event,
it will create a blessed hash reference initialized with \f(CW%args\fR.
.ie n .IP "$obj\->init_object_events ()" 4
.el .IP "\f(CW$obj\fR\->init_object_events ()" 4
.IX Item "$obj->init_object_events ()"
This method should only be called if you are not able to call the \f(CW\*(C`new\*(C'\fR
constructor of this class. Then you need to call this method to initialize
the event system.
.ie n .IP "$obj\->set_exception_cb ($cb\->($exception, $eventname))" 4
.el .IP "\f(CW$obj\fR\->set_exception_cb ($cb\->($exception, \f(CW$eventname\fR))" 4
.IX Item "$obj->set_exception_cb ($cb->($exception, $eventname))"
This method installs a callback that will be called when some other
event callback threw an exception. The first argument to \f(CW$cb\fR
will be the exception and the second the event name.
.ie n .IP "$guard = $obj\->reg_cb ($eventname => $cb\->($obj, @args), ...)" 4
.el .IP "\f(CW$guard\fR = \f(CW$obj\fR\->reg_cb ($eventname => \f(CW$cb\fR\->($obj, \f(CW@args\fR), ...)" 4
.IX Item "$guard = $obj->reg_cb ($eventname => $cb->($obj, @args), ...)"
.PD 0
.ie n .IP "$guard = $obj\->reg_cb ($eventname => $prio, $cb\->($obj, @args), ...)" 4
.el .IP "\f(CW$guard\fR = \f(CW$obj\fR\->reg_cb ($eventname => \f(CW$prio\fR, \f(CW$cb\fR\->($obj, \f(CW@args\fR), ...)" 4
.IX Item "$guard = $obj->reg_cb ($eventname => $prio, $cb->($obj, @args), ...)"
.PD
This method registers a callback \f(CW$cb1\fR for the event with the
name \f(CW$eventname1\fR. You can also pass multiple of these eventname => callback
pairs.
.Sp
The return value \f(CW$guard\fR will be a guard that represents the set of callbacks
you have installed. You can either just \*(L"forget\*(R" the contents of \f(CW$guard\fR to
unregister the callbacks or call \f(CW\*(C`unreg_cb\*(C'\fR with that \s-1ID\s0 to remove those
callbacks again. If \f(CW\*(C`reg_cb\*(C'\fR is called in a void context no guard is returned
and you have no chance to unregister the registered callbacks.
.Sp
The first argument for callbacks registered with the \f(CW\*(C`reg_cb\*(C'\fR function will
always be the master object \f(CW$obj\fR.
.Sp
The return value of the callbacks are ignored. If you need to pass
any information from a handler to the caller of the event you have to
establish your own \*(L"protocol\*(R" to do this. I recommend to pass an array
reference to the handlers:
.Sp
.Vb 4
\&   $obj\->reg_cb (event_foobar => sub {
\&      my ($self, $results) = @_;
\&      push @$results, time / 30;
\&   });
\&
\&   my @results;
\&   $obj\->event (event_foobar => \e@results);
\&   for (@results) {
\&      # ...
\&   }
.Ve
.Sp
The order of the callbacks in the call chain of the event depends on their
priority. If you didn't specify any priority (see below) they get the default
priority of 0, and are appended to the other priority 0 callbacks.
The higher the priority number, the earlier the callbacks gets called in the chain.
.Sp
If \f(CW$eventname1\fR starts with \f(CW\*(Aqbefore_\*(Aq\fR the callback gets a priority
of 1000, and if it starts with \f(CW\*(Aqext_before_\*(Aq\fR it gets the priority 500.
\&\f(CW\*(Aqafter_\*(Aq\fR is mapped to the priority \-1000 and \f(CW\*(Aqext_after_\*(Aq\fR to \-500.
.Sp
If you want more fine grained control you can pass an array reference
instead of the event name:
.Sp
.Vb 4
\&   ($eventname1, $prio) = (\*(Aqtest_abc\*(Aq, 100);
\&   $obj\->reg_cb ([$eventname1, $prio] => sub {
\&      ...
\&   });
.Ve
.ie n .IP "$obj\->unreg_cb ($cb)" 4
.el .IP "\f(CW$obj\fR\->unreg_cb ($cb)" 4
.IX Item "$obj->unreg_cb ($cb)"
Removes the callback \f(CW$cb\fR from the set of registered callbacks.
.ie n .IP "my $handled = $obj\->event ($eventname, @args)" 4
.el .IP "my \f(CW$handled\fR = \f(CW$obj\fR\->event ($eventname, \f(CW@args\fR)" 4
.IX Item "my $handled = $obj->event ($eventname, @args)"
Emits the event \f(CW$eventname\fR and passes the arguments \f(CW@args\fR to the
callbacks. The return value \f(CW$handled\fR is a true value in case some handler
was found and run. It returns false if no handler was found (see also the
\&\f(CW\*(C`handles\*(C'\fR method below). Basically: It returns the same value as the
\&\f(CW\*(C`handles\*(C'\fR method.
.Sp
Please note that an event can be stopped and reinvoked while it is being
handled.
.Sp
See also the specification of the before and after events in \f(CW\*(C`reg_cb\*(C'\fR above.
.Sp
\&\s-1NOTE:\s0 Whenever an event is emitted the current set of callbacks registered
to that event will be used. So, if you register another event callback for the
same event that is executed at the moment, it will be called the \fBnext\fR time 
when the event is emitted. Example:
.Sp
.Vb 2
\&   $obj\->reg_cb (event_test => sub {
\&      my ($obj) = @_;
\&
\&      print "Test1\en";
\&      $obj\->unreg_me;
\&
\&      $obj\->reg_cb (event_test => sub {
\&         my ($obj) = @_;
\&         print "Test2\en";
\&         $obj\->unreg_me;
\&      });
\&   });
\&
\&   $obj\->event (\*(Aqevent_test\*(Aq); # prints "Test1"
\&   $obj\->event (\*(Aqevent_test\*(Aq); # prints "Test2"
.Ve
.ie n .IP "my $bool = $obj\->handles ($eventname)" 4
.el .IP "my \f(CW$bool\fR = \f(CW$obj\fR\->handles ($eventname)" 4
.IX Item "my $bool = $obj->handles ($eventname)"
This method returns true if any event handler has been setup for
the event \f(CW$eventname\fR.
.Sp
It returns false if that is not the case.
.ie n .IP "$obj\->event_name" 4
.el .IP "\f(CW$obj\fR\->event_name" 4
.IX Item "$obj->event_name"
Returns the name of the currently executed event.
.ie n .IP "$obj\->unreg_me" 4
.el .IP "\f(CW$obj\fR\->unreg_me" 4
.IX Item "$obj->unreg_me"
Unregisters the currently executed callback.
.ie n .IP "$continue_cb = $obj\->stop_event" 4
.el .IP "\f(CW$continue_cb\fR = \f(CW$obj\fR\->stop_event" 4
.IX Item "$continue_cb = $obj->stop_event"
This method stops the execution of callbacks of the current
event, and returns (in non-void context) a callback that will
let you continue the execution.
.ie n .IP "$obj\->add_forward ($obj, $cb)" 4
.el .IP "\f(CW$obj\fR\->add_forward ($obj, \f(CW$cb\fR)" 4
.IX Item "$obj->add_forward ($obj, $cb)"
\&\fB\s-1DEPRECATED:\s0 Don't use it!\fR Just for backward compatibility for AnyEvent::XMPP
version 0.4.
.ie n .IP "$obj\->remove_forward ($obj)" 4
.el .IP "\f(CW$obj\fR\->remove_forward ($obj)" 4
.IX Item "$obj->remove_forward ($obj)"
\&\fB\s-1DEPRECATED:\s0 Don't use it!\fR Just for backward compatibility for AnyEvent::XMPP
version 0.4.
.ie n .IP "$obj\->remove_all_callbacks ()" 4
.el .IP "\f(CW$obj\fR\->remove_all_callbacks ()" 4
.IX Item "$obj->remove_all_callbacks ()"
This method removes all registered event callbacks from this object.
.ie n .IP "$obj\->events_as_string_dump ()" 4
.el .IP "\f(CW$obj\fR\->events_as_string_dump ()" 4
.IX Item "$obj->events_as_string_dump ()"
This method returns a string dump of all registered event callbacks.
This method is only for debugging purposes.
.SH "EVENT METHODS"
.IX Header "EVENT METHODS"
You can define static methods in a package that act as event handler.
This is done by using Perl's attributes functionality. To make
a method act as event handler you need to add the \f(CW\*(C`event_cb\*(C'\fR attribute
to it.
.PP
\&\fB\s-1NOTE:\s0\fR Please note that for this to work the methods need to be defined at
compile time. This means that you are not able to add event handles using
\&\f(CW\*(C`AUTOLOAD\*(C'\fR!
.PP
\&\fB\s-1NOTE:\s0\fR Perl's attributes have a very basic syntax, you have to take
care to not insert any whitespace, the attribute must be a single
string that contains no whitespace. That means: \f(CW\*(C`event_cb (1)\*(C'\fR is not the
same as \f(CWevent_cb(1)\fR!
.PP
Here is an example:
.PP
.Vb 2
\&   package foo;
\&   use base qw/Object::Event/;
\&
\&   sub test : event_cb { print "test event handler!\en" }
\&
\&   package main;
\&   my $o = foo\->new;
\&   $o\->test ();        # prints \*(Aqtest event handler!\*(Aq
\&   $o\->event (\*(Aqtest\*(Aq); # also prints \*(Aqtest event handler!\*(Aq!
.Ve
.PP
In case you want to set a priority use this syntax:
.PP
.Vb 1
\&   sub test : event_cb(\-1000) { ... }
.Ve
.PP
Or:
.PP
.Vb 1
\&   sub test : event_cb(after) { ... }
.Ve
.PP
You may want to have a look at the tests of the Object::Event
distribution for more examples.
.SS "\s-1ALIASES\s0"
.IX Subsection "ALIASES"
If you want to define multiple event handlers as package method
you can use the \f(CW\*(C`event_cb\*(C'\fR attribute with an additional argument:
.PP
.Vb 2
\&   package foo;
\&   use base qw/Object::Event/;
\&
\&   sub test : event_cb { # default prio is always 0
\&      print "middle\en";
\&   }
\&
\&   sub test_last : event_cb(\-1,test) {
\&      print "after\en";
\&   }
\&
\&   sub test_first : event_cb(1,test) {
\&      print "before\en";
\&   }
\&
\&   package main;
\&   my $o = foo\->new;
\&   $o\->test ();        # prints "after\en" "middle\en" "before\en"
\&   $o\->event (\*(Aqtest\*(Aq); # prints the same
\&   $o\->test_first ();  # also prints the same
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR Please note that if you don't provide any order the methods
are sorted \fIalphabetically\fR:
.PP
.Vb 2
\&   package foo;
\&   use base qw/Object::Event/;
\&
\&   sub test : event_cb { # default prio is always 0
\&      print "middle\en";
\&   }
\&
\&   sub x : event_cb(, test) { # please note the empty element before the \*(Aq,\*(Aq! 
\&      print "after\en";
\&   }
\&
\&   sub a : event_cb(, test) {
\&      print "before\en";
\&   }
\&
\&   package main;
\&   my $o = foo\->new;
\&   $o\->test ();        # prints "after\en" "middle\en" "before\en"
\&   $o\->event (\*(Aqtest\*(Aq); # prints the same
\&   $o\->x ();           # also prints the same
.Ve
.SS "\s-1ALIAS ORDERING\s0"
.IX Subsection "ALIAS ORDERING"
The ordering of how the methods event handlers are called if they
are all defined for the same event is strictly defined:
.IP "1." 4
Ordering of the methods for the same event in the inheritance hierarchy
is always dominated by the priority of the event callback.
.IP "2." 4
Then if there are multiple methods with the same priority the place in the
inheritance hierarchy defines in which order the methods are executed. The
higher up in the hierarchy the class is, the earlier it will be called.
.IP "3." 4
Inside a class the name of the method for the event decides which event is
executed first. (All if the priorities are the same)
.SH "DEBUGGING"
.IX Header "DEBUGGING"
There exists a package global variable called \f(CW$DEBUG\fR that control debugging
capabilities.
.PP
Set it to 1 to produce a slightly extended \f(CW\*(C`events_as_string_dump\*(C'\fR output.
.PP
Set it to 2 and all events will be dumped in a tree of event invocations.
.PP
You can set the variable either in your main program:
.PP
.Vb 1
\&   $Object::Event::DEBUG = 2;
.Ve
.PP
Or use the environment variable \f(CW\*(C`PERL_OBJECT_EVENT_DEBUG\*(C'\fR:
.PP
.Vb 1
\&   export PERL_OBJECT_EVENT_DEBUG=2
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Redeker, \f(CW\*(C`<elmex at ta\-sa.org>\*(C'\fR, \s-1JID:\s0 \f(CW\*(C`<elmex at jabber.org>\*(C'\fR
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Object::Event
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Object\-Event>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Object\-Event>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Object\-Event>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Object\-Event>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks go to:
.PP
.Vb 2
\&  \- Mons Anderson for suggesting the \*(Aqhandles\*(Aq method and
\&    the return value of the \*(Aqevent\*(Aq method and reporting bugs.
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009\-2011 Robin Redeker, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
