.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::SSH::Perl::Util 3"
.TH Net::SSH::Perl::Util 3 2023-08-07 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Net::SSH::Perl::Util \- Shared utility functions
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::SSH::Perl::Util qw( ... );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\fINet::SSH::Perl::Util\fR contains a variety of exportable utility
functions used by the various \fINet::SSH::Perl\fR modules. These
range from hostfile routines, to RSA encryption routines, etc.
.PP
None of the routines are actually stored in the \fIUtil\fR module
itself; they are contained within sub-modules that are loaded
on demand by the parent \fIUtil\fR module, which contains a
table mapping function names to sub-module names. The "on
demand" is done by including either a function name, or a tag
name (see below), in your \fIuse\fR line. \fINet::SSH::Perl::Util\fR
will take care of loading the sub-module and importing the
requested function(s) into your namespace.
.PP
The routines are exportable by themselves, ie.
.PP
.Vb 1
\&    use Net::SSH::Perl::Util qw( routine_name );
.Ve
.PP
In addition, some of the routines are grouped into bundles that
you can pull in by export tag, ie.
.PP
.Vb 1
\&    use Net::SSH::Perl::Util qw( :bundle );
.Ve
.PP
The groups are:
.IP \(bu 4
hosts
.Sp
Routines associated with hostfile-checking, addition, etc.
Contains \f(CW\*(C`_check_host_in_hostfile\*(C'\fR and \f(CW\*(C`_add_host_to_hosfile\*(C'\fR.
.IP \(bu 4
rsa
.Sp
Routines associated with RSA encryption, decryption, and
authentication. Contains \f(CW\*(C`_rsa_public_encrypt\*(C'\fR,
\&\f(CW\*(C`_rsa_private_decrypt\*(C'\fR, and \f(CW\*(C`_respond_to_rsa_challenge\*(C'\fR.
.IP \(bu 4
ssh1mp
.Sp
Routines associated with multiple-precision integers and the
generation and manipulation of same. Contains \f(CW\*(C`_mp_linearize\*(C'\fR
and \f(CW\*(C`_compute_session_id\*(C'\fR.
.Sp
Because the SSH1 implementation uses \fIMath::GMP\fR for its
big integers, the functions in \fIssh1mp\fR all deal with
\&\fIMath::GMP\fR objects.
.IP \(bu 4
authfile
.Sp
Routines associated with loading of RSA SSH1 keys (both public
and private) from keyfiles. Contains \f(CW\*(C`_load_public_key\*(C'\fR,
\&\f(CW\*(C`_load_private_key\*(C'\fR, and \f(CW\*(C`_save_private_key\*(C'\fR.
.Sp
Note that this interface is deprecated in favor of the
\&\fINet::SSH::Perl::Key\fR interface to loading keys.
.IP \(bu 4
all
.Sp
All routines. Contains all of the routines listed below.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.SS _crc32($data)
.IX Subsection "_crc32($data)"
Returns a CRC32 checksum of \fR\f(CI$data\fR\fI\fR. This uses \fIString::CRC32\fR
internally to do its magic, with the caveat that the "init state"
of the checksum is \f(CW0xFFFFFFFF\fR, and the result is xor-ed with
\&\f(CW0xFFFFFFFF\fR.
.PP
This is used in SSH1.
.ie n .SS "_compute_session_id($check_bytes, $host_key, $public_key)"
.el .SS "_compute_session_id($check_bytes, \f(CW$host_key\fP, \f(CW$public_key\fP)"
.IX Subsection "_compute_session_id($check_bytes, $host_key, $public_key)"
Given the check bytes (\fR\f(CI$check_bytes\fR\fI\fR) and the server host and
public keys (\fI\fR\f(CI$host_key\fR\fI\fR and \fI\fR\f(CI$public_key\fR\fI\fR, respectively),
computes the session ID that is then used to uniquely identify
the session between the server and client.
.PP
\&\fR\f(CI$host_key\fR\fI\fR and \fI\fR\f(CI$public_key\fR\fI\fR should be \fINet::SSH::Perl::Key::RSA1\fR
objects; \fI\fR\f(CI$check_bytes\fR\fI\fR is an 8\-byte string.
.PP
Returns the session ID.
.SS _mp_linearize($int)
.IX Subsection "_mp_linearize($int)"
Converts a multiple-precision integer \fR\f(CI$int\fR\fI\fR into a byte string.
\&\fI\fR\f(CI$int\fR\fI\fR should be a \fIMath::GMP\fR object.
.PP
Returns the byte string.
.ie n .SS "_check_host_in_hostfile($host, $host_file, $host_key)"
.el .SS "_check_host_in_hostfile($host, \f(CW$host_file\fP, \f(CW$host_key\fP)"
.IX Subsection "_check_host_in_hostfile($host, $host_file, $host_key)"
Looks up \fR\f(CI$host\fR\fI\fR in \fI\fR\f(CI$host_file\fR\fI\fR and checks the stored host
key against \fI\fR\f(CI$host_key\fR\fI\fR to determine the status of the host.
.PP
\&\fR\f(CI$host_key\fR\fI\fR should be an object of some subclass of
\&\fINet::SSH::Perl::Key\fR; in particular, it must support the
\&\fIextract_public\fR class method and the \fIequal\fR object
method.
.PP
If the host is not found, returns HOST_NEW.
.PP
If the host is found, and the keys match, returns HOST_OK.
.PP
If the host is found, and the keys don't match, returns
HOST_CHANGED, which generally indicates a security problem
(ie. man-in-the-middle attack).
.ie n .SS "_add_host_to_hostfile($host, $host_file, $host_key)"
.el .SS "_add_host_to_hostfile($host, \f(CW$host_file\fP, \f(CW$host_key\fP)"
.IX Subsection "_add_host_to_hostfile($host, $host_file, $host_key)"
Opens up the known hosts file \fR\f(CI$host_file\fR\fI\fR and adds an
entry for \fI\fR\f(CI$host\fR\fI\fR with host key \fI\fR\f(CI$host_key\fR\fI\fR. Dies if
\&\fI\fR\f(CI$host_file\fR\fI\fR can't be opened for writing.
.PP
\&\fR\f(CI$host_key\fR\fI\fR should be an object of some subclass of
\&\fINet::SSH::Perl::Key\fR; in particular, it must support the
\&\fIdump_public\fR object method.
.SS _load_public_key($key_file)
.IX Subsection "_load_public_key($key_file)"
Given the location of a public key file \fR\f(CI$key_file\fR\fI\fR, reads
the RSA public key from that file.
.PP
If called in list context, returns the key and the comment
associated with the key. If called in scalar context,
returns only the key.
.PP
Dies if: the key file \fR\f(CI$key_file\fR\fI\fR can't be opened for
reading; or the key file is "bad" (the ID string in the
file doesn't match the PRIVATE_KEY_ID_STRING constant).
.PP
Returns the RSA key (a \fINet::SSH::Perl::Key::RSA1\fR object).
.ie n .SS "_load_private_key($key_file [, $passphrase ])"
.el .SS "_load_private_key($key_file [, \f(CW$passphrase\fP ])"
.IX Subsection "_load_private_key($key_file [, $passphrase ])"
Given the location of a private key file \fR\f(CI$key_file\fR\fI\fR,
and an optional passphrase to decrypt the key, reads the
private key from that file. If \fI\fR\f(CI$passphrase\fR\fI\fR is not
supplied, an empty passphrase (the empty string) is tried
instead.
.PP
If called in list context, returns the key and the comment
associated with the key. If called in scalar context,
returns only the key.
.PP
Dies if: the key file \fR\f(CI$key_file\fR\fI\fR can't be opened for
reading; the key file is "bad" (the ID string in the file
doesn't match the PRIVATE_KEY_ID_STRING constant); the
file is encrypted using an unsupported encryption cipher;
or the passphrase \fI\fR\f(CI$passphrase\fR\fI\fR is incorrect.
.PP
Returns the RSA key (a \fINet::SSH::Perl::Key::RSA1\fR object).
.ie n .SS "_save_private_key($key_file, $key, [ $passphrase [, $comment ]])"
.el .SS "_save_private_key($key_file, \f(CW$key\fP, [ \f(CW$passphrase\fP [, \f(CW$comment\fP ]])"
.IX Subsection "_save_private_key($key_file, $key, [ $passphrase [, $comment ]])"
Given a private key \fR\f(CI$key\fR\fI\fR, and the location of the private
key file \fI\fR\f(CI$key_file\fR\fI\fR, writes out an SSH1 RSA key file to
\&\fI\fR\f(CI$key_file\fR\fI\fR.
.PP
If \fR\f(CI$passphrase\fR\fI\fR is supplied, the private key portion of
the file is encrypted with \fI3DES\fR encryption, using the
passphrase \fI\fR\f(CI$passphrase\fR\fI\fR. If the passphrase is not supplied,
an empty passphrase will be used instead. This is useful
when using RSA authentication in a non-interactive process,
for example.
.PP
\&\fR\f(CI$comment\fR\fI\fR is an optional string that, if supplied, is
inserted into the key file and can be used by clients when
prompting for the passphrase upon loading the private key,
etc. It should be somewhat descriptive of this key file.
.PP
\&\fR\f(CI$key\fR\fI\fR should be a \fINet::SSH::Perl::Key::RSA1\fR object.
.ie n .SS "_prompt($prompt [, $default [, $echo ]])"
.el .SS "_prompt($prompt [, \f(CW$default\fP [, \f(CW$echo\fP ]])"
.IX Subsection "_prompt($prompt [, $default [, $echo ]])"
Emits an interactive prompt \fR\f(CI$prompt\fR\fI\fR with an optional
default \fI\fR\f(CI$default\fR\fI\fR. If \fI\fR\f(CI$echo\fR\fI\fR is true, reads normally
from \fISTDIN\fR; if \fI\fR\f(CI$echo\fR\fI\fR is false, calls
\&\fI_read_passphrase\fR internally to read sensitive
information with echo off.
.PP
Returns the user's answer to the prompt, \fR\f(CI$default\fR\fI\fR if
no answer was provided.
.SS _read_passphrase($prompt)
.IX Subsection "_read_passphrase($prompt)"
Uses \fITerm::ReadKey\fR with echo off to read a passphrase,
after issuing the prompt \fR\f(CI$prompt\fR\fI\fR. Echo is restored
once the passphrase has been read.
.SS _read_yes_or_no($prompt)
.IX Subsection "_read_yes_or_no($prompt)"
Issues the prompt \fR\f(CI$prompt\fR\fI\fR, which should be a yes/no
question; then reads the response, and returns true if the
response is yes (or rather, anything starting with 'y',
case insensitive).
.ie n .SS "_respond_to_rsa_challenge($ssh, $challenge, $key)"
.el .SS "_respond_to_rsa_challenge($ssh, \f(CW$challenge\fP, \f(CW$key\fP)"
.IX Subsection "_respond_to_rsa_challenge($ssh, $challenge, $key)"
Decrypts the RSA challenge \fR\f(CI$challenge\fR\fI\fR using \fI\fR\f(CI$key\fR\fI\fR,
then the response (MD5 of decrypted challenge and session
ID) to the server, using the \fI\fR\f(CI$ssh\fR\fI\fR object, in an
RSA response packet.
.ie n .SS "_rsa_public_encrypt($data, $key)"
.el .SS "_rsa_public_encrypt($data, \f(CW$key\fP)"
.IX Subsection "_rsa_public_encrypt($data, $key)"
Encrypts the multiple-precision integer \fR\f(CI$data\fR\fI\fR (a
\&\fIMath::GMP\fR object) using \fI\fR\f(CI$key\fR\fI\fR.
.PP
Returns the encrypted data, also a \fIMath::GMP\fR object.
.ie n .SS "_rsa_private_decrypt($data, $key)"
.el .SS "_rsa_private_decrypt($data, \f(CW$key\fP)"
.IX Subsection "_rsa_private_decrypt($data, $key)"
Decrypts the multiple-precision integer \fR\f(CI$data\fR\fI\fR (a
\&\fIMath::GMP\fR object) using \fI\fR\f(CI$key\fR\fI\fR.
.PP
Returns the decrypted data, also a \fIMath::GMP\fR object.
.SH "AUTHOR & COPYRIGHTS"
.IX Header "AUTHOR & COPYRIGHTS"
Please see the Net::SSH::Perl manpage for author, copyright,
and license information.
