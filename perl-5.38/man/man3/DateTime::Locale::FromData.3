.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DateTime::Locale::FromData 3"
.TH DateTime::Locale::FromData 3 2023-11-04 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DateTime::Locale::FromData \- Class for locale objects instantiated from pre\-defined data
.SH VERSION
.IX Header "VERSION"
version 1.40
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  my $locale = DateTime::Locale::FromData\->new(%lots_of_data)
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This class is used to represent locales instantiated from the data in the
DateTime::Locale::Data module.
.SH METHODS
.IX Header "METHODS"
This class provides the following methods:
.ie n .SS $locale\->code
.el .SS \f(CW$locale\fP\->code
.IX Subsection "$locale->code"
The complete locale id, something like "en-US".
.ie n .SS $locale\->language_code
.el .SS \f(CW$locale\fP\->language_code
.IX Subsection "$locale->language_code"
The language portion of the code, like "en".
.ie n .SS $locale\->script_code
.el .SS \f(CW$locale\fP\->script_code
.IX Subsection "$locale->script_code"
The script portion of the code, like "Hant".
.ie n .SS $locale\->territory_code
.el .SS \f(CW$locale\fP\->territory_code
.IX Subsection "$locale->territory_code"
The territory portion of the code, like "US".
.ie n .SS $locale\->variant_code
.el .SS \f(CW$locale\fP\->variant_code
.IX Subsection "$locale->variant_code"
The variant portion of the code, like "POSIX".
.ie n .SS $locale\->name
.el .SS \f(CW$locale\fP\->name
.IX Subsection "$locale->name"
The locale's complete name, which always includes at least a language
component, plus optional territory and variant components. Something like
"English United States". The value returned will always be in English.
.ie n .SS $locale\->language
.el .SS \f(CW$locale\fP\->language
.IX Subsection "$locale->language"
.ie n .SS $locale\->script
.el .SS \f(CW$locale\fP\->script
.IX Subsection "$locale->script"
.ie n .SS $locale\->territory
.el .SS \f(CW$locale\fP\->territory
.IX Subsection "$locale->territory"
.ie n .SS $locale\->variant
.el .SS \f(CW$locale\fP\->variant
.IX Subsection "$locale->variant"
The relevant component from the locale's complete name, like "English" or
"United States".
.ie n .SS $locale\->native_name
.el .SS \f(CW$locale\fP\->native_name
.IX Subsection "$locale->native_name"
The locale's complete name in localized form as a UTF\-8 string.
.ie n .SS $locale\->native_language
.el .SS \f(CW$locale\fP\->native_language
.IX Subsection "$locale->native_language"
.ie n .SS $locale\->native_script
.el .SS \f(CW$locale\fP\->native_script
.IX Subsection "$locale->native_script"
.ie n .SS $locale\->native_territory
.el .SS \f(CW$locale\fP\->native_territory
.IX Subsection "$locale->native_territory"
.ie n .SS $locale\->native_variant
.el .SS \f(CW$locale\fP\->native_variant
.IX Subsection "$locale->native_variant"
The relevant component from the locale's complete native name as a UTF\-8
string.
.ie n .SS $locale\->month_format_wide
.el .SS \f(CW$locale\fP\->month_format_wide
.IX Subsection "$locale->month_format_wide"
.ie n .SS $locale\->month_format_abbreviated
.el .SS \f(CW$locale\fP\->month_format_abbreviated
.IX Subsection "$locale->month_format_abbreviated"
.ie n .SS $locale\->month_format_narrow
.el .SS \f(CW$locale\fP\->month_format_narrow
.IX Subsection "$locale->month_format_narrow"
.ie n .SS $locale\->month_stand_alone_wide
.el .SS \f(CW$locale\fP\->month_stand_alone_wide
.IX Subsection "$locale->month_stand_alone_wide"
.ie n .SS $locale\->month_stand_alone_abbreviated
.el .SS \f(CW$locale\fP\->month_stand_alone_abbreviated
.IX Subsection "$locale->month_stand_alone_abbreviated"
.ie n .SS $locale\->month_stand_alone_narrow
.el .SS \f(CW$locale\fP\->month_stand_alone_narrow
.IX Subsection "$locale->month_stand_alone_narrow"
.ie n .SS $locale\->day_format_wide
.el .SS \f(CW$locale\fP\->day_format_wide
.IX Subsection "$locale->day_format_wide"
.ie n .SS $locale\->day_format_abbreviated
.el .SS \f(CW$locale\fP\->day_format_abbreviated
.IX Subsection "$locale->day_format_abbreviated"
.ie n .SS $locale\->day_format_narrow
.el .SS \f(CW$locale\fP\->day_format_narrow
.IX Subsection "$locale->day_format_narrow"
.ie n .SS $locale\->day_stand_alone_wide
.el .SS \f(CW$locale\fP\->day_stand_alone_wide
.IX Subsection "$locale->day_stand_alone_wide"
.ie n .SS $locale\->day_stand_alone_abbreviated
.el .SS \f(CW$locale\fP\->day_stand_alone_abbreviated
.IX Subsection "$locale->day_stand_alone_abbreviated"
.ie n .SS $locale\->day_stand_alone_narrow
.el .SS \f(CW$locale\fP\->day_stand_alone_narrow
.IX Subsection "$locale->day_stand_alone_narrow"
.ie n .SS $locale\->quarter_format_wide
.el .SS \f(CW$locale\fP\->quarter_format_wide
.IX Subsection "$locale->quarter_format_wide"
.ie n .SS $locale\->quarter_format_abbreviated
.el .SS \f(CW$locale\fP\->quarter_format_abbreviated
.IX Subsection "$locale->quarter_format_abbreviated"
.ie n .SS $locale\->quarter_format_narrow
.el .SS \f(CW$locale\fP\->quarter_format_narrow
.IX Subsection "$locale->quarter_format_narrow"
.ie n .SS $locale\->quarter_stand_alone_wide
.el .SS \f(CW$locale\fP\->quarter_stand_alone_wide
.IX Subsection "$locale->quarter_stand_alone_wide"
.ie n .SS $locale\->quarter_stand_alone_abbreviated
.el .SS \f(CW$locale\fP\->quarter_stand_alone_abbreviated
.IX Subsection "$locale->quarter_stand_alone_abbreviated"
.ie n .SS $locale\->quarter_stand_alone_narrow
.el .SS \f(CW$locale\fP\->quarter_stand_alone_narrow
.IX Subsection "$locale->quarter_stand_alone_narrow"
.ie n .SS $locale\->am_pm_abbreviated
.el .SS \f(CW$locale\fP\->am_pm_abbreviated
.IX Subsection "$locale->am_pm_abbreviated"
.ie n .SS $locale\->era_wide
.el .SS \f(CW$locale\fP\->era_wide
.IX Subsection "$locale->era_wide"
.ie n .SS $locale\->era_abbreviated
.el .SS \f(CW$locale\fP\->era_abbreviated
.IX Subsection "$locale->era_abbreviated"
.ie n .SS $locale\->era_narrow
.el .SS \f(CW$locale\fP\->era_narrow
.IX Subsection "$locale->era_narrow"
These methods all return an array reference containing the specified data.
.PP
The methods with "format" in the name should return strings that can be used a
part of a string, like "the month of July". The stand alone values are for use
in things like calendars as opposed to a sentence.
.PP
The narrow forms may not be unique (for example, in the day column heading for
a calendar it's okay to have "T" for both Tuesday and Thursday).
.PP
The wide name should always be the full name of thing in question. The narrow
name should be just one or two characters.
.PP
\&\fBThese methods return a reference to the data stored in the locale object. If
you change this reference's contents, this will affect the data in the locale
object! You should clone the data first if you want to modify it.\fR
.ie n .SS $locale\->date_format_full
.el .SS \f(CW$locale\fP\->date_format_full
.IX Subsection "$locale->date_format_full"
.ie n .SS $locale\->date_format_long
.el .SS \f(CW$locale\fP\->date_format_long
.IX Subsection "$locale->date_format_long"
.ie n .SS $locale\->date_format_medium
.el .SS \f(CW$locale\fP\->date_format_medium
.IX Subsection "$locale->date_format_medium"
.ie n .SS $locale\->date_format_short
.el .SS \f(CW$locale\fP\->date_format_short
.IX Subsection "$locale->date_format_short"
.ie n .SS $locale\->time_format_full
.el .SS \f(CW$locale\fP\->time_format_full
.IX Subsection "$locale->time_format_full"
.ie n .SS $locale\->time_format_long
.el .SS \f(CW$locale\fP\->time_format_long
.IX Subsection "$locale->time_format_long"
.ie n .SS $locale\->time_format_medium
.el .SS \f(CW$locale\fP\->time_format_medium
.IX Subsection "$locale->time_format_medium"
.ie n .SS $locale\->time_format_short
.el .SS \f(CW$locale\fP\->time_format_short
.IX Subsection "$locale->time_format_short"
.ie n .SS $locale\->datetime_format_full
.el .SS \f(CW$locale\fP\->datetime_format_full
.IX Subsection "$locale->datetime_format_full"
.ie n .SS $locale\->datetime_format_long
.el .SS \f(CW$locale\fP\->datetime_format_long
.IX Subsection "$locale->datetime_format_long"
.ie n .SS $locale\->datetime_format_medium
.el .SS \f(CW$locale\fP\->datetime_format_medium
.IX Subsection "$locale->datetime_format_medium"
.ie n .SS $locale\->datetime_format_short
.el .SS \f(CW$locale\fP\->datetime_format_short
.IX Subsection "$locale->datetime_format_short"
These methods return strings appropriate for the \f(CW\*(C`DateTime\->format_cldr\*(C'\fR
method.
.ie n .SS $locale\->format_for($name)
.el .SS \f(CW$locale\fP\->format_for($name)
.IX Subsection "$locale->format_for($name)"
These are accessed by passing a name to \f(CW\*(C`$locale\->format_for(...)\*(C'\fR, where
the name is a CLDR-style format specifier.
.PP
The return value is a string suitable for passing to \f(CW\*(C`$dt\->format_cldr\*(C'\fR,
so you can do something like this:
.PP
.Vb 1
\&  print $dt\->format_cldr( $dt\->locale\->format_for(\*(AqMMMdd\*(Aq) )
.Ve
.PP
which for the "en" locale would print out something like "08 Jul".
.PP
Note that the localization may also include additional text specific to the
locale. For example, the "MMMMd" format for the "zh" locale includes the
Chinese characters for "day" (日) and month (月), so you get something like
"8月23日".
.ie n .SS $locale\->available_formats
.el .SS \f(CW$locale\fP\->available_formats
.IX Subsection "$locale->available_formats"
This should return a list of all the format names that could be passed to \f(CW\*(C`$locale\->format_for\*(C'\fR.
.PP
See the documentation for individual locales for details and examples of these
formats. The format names that are available vary by locale.
.ie n .SS $locale\->glibc_datetime_format
.el .SS \f(CW$locale\fP\->glibc_datetime_format
.IX Subsection "$locale->glibc_datetime_format"
.ie n .SS $locale\->glibc_date_format
.el .SS \f(CW$locale\fP\->glibc_date_format
.IX Subsection "$locale->glibc_date_format"
.ie n .SS $locale\->glibc_date_1_format
.el .SS \f(CW$locale\fP\->glibc_date_1_format
.IX Subsection "$locale->glibc_date_1_format"
.ie n .SS $locale\->glibc_time_format
.el .SS \f(CW$locale\fP\->glibc_time_format
.IX Subsection "$locale->glibc_time_format"
.ie n .SS $locale\->glibc_time_12_format
.el .SS \f(CW$locale\fP\->glibc_time_12_format
.IX Subsection "$locale->glibc_time_12_format"
These methods return strings appropriate for the \f(CW\*(C`DateTime\->strftime\*(C'\fR
method. However, you are strongly encouraged to use the other format methods,
which use the CLDR format data. They are primarily included for the benefit for
DateTime::Format::Strptime.
.ie n .SS $locale\->version
.el .SS \f(CW$locale\fP\->version
.IX Subsection "$locale->version"
The CLDR version from which this locale was generated.
.ie n .SS $locale\->prefers_24_hour_time
.el .SS \f(CW$locale\fP\->prefers_24_hour_time
.IX Subsection "$locale->prefers_24_hour_time"
Returns a boolean indicating whether or not the locale prefers 24\-hour time.
.ie n .SS $locale\->first_day_of_week
.el .SS \f(CW$locale\fP\->first_day_of_week
.IX Subsection "$locale->first_day_of_week"
Returns a number from 1 to 7 indicating the \fIlocal\fR first day of the week,
with Monday being 1 and Sunday being 7.
.ie n .SS $locale\->locale_data
.el .SS \f(CW$locale\fP\->locale_data
.IX Subsection "$locale->locale_data"
Returns a clone of the original data used to create this locale as a hash. This
is here to facilitate creating custom locales via
\&\f(CW\*(C`DateTime::Locale\-\*(C'\fRregister_data_locale>.
.SH SUPPORT
.IX Header "SUPPORT"
Bugs may be submitted at <https://github.com/houseabsolute/DateTime\-Locale/issues>.
.PP
There is a mailing list available for users of this distribution,
<mailto:datetime@perl.org>.
.SH SOURCE
.IX Header "SOURCE"
The source code repository for DateTime-Locale can be found at <https://github.com/houseabsolute/DateTime\-Locale>.
.SH AUTHOR
.IX Header "AUTHOR"
Dave Rolsky <autarch@urth.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2003 \- 2023 by Dave Rolsky.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.PP
The full text of the license can be found in the
\&\fILICENSE\fR file included with this distribution.
