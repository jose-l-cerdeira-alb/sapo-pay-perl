.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Interrupt 3"
.TH Interrupt 3 2020-04-27 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Async::Interrupt \- allow C/XS libraries to interrupt perl asynchronously
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& use Async::Interrupt;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module implements a single feature only of interest to advanced perl
modules, namely asynchronous interruptions (think "UNIX signals", which
are very similar).
.PP
Sometimes, modules wish to run code asynchronously (in another thread,
or from a signal handler), and then signal the perl interpreter on
certain events. One common way is to write some data to a pipe and use an
event handling toolkit to watch for I/O events. Another way is to send
a signal. Those methods are slow, and in the case of a pipe, also not
asynchronous \- it won't interrupt a running perl interpreter.
.PP
This module implements asynchronous notifications that enable you to
signal running perl code from another thread, asynchronously, and
sometimes even without using a single syscall.
.SS "USAGE SCENARIOS"
.IX Subsection "USAGE SCENARIOS"
.IP "Race-free signal handling" 4
.IX Item "Race-free signal handling"
There seems to be no way to do race-free signal handling in perl: to
catch a signal, you have to execute Perl code, and between entering the
interpreter \f(CW\*(C`select\*(C'\fR function (or other blocking functions) and executing
the select syscall is a small but relevant timespan during which signals
will be queued, but perl signal handlers will not be executed and the
blocking syscall will not be interrupted.
.Sp
You can use this module to bind a signal to a callback while at the same
time activating an event pipe that you can \f(CW\*(C`select\*(C'\fR on, fixing the race
completely.
.Sp
This can be used to implement the signal handling in event loops,
e.g. AnyEvent, POE, IO::Async::Loop and so on.
.IP "Background threads want speedy reporting" 4
.IX Item "Background threads want speedy reporting"
Assume you want very exact timing, and you can spare an extra cpu core
for that. Then you can run an extra thread that signals your perl
interpreter. This means you can get a very exact timing source while your
perl code is number crunching, without even using a syscall to communicate
between your threads.
.Sp
For example the deliantra game server uses a variant of this technique
to interrupt background processes regularly to send map updates to game
clients.
.Sp
Or EV::Loop::Async uses an interrupt object to wake up perl when new
events have arrived.
.Sp
IO::AIO and BDB could also use this to speed up result reporting.
.IP "Speedy event loop invocation" 4
.IX Item "Speedy event loop invocation"
One could use this module e.g. in Coro to interrupt a running coro-thread
and cause it to enter the event loop.
.Sp
Or one could bind to \f(CW\*(C`SIGIO\*(C'\fR and tell some important sockets to send this
signal, causing the event loop to be entered to reduce network latency.
.SS "HOW TO USE"
.IX Subsection "HOW TO USE"
You can use this module by creating an \f(CW\*(C`Async::Interrupt\*(C'\fR object for each
such event source. This object stores a perl and/or a C\-level callback
that is invoked when the \f(CW\*(C`Async::Interrupt\*(C'\fR object gets signalled. It is
executed at the next time the perl interpreter is running (i.e. it will
interrupt a computation, but not an XS function or a syscall).
.PP
You can signal the \f(CW\*(C`Async::Interrupt\*(C'\fR object either by calling it's \f(CW\*(C`\->signal\*(C'\fR method, or, more commonly, by calling a C function. There is
also the built-in (POSIX) signal source.
.PP
The \f(CW\*(C`\->signal_func\*(C'\fR returns the address of the C function that is to
be called (plus an argument to be used during the call). The signalling
function also takes an integer argument in the range SIG_ATOMIC_MIN to
SIG_ATOMIC_MAX (guaranteed to allow at least 0..127).
.PP
Since this kind of interruption is fast, but can only interrupt a
\&\fIrunning\fR interpreter, there is optional support for signalling a pipe
\&\- that means you can also wait for the pipe to become readable (e.g. via
EV or AnyEvent). This, of course, incurs the overhead of a \f(CW\*(C`read\*(C'\fR
and \f(CW\*(C`write\*(C'\fR syscall.
.SH "USAGE EXAMPLES"
.IX Header "USAGE EXAMPLES"
.SS "Implementing race-free signal handling"
.IX Subsection "Implementing race-free signal handling"
This example uses a single event pipe for all signals, and one
Async::Interrupt per signal. This code is actually what the AnyEvent
module uses itself when Async::Interrupt is available.
.PP
First, create the event pipe and hook it into the event loop
.PP
.Vb 6
\&   $SIGPIPE = new Async::Interrupt::EventPipe;
\&   $SIGPIPE_W = AnyEvent\->io (
\&      fh   => $SIGPIPE\->fileno,
\&      poll => "r",
\&      cb   => \e&_signal_check, # defined later
\&   );
.Ve
.PP
Then, for each signal to hook, create an Async::Interrupt object. The
callback just sets a global variable, as we are only interested in
synchronous signals (i.e. when the event loop polls), which is why the
pipe draining is not done automatically.
.PP
.Vb 6
\&   my $interrupt = new Async::Interrupt
\&      cb             => sub { undef $SIGNAL_RECEIVED{$signum} },
\&      signal         => $signum,
\&      pipe           => [$SIGPIPE\->filenos],
\&      pipe_autodrain => 0,
\&   ;
.Ve
.PP
Finally, the I/O callback for the event pipe handles the signals:
.PP
.Vb 3
\&   sub _signal_check {
\&      # drain the pipe first
\&      $SIGPIPE\->drain;
\&
\&      # two loops, just to be sure
\&      while (%SIGNAL_RECEIVED) {
\&         for (keys %SIGNAL_RECEIVED) {
\&            delete $SIGNAL_RECEIVED{$_};
\&            warn "signal $_ received\en";
\&         }
\&      }
\&   }
.Ve
.SS "Interrupt perl from another thread"
.IX Subsection "Interrupt perl from another thread"
This example interrupts the Perl interpreter from another thread, via the
XS API. This is used by e.g. the EV::Loop::Async module.
.PP
On the Perl level, a new loop object (which contains the thread)
is created, by first calling some XS constructor, querying the
C\-level callback function and feeding that as the \f(CW\*(C`c_cb\*(C'\fR into the
Async::Interrupt constructor:
.PP
.Vb 3
\&   my $self = XS_thread_constructor;
\&   my ($c_func, $c_arg) = _c_func $self; # return the c callback
\&   my $asy = new Async::Interrupt c_cb => [$c_func, $c_arg];
.Ve
.PP
Then the newly created Interrupt object is queried for the signaling
function that the newly created thread should call, and this is in turn
told to the thread object:
.PP
.Vb 1
\&   _attach $self, $asy\->signal_func;
.Ve
.PP
So to repeat: first the XS object is created, then it is queried for the
callback that should be called when the Interrupt object gets signalled.
.PP
Then the interrupt object is queried for the callback function that the
thread should call to signal the Interrupt object, and this callback is
then attached to the thread.
.PP
You have to be careful that your new thread is not signalling before the
signal function was configured, for example by starting the background
thread only within \f(CW\*(C`_attach\*(C'\fR.
.PP
That concludes the Perl part.
.PP
The XS part consists of the actual constructor which creates a thread,
which is not relevant for this example, and two functions, \f(CW\*(C`_c_func\*(C'\fR,
which returns the Perl-side callback, and \f(CW\*(C`_attach\*(C'\fR, which configures
the signalling functioon that is safe toc all from another thread. For
simplicity, we will use global variables to store the functions, normally
you would somehow attach them to \f(CW$self\fR.
.PP
The \f(CW\*(C`c_func\*(C'\fR simply returns the address of a static function and arranges
for the object pointed to by \f(CW$self\fR to be passed to it, as an integer:
.PP
.Vb 6
\&   void
\&   _c_func (SV *loop)
\&           PPCODE:
\&           EXTEND (SP, 2);
\&           PUSHs (sv_2mortal (newSViv (PTR2IV (c_func))));
\&           PUSHs (sv_2mortal (newSViv (SvRV (loop))));
.Ve
.PP
This would be the callback (since it runs in a normal Perl context, it is
permissible to manipulate Perl values):
.PP
.Vb 6
\&   static void
\&   c_func (pTHX_ void *loop_, int value)
\&   {
\&     SV *loop_object = (SV *)loop_;
\&     ...
\&   }
.Ve
.PP
And this attaches the signalling callback:
.PP
.Vb 2
\&   static void (*my_sig_func) (void *signal_arg, int value);
\&   static void *my_sig_arg;
\&
\&   void
\&   _attach (SV *loop_, IV sig_func, void *sig_arg)
\&           CODE:
\&   {
\&           my_sig_func = sig_func;
\&           my_sig_arg  = sig_arg;
\&
\&           /* now run the thread */
\&           thread_create (&u\->tid, l_run, 0);
\&   }
.Ve
.PP
And \f(CW\*(C`l_run\*(C'\fR (the background thread) would eventually call the signaling
function:
.PP
.Vb 1
\&   my_sig_func (my_sig_arg, 0);
.Ve
.PP
You can have a look at EV::Loop::Async for an actual example using
intra-thread communication, locking and so on.
.SH "THE Async::Interrupt CLASS"
.IX Header "THE Async::Interrupt CLASS"
.ie n .IP "$async = new Async::Interrupt key => value..." 4
.el .IP "\f(CW$async\fR = new Async::Interrupt key => value..." 4
.IX Item "$async = new Async::Interrupt key => value..."
Creates a new Async::Interrupt object. You may only use async
notifications on this object while it exists, so you need to keep a
reference to it at all times while it is used.
.Sp
Optional constructor arguments include (normally you would specify at
least one of \f(CW\*(C`cb\*(C'\fR or \f(CW\*(C`c_cb\*(C'\fR).
.RS 4
.ie n .IP "cb => $coderef\->($value)" 4
.el .IP "cb => \f(CW$coderef\fR\->($value)" 4
.IX Item "cb => $coderef->($value)"
Registers a perl callback to be invoked whenever the async interrupt is
signalled.
.Sp
Note that, since this callback can be invoked at basically any time, it
must not modify any well-known global variables such as \f(CW$/\fR without
restoring them again before returning.
.Sp
The exceptions are \f(CW$!\fR and \f(CW$@\fR, which are saved and restored by
Async::Interrupt.
.Sp
If the callback should throw an exception, then it will be caught,
and \f(CW$Async::Interrupt::DIED\fR will be called with \f(CW$@\fR containing
the exception. The default will simply \f(CW\*(C`warn\*(C'\fR about the message and
continue.
.ie n .IP "c_cb => [$c_func, $c_arg]" 4
.el .IP "c_cb => [$c_func, \f(CW$c_arg\fR]" 4
.IX Item "c_cb => [$c_func, $c_arg]"
Registers a C callback the be invoked whenever the async interrupt is
signalled.
.Sp
The C callback must have the following prototype:
.Sp
.Vb 1
\&   void c_func (pTHX_ void *c_arg, int value);
.Ve
.Sp
Both \f(CW$c_func\fR and \f(CW$c_arg\fR must be specified as integers/IVs, and
\&\f(CW$value\fR is the \f(CW\*(C`value\*(C'\fR passed to some earlier call to either \f(CW$signal\fR
or the \f(CW\*(C`signal_func\*(C'\fR function.
.Sp
Note that, because the callback can be invoked at almost any time, you
have to be careful at saving and restoring global variables that Perl
might use (the exception is \f(CW\*(C`errno\*(C'\fR, which is saved and restored by
Async::Interrupt). The callback itself runs as part of the perl context,
so you can call any perl functions and modify any perl data structures (in
which case the requirements set out for \f(CW\*(C`cb\*(C'\fR apply as well).
.ie n .IP "var => $scalar_ref" 4
.el .IP "var => \f(CW$scalar_ref\fR" 4
.IX Item "var => $scalar_ref"
When specified, then the given argument must be a reference to a
scalar. The scalar will be set to \f(CW0\fR initially. Signalling the interrupt
object will set it to the passed value, handling the interrupt will reset
it to \f(CW0\fR again.
.Sp
Note that the only thing you are legally allowed to do is to is to check
the variable in a boolean or integer context (e.g. comparing it with a
string, or printing it, will \fIdestroy\fR it and might cause your program to
crash or worse).
.ie n .IP "signal => $signame_or_value" 4
.el .IP "signal => \f(CW$signame_or_value\fR" 4
.IX Item "signal => $signame_or_value"
When this parameter is specified, then the Async::Interrupt will hook the
given signal, that is, it will effectively call \f(CW\*(C`\->signal (0)\*(C'\fR each time
the given signal is caught by the process.
.Sp
Only one async can hook a given signal, and the signal will be restored to
defaults when the Async::Interrupt object gets destroyed.
.ie n .IP "signal_hysteresis => $boolean" 4
.el .IP "signal_hysteresis => \f(CW$boolean\fR" 4
.IX Item "signal_hysteresis => $boolean"
Sets the initial signal hysteresis state, see the \f(CW\*(C`signal_hysteresis\*(C'\fR
method, below.
.ie n .IP "pipe => [$fileno_or_fh_for_reading, $fileno_or_fh_for_writing]" 4
.el .IP "pipe => [$fileno_or_fh_for_reading, \f(CW$fileno_or_fh_for_writing\fR]" 4
.IX Item "pipe => [$fileno_or_fh_for_reading, $fileno_or_fh_for_writing]"
Specifies two file descriptors (or file handles) that should be signalled
whenever the async interrupt is signalled. This means a single octet will
be written to it, and before the callback is being invoked, it will be
read again. Due to races, it is unlikely but possible that multiple octets
are written. It is required that the file handles are both in nonblocking
mode.
.Sp
The object will keep a reference to the file handles.
.Sp
This can be used to ensure that async notifications will interrupt event
frameworks as well.
.Sp
Note that \f(CW\*(C`Async::Interrupt\*(C'\fR will create a suitable signal fd
automatically when your program requests one, so you don't have to specify
this argument when all you want is an extra file descriptor to watch.
.Sp
If you want to share a single event pipe between multiple Async::Interrupt
objects, you can use the \f(CW\*(C`Async::Interrupt::EventPipe\*(C'\fR class to manage
those.
.ie n .IP "pipe_autodrain => $boolean" 4
.el .IP "pipe_autodrain => \f(CW$boolean\fR" 4
.IX Item "pipe_autodrain => $boolean"
Sets the initial autodrain state, see the \f(CW\*(C`pipe_autodrain\*(C'\fR method, below.
.RE
.RS 4
.RE
.ie n .IP "($signal_func, $signal_arg) = $async\->signal_func" 4
.el .IP "($signal_func, \f(CW$signal_arg\fR) = \f(CW$async\fR\->signal_func" 4
.IX Item "($signal_func, $signal_arg) = $async->signal_func"
Returns the address of a function to call asynchronously. The function
has the following prototype and needs to be passed the specified
\&\f(CW$signal_arg\fR, which is a \f(CW\*(C`void *\*(C'\fR cast to \f(CW\*(C`IV\*(C'\fR:
.Sp
.Vb 1
\&   void (*signal_func) (void *signal_arg, int value)
.Ve
.Sp
An example call would look like:
.Sp
.Vb 1
\&   signal_func (signal_arg, 0);
.Ve
.Sp
The function is safe to call from within signal and thread contexts, at
any time. The specified \f(CW\*(C`value\*(C'\fR is passed to both C and Perl callback.
.Sp
\&\f(CW$value\fR must be in the valid range for a \f(CW\*(C`sig_atomic_t\*(C'\fR, except \f(CW0\fR
(1..127 is portable).
.Sp
If the function is called while the Async::Interrupt object is already
signaled but before the callbacks are being executed, then the stored
\&\f(CW\*(C`value\*(C'\fR is either the old or the new one. Due to the asynchronous
nature of the code, the \f(CW\*(C`value\*(C'\fR can even be passed to two consecutive
invocations of the callback.
.ie n .IP "$address = $async\->c_var" 4
.el .IP "\f(CW$address\fR = \f(CW$async\fR\->c_var" 4
.IX Item "$address = $async->c_var"
Returns the address (cast to IV) of an \f(CW\*(C`IV\*(C'\fR variable. The variable is set
to \f(CW0\fR initially and gets set to the passed value whenever the object
gets signalled, and reset to \f(CW0\fR once the interrupt has been handled.
.Sp
Note that it is often beneficial to just call \f(CW\*(C`PERL_ASYNC_CHECK ()\*(C'\fR to
handle any interrupts.
.Sp
Example: call some XS function to store the address, then show C code
waiting for it.
.Sp
.Vb 1
\&   my_xs_func $async\->c_var;
\&
\&   static IV *valuep;
\&
\&   void
\&   my_xs_func (void *addr)
\&           CODE:
\&           valuep = (IV *)addr;
\&
\&   // code in a loop, waiting
\&   while (!*valuep)
\&     ; // do something
.Ve
.ie n .IP "$async\->signal ($value=1)" 4
.el .IP "\f(CW$async\fR\->signal ($value=1)" 4
.IX Item "$async->signal ($value=1)"
This signals the given async object from Perl code. Semi-obviously, this
will instantly trigger the callback invocation (it does not, as the name
might imply, do anything with POSIX signals).
.Sp
\&\f(CW$value\fR must be in the valid range for a \f(CW\*(C`sig_atomic_t\*(C'\fR, except \f(CW0\fR
(1..127 is portable).
.ie n .IP $async\->handle 4
.el .IP \f(CW$async\fR\->handle 4
.IX Item "$async->handle"
Calls the callback if the object is pending.
.Sp
This method does not need to be called normally, as it will be invoked
automatically. However, it can be used to force handling of outstanding
interrupts while the object is blocked.
.Sp
One reason why one might want to do that is when you want to switch
from asynchronous interruptions to synchronous one, using e.g. an event
loop. To do that, one would first \f(CW\*(C`$async\->block\*(C'\fR the interrupt
object, then register a read watcher on the \f(CW\*(C`pipe_fileno\*(C'\fR that calls \f(CW\*(C`$async\->handle\*(C'\fR.
.Sp
This disables asynchronous interruptions, but ensures that interrupts are
handled by the event loop.
.ie n .IP "$async\->signal_hysteresis ($enable)" 4
.el .IP "\f(CW$async\fR\->signal_hysteresis ($enable)" 4
.IX Item "$async->signal_hysteresis ($enable)"
Enables or disables signal hysteresis (default: disabled). If a POSIX
signal is used as a signal source for the interrupt object, then enabling
signal hysteresis causes Async::Interrupt to reset the signal action to
\&\f(CW\*(C`SIG_IGN\*(C'\fR in the signal handler and restore it just before handling the
interruption.
.Sp
When you expect a lot of signals (e.g. when using SIGIO), then enabling
signal hysteresis can reduce the number of handler invocations
considerably, at the cost of two extra syscalls.
.Sp
Note that setting the signal to \f(CW\*(C`SIG_IGN\*(C'\fR can have unintended side
effects when you fork and exec other programs, as often they do not expect
signals to be ignored by default.
.ie n .IP $async\->block 4
.el .IP \f(CW$async\fR\->block 4
.IX Item "$async->block"
.PD 0
.ie n .IP $async\->unblock 4
.el .IP \f(CW$async\fR\->unblock 4
.IX Item "$async->unblock"
.PD
Sometimes you need a "critical section" of code that will not be
interrupted by an Async::Interrupt. This can be implemented by calling \f(CW\*(C`$async\->block\*(C'\fR before the critical section, and \f(CW\*(C`$async\->unblock\*(C'\fR
afterwards.
.Sp
Note that there must be exactly one call of \f(CW\*(C`unblock\*(C'\fR for every previous
call to \f(CW\*(C`block\*(C'\fR (i.e. calls can nest).
.Sp
Since ensuring this in the presence of exceptions and threads is
usually more difficult than you imagine, I recommend using \f(CW\*(C`$async\->scoped_block\*(C'\fR instead.
.ie n .IP $async\->scope_block 4
.el .IP \f(CW$async\fR\->scope_block 4
.IX Item "$async->scope_block"
This call \f(CW\*(C`$async\->block\*(C'\fR and installs a handler that is called when
the current scope is exited (via an exception, by canceling the Coro
thread, by calling last/goto etc.).
.Sp
This is the recommended (and fastest) way to implement critical sections.
.ie n .IP "($block_func, $block_arg) = $async\->scope_block_func" 4
.el .IP "($block_func, \f(CW$block_arg\fR) = \f(CW$async\fR\->scope_block_func" 4
.IX Item "($block_func, $block_arg) = $async->scope_block_func"
Returns the address of a function that implements the \f(CW\*(C`scope_block\*(C'\fR
functionality.
.Sp
It has the following prototype and needs to be passed the specified
\&\f(CW$block_arg\fR, which is a \f(CW\*(C`void *\*(C'\fR cast to \f(CW\*(C`IV\*(C'\fR:
.Sp
.Vb 1
\&   void (*block_func) (void *block_arg)
.Ve
.Sp
An example call would look like:
.Sp
.Vb 1
\&   block_func (block_arg);
.Ve
.Sp
The function is safe to call only from within the toplevel of a perl XS
function and will call \f(CW\*(C`LEAVE\*(C'\fR and \f(CW\*(C`ENTER\*(C'\fR (in this order!).
.ie n .IP $async\->pipe_enable 4
.el .IP \f(CW$async\fR\->pipe_enable 4
.IX Item "$async->pipe_enable"
.PD 0
.ie n .IP $async\->pipe_disable 4
.el .IP \f(CW$async\fR\->pipe_disable 4
.IX Item "$async->pipe_disable"
.PD
Enable/disable signalling the pipe when the interrupt occurs (default is
enabled). Writing to a pipe is relatively expensive, so it can be disabled
when you know you are not waiting for it (for example, with EV you
could disable the pipe in a check watcher, and enable it in a prepare
watcher).
.Sp
Note that currently, while \f(CW\*(C`pipe_disable\*(C'\fR is in effect, no attempt to
read from the pipe will be done when handling events. This might change as
soon as I realize why this is a mistake.
.ie n .IP "$fileno = $async\->pipe_fileno" 4
.el .IP "\f(CW$fileno\fR = \f(CW$async\fR\->pipe_fileno" 4
.IX Item "$fileno = $async->pipe_fileno"
Returns the reading side of the signalling pipe. If no signalling pipe is
currently attached to the object, it will dynamically create one.
.Sp
Note that the only valid operation on this file descriptor is to wait
until it is readable. The fd might belong currently to a pipe, a tcp
socket, or an eventfd, depending on the platform, and is guaranteed to be
\&\f(CW\*(C`select\*(C'\fRable.
.ie n .IP "$async\->pipe_autodrain ($enable)" 4
.el .IP "\f(CW$async\fR\->pipe_autodrain ($enable)" 4
.IX Item "$async->pipe_autodrain ($enable)"
Enables (\f(CW1\fR) or disables (\f(CW0\fR) automatic draining of the pipe (default:
enabled). When automatic draining is enabled, then Async::Interrupt will
automatically clear the pipe. Otherwise the user is responsible for this
draining.
.Sp
This is useful when you want to share one pipe among many Async::Interrupt
objects.
.ie n .IP $async\->pipe_drain 4
.el .IP \f(CW$async\fR\->pipe_drain 4
.IX Item "$async->pipe_drain"
Drains the pipe manually, for example, when autodrain is disabled. Does
nothing when no pipe is enabled.
.ie n .IP $async\->post_fork 4
.el .IP \f(CW$async\fR\->post_fork 4
.IX Item "$async->post_fork"
The object will not normally be usable after a fork (as the pipe fd is
shared between processes). Calling this method after a fork in the child
ensures that the object will work as expected again. It only needs to be
called when the async object is used in the child.
.Sp
This only works when the pipe was created by Async::Interrupt.
.Sp
Async::Interrupt ensures that the reading file descriptor does not change
it's value.
.ie n .IP "$signum = Async::Interrupt::sig2num $signame_or_number" 4
.el .IP "\f(CW$signum\fR = Async::Interrupt::sig2num \f(CW$signame_or_number\fR" 4
.IX Item "$signum = Async::Interrupt::sig2num $signame_or_number"
.PD 0
.ie n .IP "$signame = Async::Interrupt::sig2name $signame_or_number" 4
.el .IP "\f(CW$signame\fR = Async::Interrupt::sig2name \f(CW$signame_or_number\fR" 4
.IX Item "$signame = Async::Interrupt::sig2name $signame_or_number"
.PD
These two convenience functions simply convert a signal name or number to
the corresponding name or number. They are not used by this module and
exist just because perl doesn't have a nice way to do this on its own.
.Sp
They will return \f(CW\*(C`undef\*(C'\fR on illegal names or numbers.
.SH "THE Async::Interrupt::EventPipe CLASS"
.IX Header "THE Async::Interrupt::EventPipe CLASS"
Pipes are the predominant utility to make asynchronous signals
synchronous. However, pipes are hard to come by: they don't exist on the
broken windows platform, and on GNU/Linux systems, you might want to use
an \f(CW\*(C`eventfd\*(C'\fR instead.
.PP
This class creates selectable event pipes in a portable fashion: on
windows, it will try to create a tcp socket pair, on GNU/Linux, it will
try to create an eventfd and everywhere else it will try to use a normal
pipe.
.ie n .IP "$epipe = new Async::Interrupt::EventPipe" 4
.el .IP "\f(CW$epipe\fR = new Async::Interrupt::EventPipe" 4
.IX Item "$epipe = new Async::Interrupt::EventPipe"
This creates and returns an eventpipe object. This object is simply a
blessed array reference:
.ie n .IP "($r_fd, $w_fd) = $epipe\->filenos" 4
.el .IP "($r_fd, \f(CW$w_fd\fR) = \f(CW$epipe\fR\->filenos" 4
.IX Item "($r_fd, $w_fd) = $epipe->filenos"
Returns the read-side file descriptor and the write-side file descriptor.
.Sp
Example: pass an eventpipe object as pipe to the Async::Interrupt
constructor, and create an AnyEvent watcher for the read side.
.Sp
.Vb 3
\&   my $epipe = new Async::Interrupt::EventPipe;
\&   my $asy = new Async::Interrupt pipe => [$epipe\->filenos];
\&   my $iow = AnyEvent\->io (fh => $epipe\->fileno, poll => \*(Aqr\*(Aq, cb => sub { });
.Ve
.ie n .IP "$r_fd = $epipe\->fileno" 4
.el .IP "\f(CW$r_fd\fR = \f(CW$epipe\fR\->fileno" 4
.IX Item "$r_fd = $epipe->fileno"
Return only the reading/listening side.
.ie n .IP $epipe\->signal 4
.el .IP \f(CW$epipe\fR\->signal 4
.IX Item "$epipe->signal"
Write something to the pipe, in a portable fashion.
.ie n .IP $epipe\->drain 4
.el .IP \f(CW$epipe\fR\->drain 4
.IX Item "$epipe->drain"
Drain (empty) the pipe.
.ie n .IP "($c_func, $c_arg) = $epipe\->signal_func" 4
.el .IP "($c_func, \f(CW$c_arg\fR) = \f(CW$epipe\fR\->signal_func" 4
.IX Item "($c_func, $c_arg) = $epipe->signal_func"
.PD 0
.ie n .IP "($c_func, $c_arg) = $epipe\->drain_func" 4
.el .IP "($c_func, \f(CW$c_arg\fR) = \f(CW$epipe\fR\->drain_func" 4
.IX Item "($c_func, $c_arg) = $epipe->drain_func"
.PD
These two methods returns a function pointer and \f(CW\*(C`void *\*(C'\fR argument
that can be called to have the effect of \f(CW\*(C`$epipe\->signal\*(C'\fR or \f(CW\*(C`$epipe\->drain\*(C'\fR, respectively, on the XS level.
.Sp
They both have the following prototype and need to be passed their
\&\f(CW$c_arg\fR, which is a \f(CW\*(C`void *\*(C'\fR cast to an \f(CW\*(C`IV\*(C'\fR:
.Sp
.Vb 1
\&   void (*c_func) (void *c_arg)
.Ve
.Sp
An example call would look like:
.Sp
.Vb 1
\&   c_func (c_arg);
.Ve
.ie n .IP $epipe\->renew 4
.el .IP \f(CW$epipe\fR\->renew 4
.IX Item "$epipe->renew"
Recreates the pipe (usually required in the child after a fork). The
reading side will not change it's file descriptor number, but the writing
side might.
.ie n .IP $epipe\->wait 4
.el .IP \f(CW$epipe\fR\->wait 4
.IX Item "$epipe->wait"
This method blocks the process until there are events on the pipe. This is
not a very event-based or ncie way of usign an event pipe, but it can be
occasionally useful.
.SH "IMPLEMENTATION DETAILS AND LIMITATIONS"
.IX Header "IMPLEMENTATION DETAILS AND LIMITATIONS"
This module works by "hijacking" SIGKILL, which is guaranteed to always
exist, but also cannot be caught, so is always available.
.PP
Basically, this module fakes the occurence of a SIGKILL signal and
then intercepts the interpreter handling it. This makes normal signal
handling slower (probably unmeasurably, though), but has the advantage
of not requiring a special runops function, nor slowing down normal perl
execution a bit.
.PP
It assumes that \f(CW\*(C`sig_atomic_t\*(C'\fR, \f(CW\*(C`int\*(C'\fR and \f(CW\*(C`IV\*(C'\fR are all async-safe to
modify.
.SH AUTHOR
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
