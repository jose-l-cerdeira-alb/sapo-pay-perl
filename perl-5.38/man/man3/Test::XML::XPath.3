.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::XML::XPath 3"
.TH Test::XML::XPath 3 2024-01-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test::XML::XPath \- Test XPath assertions
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 4
\&  use Test::XML::XPath tests => 3;
\&  like_xpath( \*(Aq<foo />\*(Aq, \*(Aq/foo\*(Aq );   # PASS
\&  like_xpath( \*(Aq<foo />\*(Aq, \*(Aq/bar\*(Aq );   # FAIL
\&  unlike_xpath( \*(Aq<foo />\*(Aq, \*(Aq/bar\*(Aq ); # PASS
\&
\&  is_xpath( \*(Aq<foo>bar</foo>\*(Aq, \*(Aq/foo\*(Aq, \*(Aqbar\*(Aq ); # PASS
\&  is_xpath( \*(Aq<foo>bar</foo>\*(Aq, \*(Aq/bar\*(Aq, \*(Aqfoo\*(Aq ); # FAIL
\&
\&  # More interesting examples of xpath assertions.
\&  my $xml = \*(Aq<foo attrib="1"><bish><bosh args="42">pub</bosh></bish></foo>\*(Aq;
\&
\&  # Do testing for attributes.
\&  like_xpath( $xml, \*(Aq/foo[@attrib="1"]\*(Aq ); # PASS
\&  # Find an element anywhere in the document.
\&  like_xpath( $xml, \*(Aq//bosh\*(Aq ); # PASS
\&  # Both.
\&  like_xpath( $xml, \*(Aq//bosh[@args="42"]\*(Aq ); # PASS
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module allows you to assert statements about your XML in the form
of XPath statements.  You can say that a piece of XML must contain
certain tags, with so-and-so attributes, etc.  It will try to use any
installed XPath module that it knows about.  Currently, this means
XML::LibXML and XML::XPath, in that order.
.PP
\&\fBNB\fR: Normally in XPath processing, the statement occurs from a
\&\fIcontext\fR node.  In the case of \fBlike_xpath()\fR, the context node will
always be the root node.  In practice, this means that these two
statements are identical:
.PP
.Vb 4
\&   # Absolute path.
\&   like_xpath( \*(Aq<foo/>\*(Aq, \*(Aq/foo\*(Aq );
\&   # Path relative to root.
\&   like_xpath( \*(Aq<foo/>\*(Aq, \*(Aqfoo\*(Aq );
.Ve
.PP
It's probably best to use absolute paths everywhere in order to keep
things simple.
.PP
\&\fBNB\fR: Beware of specifying attributes.  Because they use an @\-sign,
perl will complain about trying to interpolate arrays if you don't
escape them or use single quotes.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.IP "like_xpath ( XML, XPATH [, NAME ] )" 4
.IX Item "like_xpath ( XML, XPATH [, NAME ] )"
Assert that XML (a string containing XML) matches the statement
XPATH.  NAME is the name of the test.
.Sp
Returns true or false depending upon test success.
.IP "unlike_xpath ( XML, XPATH [, NAME ] )" 4
.IX Item "unlike_xpath ( XML, XPATH [, NAME ] )"
This is the reverse of \fBlike_xpath()\fR.  The test will only pass if XPATH
\&\fIdoes not\fR generates any matches in XML.
.Sp
Returns true or false depending upon test success.
.IP "is_xpath ( XML, XPATH, EXPECTED [, NAME ] )" 4
.IX Item "is_xpath ( XML, XPATH, EXPECTED [, NAME ] )"
Evaluates XPATH against XML, and pass the test if the is EXPECTED.  Uses
\&\fBfindvalue()\fR internally.
.Sp
Returns true or false depending upon test success.
.IP "set_xpath_processor ( CLASS )" 4
.IX Item "set_xpath_processor ( CLASS )"
Set the class name of the XPath processor used.  It is up to you to
ensure that this class is loaded.
.PP
In all cases, XML must be well formed, or the test will fail.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::XML.
.PP
XML::XPath, which is the basis for this module.
.PP
If you are not conversant with XPath, there are many tutorials
available on the web.  Google will point you at them.  The first one
that I saw was: <http://www.zvon.org/xxl/XPathTutorial/>, which
appears to offer interactive XPath as well as the tutorials.
.SH AUTHOR
.IX Header "AUTHOR"
Dominic Mitchell <cpan2 (at) semantico.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2002 by semantico
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
