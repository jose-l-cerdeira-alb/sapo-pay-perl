.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::SSH::Perl::Key 3"
.TH Net::SSH::Perl::Key 3 2023-08-07 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Net::SSH::Perl::Key \- Public or private key abstraction
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&    use Net::SSH::Perl::Key;
\&    my $key = Net::SSH::Perl::Key\->new;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\fINet::SSH::Perl::Key\fR implements an abstract base class interface
to key objects (either DSA, RSA, ECDSA, or Ed25519 keys, currently).
The underlying implementation for RSA, DSA, an ECDSA keys is the
CryptX module.  The Ed25519 implementation uses bundled XS and C code
from the SUPERCOP ref10 implementation.
.SH USAGE
.IX Header "USAGE"
.ie n .SS "Net::SSH::Perl::Key\->new($key_type [, $blob [, $compat_flag_ref ]])"
.el .SS "Net::SSH::Perl::Key\->new($key_type [, \f(CW$blob\fP [, \f(CW$compat_flag_ref\fP ]])"
.IX Subsection "Net::SSH::Perl::Key->new($key_type [, $blob [, $compat_flag_ref ]])"
Creates a new object of type \fINet::SSH::Perl::Key::$key_type\fR,
after loading the class implementing \fR\f(CI$key_type\fR\fI\fR.
should be \f(CW\*(C`DSA\*(C'\fR, \f(CW\*(C`RSA1\*(C'\fR, \f(CW\*(C`RSA\*(C'\fR, \f(CW\*(C`ECDSA256\*(C'\fR, \f(CW\*(C`ECDSA384\*(C'\fR, \f(CW\*(C`ECDSA521\*(C'\fR,
or \f(CW\*(C`Ed25519\*(C'\fR.
.PP
\&\fR\f(CI$blob\fR\fI\fR, if present, should be a string representation of the key,
from which the key object can be initialized. In fact, it should
be the representation that is returned from the \fIas_blob\fR method,
below.
.PP
\&\fR\f(CI$compat_flag_ref\fR\fI\fR should be a reference to the SSH compatibility
flag, which is generally stored inside of the \fINet::SSH::Perl\fR
object. This flag is used by certain key implementations (\f(CW\*(C`DSA\*(C'\fR)
to work around differences between SSH2 protocol implementations.
.PP
Returns the new key object, which is blessed into the subclass.
.ie n .SS "Net::SSH::Perl::Key\->read_private($key_type, $file [, $pass])"
.el .SS "Net::SSH::Perl::Key\->read_private($key_type, \f(CW$file\fP [, \f(CW$pass\fP])"
.IX Subsection "Net::SSH::Perl::Key->read_private($key_type, $file [, $pass])"
Reads a private key of type \fR\f(CI$key_type\fR\fI\fR out of the key file
\&\fI\fR\f(CI$file\fR\fI\fR. If the private key is encrypted, an attempt will be
made to decrypt it using the passphrase \fI\fR\f(CI$pass\fR\fI\fR; if \fI\fR\f(CI$pass\fR\fI\fR
is not provided, the empty string will be used. An empty
passphrase can be a handy way of providing password-less access
using publickey authentication.
.PP
If for any reason loading the key fails, returns \fIundef\fR; most
of the time, if loading the key fails, it's because the passphrase
is incorrect. If you first tried to read the key using an empty
passphrase, this might be a good time to ask the user for the
actual passphrase. :)
.PP
Returns the new key object, which is blessed into the subclass
denoted by \fR\f(CI$key_type\fR\fI\fR (\f(CW\*(C`DSA\*(C'\fR, \f(CW\*(C`RSA1\*(C'\fR, \f(CW\*(C`ECDSA\*(C'\fR or \f(CW\*(C`Ed25519\*(C'\fR).
.ie n .SS "Net::SSH::Perl::Key\->keygen($key_type, $bits)"
.el .SS "Net::SSH::Perl::Key\->keygen($key_type, \f(CW$bits\fP)"
.IX Subsection "Net::SSH::Perl::Key->keygen($key_type, $bits)"
\&\f(CW$key_type\fR is one of RSA, DSA, or ECDSA256/ECDSA384/ECDSA521.
Generates a new key and returns that key. The key returned is the
private key, which (presumably) contains all of the public key
data, as well. \fR\f(CI$bits\fR\fI\fR is the number of bits in the key.
.PP
Your \fR\f(CI$key_type\fR\fI\fR implementation may not support key generation;
if not, calling this method is a fatal error.
.PP
Returns the new key object, which is blessed into the subclass
denoted by \fR\f(CI$key_type\fR\fI\fR
.SS Net::SSH::Perl::Key\->keygen('Ed25519')
.IX Subsection "Net::SSH::Perl::Key->keygen('Ed25519')"
Generates a new Ed25519 key.  Ed25519 keys have fixed key length.
.PP
Returns the new key object, which is bless into the Ed25519
subclass.
.ie n .SS "Net::SSH::Perl::Key\->extract_public($key_type, $key_string)"
.el .SS "Net::SSH::Perl::Key\->extract_public($key_type, \f(CW$key_string\fP)"
.IX Subsection "Net::SSH::Perl::Key->extract_public($key_type, $key_string)"
Given a key string \fR\f(CI$key_string\fR\fI\fR, which should be a textual
representation of the public portion of a key of \fI\fR\f(CI$key_type\fR\fI\fR,
extracts the key attributes out of that string. This is used to
extract public keys out of entries in \fIknown_hosts\fR and public
identity files.
.PP
Returns the new key object, which is blessed into the subclass
denoted by \fR\f(CI$key_type\fR\fI\fR
.ie n .SS "$key\->write_private([ $file [, $pass, $ciphername, $rounds] ])"
.el .SS "\f(CW$key\fP\->write_private([ \f(CW$file\fP [, \f(CW$pass\fP, \f(CW$ciphername\fP, \f(CW$rounds\fP] ])"
.IX Subsection "$key->write_private([ $file [, $pass, $ciphername, $rounds] ])"
Writes out the private key \fR\f(CI$key\fR\fI\fR to \fI\fR\f(CI$file\fR\fI\fR, and encrypts
it using the passphrase \fI\fR\f(CI$pass\fR\fI\fR. If \fI\fR\f(CI$pass\fR\fI\fR is not provided,
the key is unencrypted, and the only security protection is
through filesystem protections.  For Ed25519 keys, optional
parameters ciphername and rounds can be passed to specify the
desired cipher to encrypt the key with and how many rounds of
encryption to employ, respectively.
.PP
If \fR\f(CI$file\fR\fI\fR is not provided, returns the content that would
have been written to the key file.
.ie n .SS $key\->dump_public
.el .SS \f(CW$key\fP\->dump_public
.IX Subsection "$key->dump_public"
Performs the inverse of \fIextract_public\fR: takes a key \fR\f(CI$key\fR\fI\fR
and dumps out a textual representation of the public portion
of the key. This is used when writing public key entries to
\&\fIknown_hosts\fR and public identity files.
.PP
Returns the textual representation.
.ie n .SS $key\->as_blob
.el .SS \f(CW$key\fP\->as_blob
.IX Subsection "$key->as_blob"
Returns a string representation of the public portion of the
key; this is \fInot\fR the same as \fIdump_public\fR, which is
intended to match the format used in \fIknown_hosts\fR, etc.
The return value of \fIas_blob\fR is used as an intermediary in
computing other values: the key fingerprint, the known hosts
representation, etc.
.ie n .SS $key\->equal($key2)
.el .SS \f(CW$key\fP\->equal($key2)
.IX Subsection "$key->equal($key2)"
Returns true if the public portions of \fR\f(CI$key\fR\fI\fR are equal to
those of \fI\fR\f(CI$key2\fR\fI\fR, and false otherwise. This is used when
comparing server host keys to keys in \fIknown_hosts\fR.
.ie n .SS $key\->size
.el .SS \f(CW$key\fP\->size
.IX Subsection "$key->size"
Returns the size (in bits) of the key \fR\f(CI$key\fR\fI\fR.
.ie n .SS "$key\->fingerprint([ \fI\fP\fI$type\fP\fI\fP ])"
.el .SS "\f(CW$key\fP\->fingerprint([ \fI\fP\f(CI$type\fP\fI\fP ])"
.IX Subsection "$key->fingerprint([ $type ])"
Returns a fingerprint of \fR\f(CI$key\fR\fI\fR. The default fingerprint is
a SHA256 representation.  If \fI\fR\f(CI$type\fR\fI\fR is equal to \f(CW\*(C`bubblebabble\*(C'\fR,
the Bubble Babble representation of the fingerprint is used.
If \fI\fR\f(CI$type\fR\fI\fR is equal to \f(CW\*(C`hex\*(C'\fR, a traditional hex representation
is returned.
.PP
The hex representation uses an \fIMD5\fR digest of the public key,
and the bubblebabble uses a \fISHA\-1\fR digest.
.SH "AUTHOR & COPYRIGHTS"
.IX Header "AUTHOR & COPYRIGHTS"
Please see the Net::SSH::Perl manpage for author, copyright,
and license information.
