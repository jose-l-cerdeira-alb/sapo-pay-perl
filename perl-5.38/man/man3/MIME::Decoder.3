.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MIME::Decoder 3"
.TH MIME::Decoder 3 2024-01-08 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
MIME::Decoder \- an object for decoding the body part of a MIME stream
.SH SYNOPSIS
.IX Header "SYNOPSIS"
Before reading further, you should see MIME::Tools to make sure that
you understand where this module fits into the grand scheme of things.
Go on, do it now.  I'll wait.
.PP
Ready?  Ok...
.SS "Decoding a data stream"
.IX Subsection "Decoding a data stream"
Here's a simple filter program to read quoted-printable data from STDIN
(until EOF) and write the decoded data to STDOUT:
.PP
.Vb 1
\&    use MIME::Decoder;
\&
\&    $decoder = new MIME::Decoder \*(Aqquoted\-printable\*(Aq or die "unsupported";
\&    $decoder\->decode(\e*STDIN, \e*STDOUT);
.Ve
.SS "Encoding a data stream"
.IX Subsection "Encoding a data stream"
Here's a simple filter program to read binary data from STDIN
(until EOF) and write base64\-encoded data to STDOUT:
.PP
.Vb 1
\&    use MIME::Decoder;
\&
\&    $decoder = new MIME::Decoder \*(Aqbase64\*(Aq or die "unsupported";
\&    $decoder\->encode(\e*STDIN, \e*STDOUT);
.Ve
.SS "Non-standard encodings"
.IX Subsection "Non-standard encodings"
You can \fBwrite and install\fR your own decoders so that
MIME::Decoder will know about them:
.PP
.Vb 1
\&    use MyBase64Decoder;
\&
\&    install MyBase64Decoder \*(Aqbase64\*(Aq;
.Ve
.PP
You can also \fBtest\fR if a given encoding is supported:
.PP
.Vb 3
\&    if (supported MIME::Decoder \*(Aqx\-uuencode\*(Aq) {
\&        ### we can uuencode!
\&    }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This abstract class, and its private concrete subclasses (see below)
provide an OO front end to the actions of...
.IP \(bu 4
Decoding a MIME-encoded stream
.IP \(bu 4
Encoding a raw data stream into a MIME-encoded stream.
.PP
The constructor for MIME::Decoder takes the name of an encoding
(\f(CW\*(C`base64\*(C'\fR, \f(CW\*(C`7bit\*(C'\fR, etc.), and returns an instance of a \fIsubclass\fR
of MIME::Decoder whose \f(CWdecode()\fR method will perform the appropriate
decoding action, and whose \f(CWencode()\fR method will perform the appropriate
encoding action.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.SS "Standard interface"
.IX Subsection "Standard interface"
If all you are doing is \fIusing\fR this class, here's all you'll need...
.IP "new ENCODING" 4
.IX Item "new ENCODING"
\&\fIClass method, constructor.\fR
Create and return a new decoder object which can handle the
given ENCODING.
.Sp
.Vb 1
\&    my $decoder = new MIME::Decoder "7bit";
.Ve
.Sp
Returns the undefined value if no known decoders are appropriate.
.IP "best ENCODING" 4
.IX Item "best ENCODING"
\&\fIClass method, constructor.\fR
Exactly like \fBnew()\fR, except that this defaults any unsupported encoding to
"binary", after raising a suitable warning (it's a fatal error if there's
no binary decoder).
.Sp
.Vb 1
\&    my $decoder = best MIME::Decoder "x\-gzip64";
.Ve
.Sp
Will either return a decoder, or a raise a fatal exception.
.IP "decode INSTREAM,OUTSTREAM" 4
.IX Item "decode INSTREAM,OUTSTREAM"
\&\fIInstance method.\fR
Decode the document waiting in the input handle INSTREAM,
writing the decoded information to the output handle OUTSTREAM.
.Sp
Read the section in this document on I/O handles for more information
about the arguments.  Note that you can still supply old-style
unblessed filehandles for INSTREAM and OUTSTREAM.
.Sp
Returns true on success, throws exception on failure.
.IP "encode INSTREAM,OUTSTREAM" 4
.IX Item "encode INSTREAM,OUTSTREAM"
\&\fIInstance method.\fR
Encode the document waiting in the input filehandle INSTREAM,
writing the encoded information to the output stream OUTSTREAM.
.Sp
Read the section in this document on I/O handles for more information
about the arguments.  Note that you can still supply old-style
unblessed filehandles for INSTREAM and OUTSTREAM.
.Sp
Returns true on success, throws exception on failure.
.IP encoding 4
.IX Item "encoding"
\&\fIInstance method.\fR
Return the encoding that this object was created to handle,
coerced to all lowercase (e.g., \f(CW"base64"\fR).
.IP "head [HEAD]" 4
.IX Item "head [HEAD]"
\&\fIInstance method.\fR
Completely optional: some decoders need to know a little about the file
they are encoding/decoding; e.g., x\-uu likes to have the filename.
The HEAD is any object which responds to messages like:
.Sp
.Vb 1
\&    $head\->mime_attr(\*(Aqcontent\-disposition.filename\*(Aq);
.Ve
.IP "supported [ENCODING]" 4
.IX Item "supported [ENCODING]"
\&\fIClass method.\fR
With one arg (an ENCODING name), returns truth if that encoding
is currently handled, and falsity otherwise.  The ENCODING will
be automatically coerced to lowercase:
.Sp
.Vb 6
\&    if (supported MIME::Decoder \*(Aq7BIT\*(Aq) {
\&        ### yes, we can handle it...
\&    }
\&    else {
\&        ### drop back six and punt...
\&    }
.Ve
.Sp
With no args, returns a reference to a hash of all available decoders,
where the key is the encoding name (all lowercase, like '7bit'),
and the value is true (it happens to be the name of the class
that handles the decoding, but you probably shouldn't rely on that).
You may safely modify this hash; it will \fInot\fR change the way the
module performs its lookups.  Only \f(CW\*(C`install\*(C'\fR can do that.
.Sp
\&\fIThanks to Achim Bohnet for suggesting this method.\fR
.SS "Subclass interface"
.IX Subsection "Subclass interface"
If you are writing (or installing) a new decoder subclass, there
are some other methods you'll need to know about:
.IP "decode_it INSTREAM,OUTSTREAM" 4
.IX Item "decode_it INSTREAM,OUTSTREAM"
\&\fIAbstract instance method.\fR
The back-end of the \fBdecode\fR method.  It takes an input handle
opened for reading (INSTREAM), and an output handle opened for
writing (OUTSTREAM).
.Sp
If you are writing your own decoder subclass, you must override this
method in your class.  Your method should read from the input
handle via \f(CWgetline()\fR or \f(CWread()\fR, decode this input, and print the
decoded data to the output handle via \f(CWprint()\fR.  You may do this
however you see fit, so long as the end result is the same.
.Sp
Note that unblessed references and globrefs are automatically turned
into I/O handles for you by \f(CWdecode()\fR, so you don't need to worry
about it.
.Sp
Your method must return either \f(CW\*(C`undef\*(C'\fR (to indicate failure),
or \f(CW1\fR (to indicate success).
It may also throw an exception to indicate failure.
.IP "encode_it INSTREAM,OUTSTREAM" 4
.IX Item "encode_it INSTREAM,OUTSTREAM"
\&\fIAbstract instance method.\fR
The back-end of the \fBencode\fR method.  It takes an input handle
opened for reading (INSTREAM), and an output handle opened for
writing (OUTSTREAM).
.Sp
If you are writing your own decoder subclass, you must override this
method in your class.  Your method should read from the input
handle via \f(CWgetline()\fR or \f(CWread()\fR, encode this input, and print the
encoded data to the output handle via \f(CWprint()\fR.  You may do this
however you see fit, so long as the end result is the same.
.Sp
Note that unblessed references and globrefs are automatically turned
into I/O handles for you by \f(CWencode()\fR, so you don't need to worry
about it.
.Sp
Your method must return either \f(CW\*(C`undef\*(C'\fR (to indicate failure),
or \f(CW1\fR (to indicate success).
It may also throw an exception to indicate failure.
.IP "filter IN, OUT, COMMAND..." 4
.IX Item "filter IN, OUT, COMMAND..."
\&\fIClass method, utility.\fR
If your decoder involves an external program, you can invoke
them easily through this method.  The command must be a "filter": a
command that reads input from its STDIN (which will come from the IN argument)
and writes output to its STDOUT (which will go to the OUT argument).
.Sp
For example, here's a decoder that un-gzips its data:
.Sp
.Vb 4
\&    sub decode_it {
\&        my ($self, $in, $out) = @_;
\&        $self\->filter($in, $out, "gzip \-d \-");
\&    }
.Ve
.Sp
The usage is similar to IPC::Open2::open2 (which it uses internally),
so you can specify COMMAND as a single argument or as an array.
.IP "init ARGS..." 4
.IX Item "init ARGS..."
\&\fIInstance method.\fR
Do any necessary initialization of the new instance,
taking whatever arguments were given to \f(CWnew()\fR.
Should return the self object on success, undef on failure.
.IP "install ENCODINGS..." 4
.IX Item "install ENCODINGS..."
\&\fIClass method\fR.
Install this class so that each encoding in ENCODINGS is handled by it:
.Sp
.Vb 1
\&    install MyBase64Decoder \*(Aqbase64\*(Aq, \*(Aqx\-base64super\*(Aq;
.Ve
.Sp
You should not override this method.
.IP "uninstall ENCODINGS..." 4
.IX Item "uninstall ENCODINGS..."
\&\fIClass method\fR.
Uninstall support for encodings.  This is a way to turn off the decoding
of "experimental" encodings.  For safety, always use MIME::Decoder directly:
.Sp
.Vb 1
\&    uninstall MIME::Decoder \*(Aqx\-uu\*(Aq, \*(Aqx\-uuencode\*(Aq;
.Ve
.Sp
You should not override this method.
.SH "DECODER SUBCLASSES"
.IX Header "DECODER SUBCLASSES"
You don't need to \f(CW"use"\fR any other Perl modules; the
following "standard" subclasses are included as part of MIME::Decoder:
.PP
.Vb 6
\&     Class:                         Handles encodings:
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MIME::Decoder::Binary          binary
\&     MIME::Decoder::NBit            7bit, 8bit
\&     MIME::Decoder::Base64          base64
\&     MIME::Decoder::QuotedPrint     quoted\-printable
.Ve
.PP
The following "non-standard" subclasses are also included:
.PP
.Vb 4
\&     Class:                         Handles encodings:
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MIME::Decoder::UU              x\-uu, x\-uuencode
\&     MIME::Decoder::Gzip64          x\-gzip64            ** requires gzip!
.Ve
.SH NOTES
.IX Header "NOTES"
.SS "Input/Output handles"
.IX Subsection "Input/Output handles"
As of MIME-tools 2.0, this class has to play nice with the new MIME::Body
class... which means that input and output routines cannot just assume that
they are dealing with filehandles.
.PP
Therefore, all that MIME::Decoder and its subclasses require (and, thus,
all that they can assume) is that INSTREAMs and OUTSTREAMs are objects
which respond to a subset of the messages defined in the IO::Handle
interface; minimally:
.PP
.Vb 3
\&      print
\&      getline
\&      read(BUF,NBYTES)
.Ve
.PP
\&\fIThanks to Achim Bohnet for suggesting this more-generic I/O model.\fR
.SS "Writing a decoder"
.IX Subsection "Writing a decoder"
If you're experimenting with your own encodings, you'll probably want
to write a decoder.  Here are the basics:
.IP 1. 4
Create a module, like "MyDecoder::", for your decoder.
Declare it to be a subclass of MIME::Decoder.
.IP 2. 4
Create the following instance methods in your class, as described above:
.Sp
.Vb 3
\&    decode_it
\&    encode_it
\&    init
.Ve
.IP 3. 4
In your application program, activate your decoder for one or
more encodings like this:
.Sp
.Vb 1
\&    require MyDecoder;
\&
\&    install MyDecoder "7bit";   ### use MyDecoder to decode "7bit"
\&    install MyDecoder "x\-foo";  ### also use MyDecoder to decode "x\-foo"
.Ve
.PP
To illustrate, here's a custom decoder class for the \f(CW\*(C`quoted\-printable\*(C'\fR
encoding:
.PP
.Vb 1
\&    package MyQPDecoder;
\&
\&    @ISA = qw(MIME::Decoder);
\&    use MIME::Decoder;
\&    use MIME::QuotedPrint;
\&
\&    ### decode_it \- the private decoding method
\&    sub decode_it {
\&        my ($self, $in, $out) = @_;
\&        local $_;
\&        while (defined($_ = $in\->getline)) {
\&            my $decoded = decode_qp($_);
\&            $out\->print($decoded);
\&        }
\&        1;
\&    }
\&
\&    ### encode_it \- the private encoding method
\&    sub encode_it {
\&        my ($self, $in, $out) = @_;
\&
\&        my ($buf, $nread) = (\*(Aq\*(Aq, 0);
\&        while ($in\->read($buf, 60)) {
\&            my $encoded = encode_qp($buf);
\&            $out\->print($encoded);
\&        }
\&        1;
\&    }
.Ve
.PP
That's it.  The task was pretty simple because the \f(CW"quoted\-printable"\fR
encoding can easily be converted line-by-line... as can
even \f(CW"7bit"\fR and \f(CW"8bit"\fR (since all these encodings guarantee
short lines, with a max of 1000 characters).
The good news is: it is very likely that it will be similarly-easy to
write a MIME::Decoder for any future standard encodings.
.PP
The \f(CW"binary"\fR decoder, however, really required block reads and writes:
see "MIME::Decoder::Binary" for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Tools, other MIME::Decoder subclasses.
.SH AUTHOR
.IX Header "AUTHOR"
Eryq (\fIeryq@zeegee.com\fR), ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.PP
All rights reserved.  This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
1;
