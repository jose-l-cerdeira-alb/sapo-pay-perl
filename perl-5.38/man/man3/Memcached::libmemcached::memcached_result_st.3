.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Memcached::libmemcached::memcached_result_st 3"
.TH Memcached::libmemcached::memcached_result_st 3 2015-05-07 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
memcached_result_create, memcached_result_free,
memcached_result_key_value, memcached_result_key_length,
memcached_result_value, memcached_result_length,
memcached_result_flags, memcached_result_cas \- Work with memcached_result_st
.SH LIBRARY
.IX Header "LIBRARY"
C Client Library for memcached (libmemcached, \-lmemcached)
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <memcached.h>
\&
\&  memcached_result_st *
\&    memcached_result_create (memcached_st *ptr,
\&                             memcached_result_st *result);
\&
\&  void memcached_result_free (memcached_result_st *result);
\&
\&  const char * memcached_result_key_value (memcached_result_st *result);
\&
\&  size_t memcached_result_key_length (const memcached_result_st *result);
\&
\&  const char *memcached_result_value (memcached_result_st *ptr);
\&
\&  size_t memcached_result_length (const memcached_result_st *ptr);
\&
\&  uint32_t memcached_result_flags (const memcached_result_st *result)
\&
\&  uint64_t memcached_result_cas (const memcached_result_st *result);
\&
\&  memcached_return_t
\&    memcached_result_set_value (memcached_result_st *ptr,
\&                                const char *value, size_t length)
\&
\&  void memcached_result_set_flags (memcached_result_st *ptr, uint32_t flags)
\&
\&  void memcached_result_set_expiration (memcached_result_st *ptr, time_t)
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\fBlibmemcached\fR\|(3) can optionally return a memcached_result_st which acts as a
result object. The result objects have added benefits over the character
pointer returns in that they are forward compatible with new return items
that future memcached servers may implement (the best current example of
this is the CAS return item). The structures can also be reused which will
save on calls to \fBmalloc\fR\|(3). It is suggested that you use result objects over
char * return functions.
.PP
The structure of memcached_result_st has been encapsulated, you should not
write code to directly access members of the structure.
.PP
\&\fBmemcached_result_create()\fR will either allocate memory for a
memcached_result_st or will initialize a structure passed to it.
.PP
\&\fBmemcached_result_free()\fR will deallocate any memory attached to the
structure. If the structure was also alloacted, it will deallocate it.
.PP
\&\fBmemcached_result_key_value()\fR returns the key value associated with the
current result object.
.PP
\&\fBmemcached_result_key_length()\fR returns the key length associated with the
current result object.
.PP
\&\fBmemcached_result_value()\fR returns the result value associated with the
current result object.
.PP
\&\fBmemcached_result_length()\fR returns the result length associated with the
current result object.
.PP
\&\fBmemcached_result_flags()\fR returns the flags associated with the
current result object.
.PP
\&\fBmemcached_result_cas()\fR returns the cas associated with the
current result object. This value will only be available if the server
supports it.
.PP
\&\fBmemcached_result_set_value()\fR takes a byte array and a size and sets
the result to this value. This function is used for trigger responses.
.PP
void \fBmemcached_result_set_flags()\fR takes a result structure and stores
a new value for the flags field.
.PP
void memcached_result_set_expiration(A) takes a result structure and stores
a new value for the expiration field (this is only used by read through
triggers).
.PP
You may wish to avoid using \fBmemcached_result_create\fR\|(3) with a
stack based allocation. The most common issues related to ABI safety involve
heap allocated structures.
.SH RETURN
.IX Header "RETURN"
Varies, see particular functions. All structures must have
\&\fBmemcached_result_free()\fR called on them for cleanup purposes. Failure to
do this will result in leaked memory.
.SH HOME
.IX Header "HOME"
To find out more information please check:
<https://launchpad.net/libmemcached>
.SH AUTHOR
.IX Header "AUTHOR"
Brian Aker, <brian@tangent.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBmemcached\fR\|(1) \fBlibmemcached\fR\|(3) \fBmemcached_strerror\fR\|(3)
