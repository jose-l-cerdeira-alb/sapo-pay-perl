.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "AlarmCall 3"
.TH AlarmCall 3 2003-04-09 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Sys::AlarmCall \- A package to handle the logic in timing out calls
with alarm() and an ALRM handler, allowing nested calls as well.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Sys::AlarmCall;
\&
\&    $result = alarm_call($timeout1,$func1,@args1);
\&    @result = alarm_call($timeout2,$func2,@args2);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Sys::AlarmCall provides a straightforward function call to use the alarm
handler. It also handles the logic which allows nested time out calls
if timeout calls are run thorugh the \fBalarm_call()\fR functions.
.PP
The main advantages of Sys::AlarmCall are that:
.PP
1. simple calls, e.g.
.PP
.Vb 4
\&    @result = &func(@args); #Normal function call with \*(Aq&\*(Aq
\&    $result = func(@args);; #Normal function call
\&    @result = &$code_reference(@args);
\&    @result = $obj\->func(@args); #Object method call
.Ve
.PP
become simple calls:
.PP
.Vb 4
\&    @result = alarm_call($timeout,\*(Aq&func\*(Aq,@args);
\&    $result = alarm_call($timeout,\*(Aqfunc\*(Aq,@args);
\&    @result = alarm_call($timeout,$code_reference,@args);
\&    @result = alarm_call($timeout,\*(Aq\->func\*(Aq,$obj,@args);
.Ve
.PP
no need to futz around with alarms and handlers and
worrying about where to intercept the timer or set globals
or whatever; and
.PP
2. No need to worry if some subroutines within the
call also set a timeout \- all that is handled logically
by the Sys::AlarmCall package (as long as the subroutines also
use the alarm_call function of course. But if they don't
you're up the same creek anyway).
.PP
Sys::AlarmCall exports one function,
.IP "alarm_call TIMEOUT,FUNCTION,ARGS" 4
.IX Item "alarm_call TIMEOUT,FUNCTION,ARGS"
Where TIMEOUT is a positive number (a fatal error occurs if TIMEOUT
is not at least one);
.Sp
FUNCTION is a string giving the function name (and the '&' if wanted,
or preceded by '\->', e.g. '\->func', if using that, in which case the
calling object should be the first argument in ARGS);
and ARGS is the list of arguments to that function.
.Sp
NOTE: As a side effect, normally fatal errors in the FUNCTION call are
caught and reported in the return.
.Sp
In a scalar context, returns as follows:
.Sp
If the FUNCTION produces any sort of error (including fatal 'die's which
are trapped), returns the error as a string, prepended by the value given
by the variable \f(CW$Sys::AlarmCall::SCALAR_ERROR\fR (default is 'ERROR ').
.Sp
If the FUNCTION times out (i.e. doesn't return before TIMEOUT \- 1),
returns the value given by the variable \f(CW$Sys::AlarmCall::TIMEOUT\fR (default
is 'TIMEOUT').
.Sp
Otherwise, returns the scalar that the FUNCTION returns.
.Sp
In an array context, returns as follows:
.Sp
If the FUNCTION produces any sort of error (including fatal 'die's which
are trapped), returns a two element array, the first element being
the value given by the variable \f(CW$Sys::AlarmCall::ARRAY_ERROR\fR (default
is 'ERROR'), and the second element the error string produced.
.Sp
If the FUNCTION times out (i.e. doesn't return before TIMEOUT \- 1),
returns a one element array consisting of the value given by the
variable \f(CW$Sys::AlarmCall::TIMEOUT\fR (default is 'TIMEOUT').
.Sp
Otherwise, returns the array that the FUNCTION returns.
.Sp
Specific support for the \-> construct has been added to alarm_call,
so that calling
.Sp
.Vb 1
\&    alarm_call($timeout,\*(Aq\->func\*(Aq,$obj,@args);
.Ve
.Sp
means that alarm_call will translate this to
.Sp
.Vb 1
\&    $obj\->func(@args);
.Ve
.Sp
Specific support for code references (e.g. \f(CW$ref\fR = sub {warn "this\en"})
has been added to alarm_call, so that calling
.Sp
.Vb 1
\&    alarm_call($timeout,$ref,@args);
.Ve
.Sp
means that alarm_call will translate this to
.Sp
.Vb 1
\&    &{$ref}(@args);
.Ve
.PP
Timers have resolutions of one second, but remember that a timeout
value of 15 will cause a timeout to occur at some point more than 14
seconds in the future. (see \fBalarm()\fR function in perl man page).
Also, nested calls decrease the resolution (make the uncertain interval
larger) by one second per nesting depth. This is because an alarm
call returns the time left rounded up to the next second.
.SH EXAMPLES
.IX Header "EXAMPLES"
EXAMPLE1
.PP
.Vb 2
\&   use Sys::AlarmCall;
\&   alarm_call(3,\*(Aqselect\*(Aq,undef,undef,undef,10);
.Ve
.PP
makes the \fBselect()\fR system call which should just block for ten
seconds, but times it out after three seconds.
.PP
EXAMPLE2
.PP
.Vb 3
\&   use Sys::AlarmCall;
\&   alarm_call(4,\*(Aqread\*(Aq,STDIN,$r,5);
\&   print $r;
.Ve
.PP
makes the \fBread()\fR system call which would block
until some characters are ready to be read from STDIN (after a
return), and then should try to read up to 5 characters.
However, the timeout for 4 seconds means that this call
will return after 4 seconds if nothing is read by then.
.PP
EXAMPLE3
.PP
.Vb 10
\&   use Sys::AlarmCall;
\&   sub do1 {
\&        print "Hi, this is do1\en";
\&        select(undef,undef,undef,10);
\&        print "Bye from do1\en"
\&   }
\&   sub do2 {
\&        print "Hi, this is do2\en";
\&        alarm_call(5,\*(Aqdo1\*(Aq);
\&        print "Bye from do2\en"
\&   }
\&   sub do3 {
\&        print "Hi, this is do3\en";
\&        alarm_call(3,\*(Aqdo2\*(Aq);
\&        print "Bye from do3\en"
\&   }
\&   sub do4 {
\&        print "Hi, this is do4\en";
\&        alarm_call(8,\*(Aqdo2\*(Aq);
\&        print "Bye from do4\en"
\&   }
\&   
\&   foreach $test ((\*(Aqdo1\*(Aq,\*(Aqdo2\*(Aq,\*(Aqdo3\*(Aq,\*(Aqdo4\*(Aq)) {
\&       print "\en$test\en";
\&       $time = time;
\&       &$test;
\&       print "$test completed after ", 
\&           time \- $time ," seconds.\en";
\&   }
.Ve
.PP
Explanation of EXAMPLE3:
.PP
Where interrupts occur, you will see the 'Hi' statement without the
corresponding 'Bye' statement.
.PP
The 'do1' is a simple test that \fBselect()\fR works correctly, delaying for
10 seconds. The 'do2' is a simple test of the alarm_call, testing
that the \fBselect()\fR is interrupted after 5 seconds. The third and
fourth 'do's are tests of nested calls to alarm_call. 'do3' should
timeout after three seconds, interrupting the call to 'do2' (so we
should see no 'bye' statement from 'do2'). 'do4' on the other hand,
has a timeout of 8 seconds, so 'do2', which it calls and which is set
to timeout and return after 5 seconds, will complete, printing out
its 'bye' statement.
.PP
WARNING \- using calls to \fBalarm()\fR in nested calls other than through
the Sys::AlarmCall module may lead to inconsistencies. Calls to alarm
BETWEEN calls to alarm_call should be no problem. Any alarms pending will
be reset after a call to alarm_call to the previous setting minus elapsed
time (approx.). The alarm handler is also reset to the previous one.
.PP
BUGS: Some perl core calls (like read, sysread) don't cope when fed
their args as an array. alarm_call explicitly states up to six
arguments so that the perl compiler reads these correctly, but
any core functions which take more than six arguments as minimum
is not accepted as valid by the compiler even if the correct
number of arguments are passed. So consequently, if you want to
time out on these specifically, you may need to wrap them in
a subroutine.
.SH AUTHOR
.IX Header "AUTHOR"
Jack Shirazi (CPAN ID 'JACKS')
.PP
.Vb 3
\&  Copyright (c) 1995 Jack Shirazi; 2003 Ask Bjoern Hansen. All rights
\&  reserved.  This program is free software; you can redistribute it
\&  and/or modify it under the same terms as Perl itself.
.Ve
