.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Type::Tiny::Bitfield 3"
.TH Type::Tiny::Bitfield 3 2023-04-05 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Type::Tiny::Bitfield \- bitfield/bitflag type constraints
.SH SYNOPSIS
.IX Header "SYNOPSIS"
Using Type::Tiny::Bitfield's export feature:
.PP
.Vb 2
\&  package LightSource {
\&    use Moo;
\&    
\&    use Type::Tiny::Bitfield LedSet => {
\&      RED   => 1,
\&      GREEN => 2,
\&      BLUE  => 4,
\&    };
\&    
\&    has leds => ( is => \*(Aqro\*(Aq, isa => LedSet, default => 0, coerce => 1 );
\&    
\&    sub new_red {
\&      my $class = shift;
\&      return $class\->new( leds => LEDSET_RED );
\&    }
\&    
\&    sub new_green {
\&      my $class = shift;
\&      return $class\->new( leds => LEDSET_GREEN );
\&    }
\&    
\&    sub new_yellow {
\&      my $class = shift;
\&      return $class\->new( leds => LEDSET_RED | LEDSET_GREEN );
\&    }
\&  }
.Ve
.PP
Using Type::Tiny::Bitfield's object-oriented interface:
.PP
.Vb 3
\&  package LightSource {
\&    use Moo;
\&    use Type::Tiny::Bitfield;
\&    
\&    my $LedSet = Type::Tiny::Bitfield\->new(
\&      name   => \*(AqLedSet\*(Aq,
\&      values => {
\&        RED   => 1,
\&        GREEN => 2,
\&        BLUE  => 4,
\&      },
\&      coercion => 1,
\&    );
\&    
\&    has leds => ( is => \*(Aqro\*(Aq, isa => $LedSet, default => 0, coerce => 1 );
\&    
\&    sub new_red {
\&      my $class = shift;
\&      return $class\->new( leds => $LedSet\->RED );
\&    }
\&    
\&    sub new_green {
\&      my $class = shift;
\&      return $class\->new( leds => $LedSet\->GREEN );
\&    }
\&    
\&    sub new_yellow {
\&      my $class = shift;
\&      return $class\->new( leds => $LedSet\->coerce(\*(Aqred|green\*(Aq) );
\&    }
\&  }
.Ve
.SH STATUS
.IX Header "STATUS"
This module is covered by the
Type-Tiny stability policy.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Bitfield type constraints.
.PP
This package inherits from Type::Tiny; see that for most documentation.
Major differences are listed below:
.SS Attributes
.IX Subsection "Attributes"
.ie n .IP """values""" 4
.el .IP \f(CWvalues\fR 4
.IX Item "values"
Hashref of bits allowed in the bitfield. Keys must be UPPER_SNAKE_CASE strings.
Values must be positive integers which are powers of two. The same number
cannot be used multiple times.
.ie n .IP """constraint""" 4
.el .IP \f(CWconstraint\fR 4
.IX Item "constraint"
Unlike Type::Tiny, you \fIcannot\fR pass a constraint coderef to the constructor.
Instead rely on the default.
.ie n .IP """inlined""" 4
.el .IP \f(CWinlined\fR 4
.IX Item "inlined"
Unlike Type::Tiny, you \fIcannot\fR pass an inlining coderef to the constructor.
Instead rely on the default.
.ie n .IP """parent""" 4
.el .IP \f(CWparent\fR 4
.IX Item "parent"
Parent is always \fBTypes::Common::Numeric::PositiveOrZeroInt\fR, and cannot be
passed to the constructor.
.ie n .IP """coercion""" 4
.el .IP \f(CWcoercion\fR 4
.IX Item "coercion"
If \f(CW\*(C`coercion => 1\*(C'\fR is passed to the constructor, the type will have an
automatic coercion from \fBStr\fR. Types built by the \f(CW\*(C`import\*(C'\fR method will
always have \f(CW\*(C`coercion => 1\*(C'\fR.
.Sp
In the SYNOPSIS example, the coercion from \fBStr\fR will accept strings like:
.Sp
.Vb 6
\&  "RED"
\&  "red"
\&  "Red Green"
\&  "Red+Blue"
\&  "blue | GREEN"
\&  "LEDSET_RED + LeDsEt_green"
.Ve
.SS Methods
.IX Subsection "Methods"
This class uses \f(CW\*(C`AUTOLOAD\*(C'\fR to allow the names of each bit in the bitfield
to be used as methods. These method names will always be UPPER_SNAKE_CASE.
.PP
For example, in the synopsis, \f(CW\*(C`LedSet\->GREEN\*(C'\fR would return 2.
.PP
Other methods it provides:
.ie n .IP "from_string( $str )" 4
.el .IP "\f(CWfrom_string( $str )\fR" 4
.IX Item "from_string( $str )"
Provides the standard coercion from a string, even if this type constraint
doesn't have a coercion.
.ie n .IP "to_string( $int )" 4
.el .IP "\f(CWto_string( $int )\fR" 4
.IX Item "to_string( $int )"
Does the reverse coercion.
.ie n .IP constant_names() 4
.el .IP \f(CWconstant_names()\fR 4
.IX Item "constant_names()"
This is a convenience to allow for:
.Sp
.Vb 2
\&  use base \*(AqExporter::Tiny\*(Aq;
\&  push our @EXPORT_OK, LineStyle\->constant_names;
.Ve
.SS Exports
.IX Subsection "Exports"
Type::Tiny::Bitfield can be used as an exporter.
.PP
.Vb 5
\&  use Type::Tiny::Bitfield LedSet => {
\&    RED    => 1,
\&    GREEN  => 2,
\&    BLUE   => 4,
\&  };
.Ve
.PP
This will export the following functions into your namespace:
.ie n .IP """LedSet""" 4
.el .IP \f(CWLedSet\fR 4
.IX Item "LedSet"
.PD 0
.ie n .IP "is_LedSet( $value )" 4
.el .IP "\f(CWis_LedSet( $value )\fR" 4
.IX Item "is_LedSet( $value )"
.ie n .IP "assert_LedSet( $value )" 4
.el .IP "\f(CWassert_LedSet( $value )\fR" 4
.IX Item "assert_LedSet( $value )"
.ie n .IP "to_LedSet( $string )" 4
.el .IP "\f(CWto_LedSet( $string )\fR" 4
.IX Item "to_LedSet( $string )"
.ie n .IP "LedSet_to_Str( $value )" 4
.el .IP "\f(CWLedSet_to_Str( $value )\fR" 4
.IX Item "LedSet_to_Str( $value )"
.ie n .IP """LEDSET_RED""" 4
.el .IP \f(CWLEDSET_RED\fR 4
.IX Item "LEDSET_RED"
.ie n .IP """LEDSET_GREEN""" 4
.el .IP \f(CWLEDSET_GREEN\fR 4
.IX Item "LEDSET_GREEN"
.ie n .IP """LEDSET_BLUE""" 4
.el .IP \f(CWLEDSET_BLUE\fR 4
.IX Item "LEDSET_BLUE"
.PD
.PP
Multiple bitfield types can be exported at once:
.PP
.Vb 4
\&  use Type::Tiny::Enum (
\&    LedSet     => { RED => 1, GREEN => 2, BLUE => 4 },
\&    LedPattern => { FLASHING => 1 },
\&  );
.Ve
.SS Overloading
.IX Subsection "Overloading"
It is possible to combine two Bitfield types using the \f(CW\*(C`+\*(C'\fR operator.
.PP
.Vb 4
\&  use Type::Tiny::Enum (
\&    LedSet     => { RED => 1, GREEN => 2, BLUE => 4 },
\&    LedPattern => { FLASHING => 8 },
\&  );
\&  
\&  has leds => (
\&    is      => \*(Aqro\*(Aq,
\&    isa     => LedSet + LedPattern,
\&    default => 0,
\&    coerce  => 1
\&  );
.Ve
.PP
This will allow values like "11" (LEDSET_RED|LEDSET_GREEN|LEDPATTERN_FLASHING).
.PP
An exception will be thrown if any of the names in the two types being combined
conflict.
.SH BUGS
.IX Header "BUGS"
Please report any bugs to
<https://github.com/tobyink/p5\-type\-tiny/issues>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Type::Tiny::Manual.
.PP
Type::Tiny.
.SH AUTHOR
.IX Header "AUTHOR"
Toby Inkster <tobyink@cpan.org>.
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
This software is copyright (c) 2023 by Toby Inkster.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
.SH "DISCLAIMER OF WARRANTIES"
.IX Header "DISCLAIMER OF WARRANTIES"
THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
