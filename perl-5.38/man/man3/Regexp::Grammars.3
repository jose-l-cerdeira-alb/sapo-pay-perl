.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Regexp::Grammars 3"
.TH Regexp::Grammars 3 2024-01-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Regexp::Grammars \- Add grammatical parsing features to Perl 5.10 regexes
.SH VERSION
.IX Header "VERSION"
This document describes Regexp::Grammars version 1.058
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Regexp::Grammars;
\&
\&    my $parser = qr{
\&        (?:
\&            <Verb>               # Parse and save a Verb in a scalar
\&            <.ws>                # Parse but don\*(Aqt save whitespace
\&            <Noun>               # Parse and save a Noun in a scalar
\&
\&            <type=(?{ rand > 0.5 ? \*(AqVN\*(Aq : \*(AqVerbNoun\*(Aq })>
\&                                 # Save result of expression in a scalar
\&        |
\&            (?:
\&                <[Noun]>         # Parse a Noun and save result in a list
\&                                     (saved under the key \*(AqNoun\*(Aq)
\&                <[PostNoun=ws]>  # Parse whitespace, save it in a list
\&                                 #   (saved under the key \*(AqPostNoun\*(Aq)
\&            )+
\&
\&            <Verb>               # Parse a Verb and save result in a scalar
\&                                     (saved under the key \*(AqVerb\*(Aq)
\&
\&            <type=(?{ \*(AqVN\*(Aq })>   # Save a literal in a scalar
\&        |
\&            <debug: match>       # Turn on the integrated debugger here
\&            <.Cmd= (?: mv? )>    # Parse but don\*(Aqt capture a subpattern
\&                                     (name it \*(AqCmd\*(Aq for debugging purposes)
\&            <[File]>+            # Parse 1+ Files and save them in a list
\&                                     (saved under the key \*(AqFile\*(Aq)
\&            <debug: off>         # Turn off the integrated debugger here
\&            <Dest=File>          # Parse a File and save it in a scalar
\&                                     (saved under the key \*(AqDest\*(Aq)
\&        )
\&
\&        ################################################################
\&
\&        <token: File>              # Define a subrule named File
\&            <.ws>                  #  \- Parse but don\*(Aqt capture whitespace
\&            <MATCH= ([\ew\-]+) >     #  \- Parse the subpattern and capture
\&                                   #    matched text as the result of the
\&                                   #    subrule
\&
\&        <token: Noun>              # Define a subrule named Noun
\&            cat | dog | fish       #  \- Match an alternative (as usual)
\&
\&        <rule: Verb>               # Define a whitespace\-sensitive subrule
\&            eats                   #  \- Match a literal (after any space)
\&            <Object=Noun>?         #  \- Parse optional subrule Noun and
\&                                   #    save result under the key \*(AqObject\*(Aq
\&        |                          #  Or else...
\&            <AUX>                  #  \- Parse subrule AUX and save result
\&            <part= (eaten|seen) >  #  \- Match a literal, save under \*(Aqpart\*(Aq
\&
\&        <token: AUX>               # Define a whitespace\-insensitive subrule
\&            (has | is)             #  \- Match an alternative and capture
\&            (?{ $MATCH = uc $^N }) #  \- Use captured text as subrule result
\&
\&    }x;
\&
\&    # Match the grammar against some text...
\&    if ($text =~ $parser) {
\&        # If successful, the hash %/ will have the hierarchy of results...
\&        process_data_in( %/ );
\&    }
.Ve
.SH "QUICKSTART CHEATSHEET"
.IX Header "QUICKSTART CHEATSHEET"
.SS "In your program..."
.IX Subsection "In your program..."
.Vb 2
\&    use Regexp::Grammars;    Allow enhanced regexes in lexical scope
\&    %/                       Result\-hash for successful grammar match
.Ve
.SS "Defining and using named grammars..."
.IX Subsection "Defining and using named grammars..."
.Vb 2
\&    <grammar:  GRAMMARNAME>  Define a named grammar that can be inherited
\&    <extends:  GRAMMARNAME>  Current grammar inherits named grammar\*(Aqs rules
.Ve
.SS "Defining rules in your grammar..."
.IX Subsection "Defining rules in your grammar..."
.Vb 2
\&    <rule:     RULENAME>     Define rule with magic whitespace
\&    <token:    RULENAME>     Define rule without magic whitespace
\&
\&    <objrule:  CLASS= NAME>  Define rule that blesses return\-hash into class
\&    <objtoken: CLASS= NAME>  Define token that blesses return\-hash into class
\&
\&    <objrule:  CLASS>        Shortcut for above (rule name derived from class)
\&    <objtoken: CLASS>        Shortcut for above (token name derived from class)
.Ve
.SS "Matching rules in your grammar..."
.IX Subsection "Matching rules in your grammar..."
.Vb 2
\&    <RULENAME>                Call named subrule (may be fully qualified)
\&                              save result to $MATCH{RULENAME}
\&
\&    <RULENAME(...)>           Call named subrule, passing args to it
\&
\&    <!RULENAME>               Call subrule and fail if it matches
\&    <!RULENAME(...)>          (shorthand for (?!<.RULENAME>) )
\&
\&    <:IDENT>                  Match contents of $ARG{IDENT} as a pattern
\&    <\e:IDENT>                 Match contents of $ARG{IDENT} as a literal
\&    </:IDENT>                 Match closing delimiter for $ARG{IDENT}
\&
\&    <%HASH>                   Match longest possible key of hash
\&    <%HASH {PAT}>             Match any key of hash that also matches PAT
\&
\&    </IDENT>                  Match closing delimiter for $MATCH{IDENT}
\&    <\e_IDENT>                 Match the literal contents of $MATCH{IDENT}
\&
\&    <ALIAS= RULENAME>         Call subrule, save result in $MATCH{ALIAS}
\&    <ALIAS= %HASH>            Match a hash key, save key in $MATCH{ALIAS}
\&    <ALIAS= ( PATTERN )>      Match pattern, save match in $MATCH{ALIAS}
\&    <ALIAS= (?{ CODE })>      Execute code, save value in $MATCH{ALIAS}
\&    <ALIAS= \*(AqSTR\*(Aq >           Save specified string in $MATCH{ALIAS}
\&    <ALIAS= 42 >              Save specified number in $MATCH{ALIAS}
\&    <ALIAS= /IDENT>           Match closing delim, save as $MATCH{ALIAS}
\&    <ALIAS= \e_IDENT>          Match \*(Aq$MATCH{IDENT}\*(Aq, save as $MATCH{ALIAS}
\&
\&    <.SUBRULE>                Call subrule (one of the above forms),
\&                              but don\*(Aqt save the result in %MATCH
\&
\&
\&    <[SUBRULE]>               Call subrule (one of the above forms), but
\&                              append result instead of overwriting it
\&
\&    <SUBRULE1>+ % <SUBRULE2>  Match one or more repetitions of SUBRULE1
\&                              as long as they\*(Aqre separated by SUBRULE2
\&    <SUBRULE1> ** <SUBRULE2>  Same (only for backwards compatibility)
\&
\&    <SUBRULE1>* % <SUBRULE2>  Match zero or more repetitions of SUBRULE1
\&                              as long as they\*(Aqre separated by SUBRULE2
\&
\&    <SUBRULE1>* %% <SUBRULE2> Match zero or more repetitions of SUBRULE1
\&                              as long as they\*(Aqre separated by SUBRULE2
\&                              and allow an optional trailing SUBRULE2
.Ve
.SS "In your grammar's code blocks..."
.IX Subsection "In your grammar's code blocks..."
.Vb 7
\&    $CAPTURE    Alias for $^N (the most recent paren capture)
\&    $CONTEXT    Another alias for $^N
\&    $INDEX      Current index of next matching position in string
\&    %MATCH      Current rule\*(Aqs result\-hash
\&    $MATCH      Magic override value (returned instead of result\-hash)
\&    %ARG        Current rule\*(Aqs argument hash
\&    $DEBUG      Current match\-time debugging mode
.Ve
.SS Directives...
.IX Subsection "Directives..."
.Vb 12
\&    <require: (?{ CODE })   >  Fail if code evaluates false
\&    <timeout: INT           >  Fail after specified number of seconds
\&    <debug:   COMMAND       >  Change match\-time debugging mode
\&    <logfile: LOGFILE       >  Change debugging log file (default: STDERR)
\&    <fatal:   TEXT|(?{CODE})>  Queue error message and fail parse
\&    <error:   TEXT|(?{CODE})>  Queue error message and backtrack
\&    <warning: TEXT|(?{CODE})>  Queue warning message and continue
\&    <log:     TEXT|(?{CODE})>  Explicitly add a message to debugging log
\&    <ws:      PATTERN       >  Override automatic whitespace matching
\&    <minimize:>                Simplify the result of a subrule match
\&    <context:>                 Switch on context substring retention
\&    <nocontext:>               Switch off context substring retention
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module adds a small number of new regex constructs that can be used
within Perl 5.10 patterns to implement complete recursive-descent parsing.
.PP
Perl 5.10 already supports recursive-descent \fImatching\fR, via the new
\&\f(CW\*(C`(?<name>...)\*(C'\fR and \f(CW\*(C`(?&name)\*(C'\fR constructs. For example, here is
a simple matcher for a subset of the LaTeX markup language:
.PP
.Vb 2
\&    $matcher = qr{
\&        (?&File)
\&
\&        (?(DEFINE)
\&            (?<File>     (?&Element)* )
\&
\&            (?<Element>  \es* (?&Command)
\&                      |  \es* (?&Literal)
\&            )
\&
\&            (?<Command>  \e\e \es* (?&Literal) \es* (?&Options)? \es* (?&Args)? )
\&
\&            (?<Options>  \e[ \es* (?:(?&Option) (?:\es*,\es* (?&Option) )*)? \es* \e])
\&
\&            (?<Args>     \e{ \es* (?&Element)* \es* \e}  )
\&
\&            (?<Option>   \es* [^][\e$&%#_{}~^\es,]+     )
\&
\&            (?<Literal>  \es* [^][\e$&%#_{}~^\es]+      )
\&        )
\&    }xms
.Ve
.PP
This technique makes it possible to use regexes to recognize complex,
hierarchical\-\-and even recursive\-\-textual structures. The problem is
that Perl 5.10 doesn't provide any support for extracting that
hierarchical data into nested data structures. In other words, using
Perl 5.10 you can \fImatch\fR complex data, but not \fIparse\fR it into an
internally useful form.
.PP
An additional problem when using Perl 5.10 regexes to match complex data
formats is that you have to make sure you remember to insert
whitespace-matching constructs (such as \f(CW\*(C`\es*\*(C'\fR) at every possible position
where the data might contain ignorable whitespace. This reduces the
readability of such patterns, and increases the chance of errors (typically
caused by overlooking a location where whitespace might appear).
.PP
The Regexp::Grammars module solves both those problems.
.PP
If you import the module into a particular lexical scope, it
preprocesses any regex in that scope, so as to implement a number of
extensions to the standard Perl 5.10 regex syntax. These extensions
simplify the task of defining and calling subrules within a grammar, and
allow those subrule calls to capture and retain the components of they
match in a proper hierarchical manner.
.PP
For example, the above LaTeX matcher could be converted to a full LaTeX parser
(and considerably tidied up at the same time), like so:
.PP
.Vb 3
\&    use Regexp::Grammars;
\&    $parser = qr{
\&        <File>
\&
\&        <rule: File>       <[Element]>*
\&
\&        <rule: Element>    <Command> | <Literal>
\&
\&        <rule: Command>    \e\e  <Literal>  <Options>?  <Args>?
\&
\&        <rule: Options>    \e[  <[Option]>+ % (,)  \e]
\&
\&        <rule: Args>       \e{  <[Element]>*  \e}
\&
\&        <rule: Option>     [^][\e$&%#_{}~^\es,]+
\&
\&        <rule: Literal>    [^][\e$&%#_{}~^\es]+
\&    }xms
.Ve
.PP
Note that there is no need to explicitly place \f(CW\*(C`\es*\*(C'\fR subpatterns throughout
the rules; that is taken care of automatically.
.PP
If the Regexp::Grammars version of this regex were successfully matched
against some appropriate LaTeX document, each rule would call the
subrules specified within it, and then return a hash containing whatever
result each of those subrules returned, with each result indexed by the
subrule's name.
.PP
That is, if the rule named \f(CW\*(C`Command\*(C'\fR were invoked, it would first try
to match a backslash, then it would call the three subrules
\&\f(CW\*(C`<Literal>\*(C'\fR, \f(CW\*(C`<Options>\*(C'\fR, and \f(CW\*(C`<Args>\*(C'\fR (in that sequence). If
they all matched successfully, the \f(CW\*(C`Command\*(C'\fR rule would then return a
hash with three keys: \f(CW\*(AqLiteral\*(Aq\fR, \f(CW\*(AqOptions\*(Aq\fR, and \f(CW\*(AqArgs\*(Aq\fR. The value
for each of those hash entries would be whatever result-hash the
subrules themselves had returned when matched.
.PP
In this way, each level of the hierarchical regex can generate hashes
recording everything its own subrules matched, so when the entire pattern
matches, it produces a tree of nested hashes that represent the
structured data the pattern matched.
.PP
For example, if the previous regex grammar were matched against a string
containing:
.PP
.Vb 2
\&    \edocumentclass[a4paper,11pt]{article}
\&    \eauthor{D. Conway}
.Ve
.PP
it would automatically extract a data structure equivalent to the
following (but with several extra "empty" keys, which are described in
"Subrule results"):
.PP
.Vb 10
\&    {
\&        \*(Aqfile\*(Aq => {
\&            \*(Aqelement\*(Aq => [
\&                {
\&                    \*(Aqcommand\*(Aq => {
\&                        \*(Aqliteral\*(Aq => \*(Aqdocumentclass\*(Aq,
\&                        \*(Aqoptions\*(Aq => {
\&                            \*(Aqoption\*(Aq  => [ \*(Aqa4paper\*(Aq, \*(Aq11pt\*(Aq ],
\&                        },
\&                        \*(Aqargs\*(Aq    => {
\&                            \*(Aqelement\*(Aq => [ \*(Aqarticle\*(Aq ],
\&                        }
\&                    }
\&                },
\&                {
\&                    \*(Aqcommand\*(Aq => {
\&                        \*(Aqliteral\*(Aq => \*(Aqauthor\*(Aq,
\&                        \*(Aqargs\*(Aq => {
\&                            \*(Aqelement\*(Aq => [
\&                                {
\&                                    \*(Aqliteral\*(Aq => \*(AqD.\*(Aq,
\&                                },
\&                                {
\&                                    \*(Aqliteral\*(Aq => \*(AqConway\*(Aq,
\&                                }
\&                            ]
\&                        }
\&                    }
\&                }
\&            ]
\&        }
\&    }
.Ve
.PP
The data structure that Regexp::Grammars produces from a regex match
is available to the surrounding program in the magic variable \f(CW\*(C`%/\*(C'\fR.
.PP
Regexp::Grammars provides many features that simplify the extraction of
hierarchical data via a regex match, and also some features that can
simplify the processing of that data once it has been extracted. The
following sections explain each of those features, and some of the
parsing techniques they support.
.SS "Setting up the module"
.IX Subsection "Setting up the module"
Just add:
.PP
.Vb 1
\&    use Regexp::Grammars;
.Ve
.PP
to any lexical scope. Any regexes within that scope will automatically now
implement the new parsing constructs:
.PP
.Vb 1
\&    use Regexp::Grammars;
\&
\&    my $parser = qr/ regex with $extra <chocolatey> grammar bits /;
.Ve
.PP
Note that you do not to use the \f(CW\*(C`/x\*(C'\fR modifier when declaring a regex
grammar (though you certainly may). But even if you don't, the module
quietly adds a \f(CW\*(C`/x\*(C'\fR to every regex within the scope of its usage.
Otherwise, the default \fI"a whitespace character matches exactly that
whitespace character"\fR behaviour of Perl regexes would mess up your
grammar's parsing. If you need the non\-\f(CW\*(C`/x\*(C'\fR behaviour, you can still
use the \f(CW\*(C`(?\-x)\*(C'\fR of \f(CW\*(C`(?\-x:...)\*(C'\fR directives to switch off \f(CW\*(C`/x\*(C'\fR within
one or more of your grammar's components.
.PP
Once the grammar has been processed, you can then match text against the
extended regexes, in the usual manner (i.e. via a \f(CW\*(C`=~\*(C'\fR match):
.PP
.Vb 3
\&    if ($input_text =~ $parser) {
\&        ...
\&    }
.Ve
.PP
After a successful match, the variable \f(CW\*(C`%/\*(C'\fR will contain a series of
nested hashes representing the structured hierarchical data captured
during the parse.
.SS "Structure of a Regexp::Grammars grammar"
.IX Subsection "Structure of a Regexp::Grammars grammar"
A Regexp::Grammars specification consists of a \fIstart-pattern\fR (which
may include both standard Perl 5.10 regex syntax, as well as special
Regexp::Grammars directives), followed by one or more rule or token
definitions.
.PP
For example:
.PP
.Vb 2
\&    use Regexp::Grammars;
\&    my $balanced_brackets = qr{
\&
\&        # Start\-pattern...
\&        <paren_pair> | <brace_pair>
\&
\&        # Rule definition...
\&        <rule: paren_pair>
\&            \e(  (?: <escape> | <paren_pair> | <brace_pair> | [^()] )*  \e)
\&
\&        # Rule definition...
\&        <rule: brace_pair>
\&            \e{  (?: <escape> | <paren_pair> | <brace_pair> | [^{}] )*  \e}
\&
\&        # Token definition...
\&        <token: escape>
\&            \e\e .
\&    }xms;
.Ve
.PP
The start-pattern at the beginning of the grammar acts like the
"top" token of the grammar, and must be matched completely for the
grammar to match.
.PP
This pattern is treated like a token for whitespace
matching behaviour (see "Tokens vs rules (whitespace handling)").
That is, whitespace in the start-pattern is treated like whitespace
in any normal Perl regex.
.PP
The rules and tokens are declarations only and they are not directly matched.
Instead, they act like subroutines, and are invoked by name from the
initial pattern (or from within a rule or token).
.PP
Each rule or token extends from the directive that introduces it up to either
the next rule or token directive, or (in the case of the final rule or token)
to the end of the grammar.
.SS "Tokens vs rules (whitespace handling)"
.IX Subsection "Tokens vs rules (whitespace handling)"
The difference between a token and a rule is that a token treats any
whitespace within it exactly as a normal Perl regular expression would.
That is, a sequence of whitespace in a token is ignored if the \f(CW\*(C`/x\*(C'\fR
modifier is in effect, or else matches the same literal sequence of
whitespace characters (if \f(CW\*(C`/x\*(C'\fR is not in effect).
.PP
In a rule, most sequences of whitespace are treated as matching the
implicit subrule \f(CW\*(C`<.ws>\*(C'\fR, which is automatically predefined to
match optional whitespace (i.e. \f(CW\*(C`\es*\*(C'\fR).
.PP
Exceptions to this behaviour are whitespaces before a \f(CW\*(C`|\*(C'\fR or a code
block or an explicit space-matcher (such as \f(CW\*(C`<ws>\*(C'\fR or \f(CW\*(C`\es\*(C'\fR),
or at the very end of the rule)
.PP
In other words, a rule such as:
.PP
.Vb 2
\&    <rule: sentence>   <noun> <verb>
\&                   |   <verb> <noun>
.Ve
.PP
is equivalent to a token with added non-capturing whitespace matching:
.PP
.Vb 2
\&    <token: sentence>  <.ws> <noun> <.ws> <verb>
\&                    |  <.ws> <verb> <.ws> <noun>
.Ve
.PP
You can explicitly define a \f(CW\*(C`<ws>\*(C'\fR token to change that default
behaviour. For example, you could alter the definition of "whitespace" to
include Perlish comments, by adding an explicit \f(CW\*(C`<token: ws>\*(C'\fR:
.PP
.Vb 2
\&    <token: ws>
\&        (?: \es+ | #[^\en]* )*
.Ve
.PP
But be careful not to define \f(CW\*(C`<ws>\*(C'\fR as a rule, as this will lead to
all kinds of infinitely recursive unpleasantness.
.PP
\fIPer-rule whitespace handling\fR
.IX Subsection "Per-rule whitespace handling"
.PP
Redefining the \f(CW\*(C`<ws>\*(C'\fR token changes its behaviour throughout the
entire grammar, within every rule definition. Usually that's appropriate,
but sometimes you need finer-grained control over whitespace handling.
.PP
So Regexp::Grammars provides the \f(CW\*(C`<ws:>\*(C'\fR directive, which allows
you to override the implicit whitespace-matches-whitespace behaviour
only within the current rule.
.PP
Note that this directive does \fInot\fR redefine \f(CW\*(C`<ws>\*(C'\fR within the
rule; it simply specifies what to replace each whitespace sequence with
(instead of replacing each with a \f(CW\*(C`<ws>\*(C'\fR call).
.PP
For example, if a language allows one kind of comment between statements
and another within statements, you could parse it with:
.PP
.Vb 3
\&    <rule: program>
\&        # One type of comment between...
\&        <ws: (\es++ | \e# .*? \en)* >
\&
\&        # ...colon\-separated statements...
\&        <[statement]>+ % ( ; )
\&
\&
\&    <rule: statement>
\&        # Another type of comment...
\&        <ws: (\es*+ | \e#{ .*? }\e# )* >
\&
\&        # ...between comma\-separated commands...
\&        <cmd>  <[arg]>+ % ( , )
.Ve
.PP
Note that each directive only applies to the rule in which it is
specified. In every other rule in the grammar, whitespace would still
match the usual \f(CW\*(C`<ws>\*(C'\fR subrule.
.SS "Calling subrules"
.IX Subsection "Calling subrules"
To invoke a rule to match at any point, just enclose the rule's name in angle
brackets (like in Perl 6). There must be no space between the opening bracket
and the rulename. For example::
.PP
.Vb 4
\&    qr{
\&        file:             # Match literal sequence \*(Aqf\*(Aq \*(Aqi\*(Aq \*(Aql\*(Aq \*(Aqe\*(Aq \*(Aq:\*(Aq
\&        <name>            # Call <rule: name>
\&        <options>?        # Call <rule: options> (it\*(Aqs okay if it fails)
\&
\&        <rule: name>
\&            # etc.
\&    }x;
.Ve
.PP
If you need to match a literal pattern that would otherwise look like a
subrule call, just backslash-escape the leading angle:
.PP
.Vb 4
\&    qr{
\&        file:             # Match literal sequence \*(Aqf\*(Aq \*(Aqi\*(Aq \*(Aql\*(Aq \*(Aqe\*(Aq \*(Aq:\*(Aq
\&        \e<name>           # Match literal sequence \*(Aq<\*(Aq \*(Aqn\*(Aq \*(Aqa\*(Aq \*(Aqm\*(Aq \*(Aqe\*(Aq \*(Aq>\*(Aq
\&        <options>?        # Call <rule: options> (it\*(Aqs okay if it fails)
\&
\&        <rule: name>
\&            # etc.
\&    }x;
.Ve
.SS "Subrule results"
.IX Subsection "Subrule results"
If a subrule call successfully matches, the result of that match is a
reference to a hash. That hash reference is stored in the current rule's
own result-hash, under the name of the subrule that was invoked. The
hash will, in turn, contain the results of any more deeply nested
subrule calls, each stored under the name by which the nested
subrule was invoked.
.PP
In other words, if the rule \f(CW\*(C`sentence\*(C'\fR is defined:
.PP
.Vb 2
\&    <rule: sentence>
\&        <noun> <verb> <object>
.Ve
.PP
then successfully calling the rule:
.PP
.Vb 1
\&    <sentence>
.Ve
.PP
causes a new hash entry at the current nesting level. That entry's key will be
\&\f(CW\*(Aqsentence\*(Aq\fR and its value will be a reference to a hash, which in turn will
have keys: \f(CW\*(Aqnoun\*(Aq\fR, \f(CW\*(Aqverb\*(Aq\fR, and \f(CW\*(Aqobject\*(Aq\fR.
.PP
In addition each result-hash has one extra key: the empty string. The
value for this key is whatever substring the entire subrule call matched.
This value is known as the \fIcontext substring\fR.
.PP
So, for example, a successful call to \f(CW\*(C`<sentence>\*(C'\fR might add
something like the following to the current result-hash:
.PP
.Vb 10
\&    sentence => {
\&        ""     => \*(AqI saw a dog\*(Aq,
\&        noun   => \*(AqI\*(Aq,
\&        verb   => \*(Aqsaw\*(Aq,
\&        object => {
\&            ""      => \*(Aqa dog\*(Aq,
\&            article => \*(Aqa\*(Aq,
\&            noun    => \*(Aqdog\*(Aq,
\&        },
\&    }
.Ve
.PP
Note, however, that if the result-hash at any level contains \fIonly\fR
the empty-string key (i.e. the subrule did not call any sub-subrules or
save any of their nested result-hashes), then the hash is "unpacked"
and just the context substring itself is returned.
.PP
For example, if \f(CW\*(C`<rule: sentence>\*(C'\fR had been defined:
.PP
.Vb 2
\&    <rule: sentence>
\&        I see dead people
.Ve
.PP
then a successful call to the rule would only add:
.PP
.Vb 1
\&    sentence => \*(AqI see dead people\*(Aq
.Ve
.PP
to the current result-hash.
.PP
This is a useful feature because it prevents a series of nested subrule
calls from producing very unwieldy data structures. For example, without
this automatic unpacking, even the simple earlier example:
.PP
.Vb 2
\&    <rule: sentence>
\&        <noun> <verb> <object>
.Ve
.PP
would produce something needlessly complex, such as:
.PP
.Vb 10
\&    sentence => {
\&        ""     => \*(AqI saw a dog\*(Aq,
\&        noun   => {
\&            "" => \*(AqI\*(Aq,
\&        },
\&        verb   => {
\&            "" => \*(Aqsaw\*(Aq,
\&        },
\&        object => {
\&            ""      => \*(Aqa dog\*(Aq,
\&            article => {
\&                "" => \*(Aqa\*(Aq,
\&            },
\&            noun    => {
\&                "" => \*(Aqdog\*(Aq,
\&            },
\&        },
\&    }
.Ve
.PP
\fITurning off the context substring\fR
.IX Subsection "Turning off the context substring"
.PP
The context substring is convenient for debugging and for generating
error messages but, in a large grammar, or when parsing a long string,
the capture and storage of many nested substrings may quickly become
prohibitively expensive.
.PP
So Regexp::Grammars provides a directive to prevent context substrings
from being retained. Any rule or token that includes the directive
\&\f(CW\*(C`<nocontext:>\*(C'\fR anywhere in the rule's body will not retain any
context substring it matches...unless that substring would be the only
entry in its result hash (which only happens within objrules and
objtokens).
.PP
If a \f(CW\*(C`<nocontext:>\*(C'\fR directive appears \fIbefore\fR the first rule or
token definition (i.e. as part of the main pattern), then the entire grammar
will discard all context substrings from every one of its rules
and tokens.
.PP
However, you can override this universal prohibition with a second
directive: \f(CW\*(C`<context:>\*(C'\fR. If this directive appears in any rule or
token, that rule or token \fIwill\fR save its context substring, even if a
global \f(CW\*(C`<nocontext:>\*(C'\fR is in effect.
.PP
This means that this grammar:
.PP
.Vb 2
\&    qr{
\&        <Command>
\&
\&        <rule: Command>
\&            <nocontext:>
\&            <Keyword> <arg=(\eS+)>+ % <.ws>
\&
\&        <token: Keyword>
\&            <Move> | <Copy> | <Delete>
\&
\&        # etc.
\&    }x
.Ve
.PP
and this grammar:
.PP
.Vb 3
\&    qr{
\&        <nocontext:>
\&        <Command>
\&
\&        <rule: Command>
\&            <Keyword> <arg=(\eS+)>+ % <.ws>
\&
\&        <token: Keyword>
\&            <context:>
\&            <Move> | <Copy> | <Delete>
\&
\&        # etc.
\&    }x
.Ve
.PP
will behave identically (saving context substrings for keywords, but not
for commands), except that the first version will also retain the global
context substring (i.e. $/{""}), whereas the second version will not.
.PP
Note that \f(CW\*(C`<context:>\*(C'\fR and \f(CW\*(C`<nocontext:>\*(C'\fR have no effect on,
or even any interaction with, the various
result distillation mechanisms,
which continue to work in the usual way when either or both of the
directives is used.
.SS "Renaming subrule results"
.IX Subsection "Renaming subrule results"
It is not always convenient to have subrule results stored under the
same name as the rule itself. Rule names should be optimized for
understanding the behaviour of the parser, whereas result names should
be optimized for understanding the structure of the data. Often those
two goals are identical, but not always; sometimes rule names need to
describe what the data looks like, while result names need to describe
what the data means.
.PP
For example, sometimes you need to call the same rule twice, to match
two syntactically identical components whose positions give then semantically
distinct meanings:
.PP
.Vb 2
\&    <rule: copy_cmd>
\&        copy <file> <file>
.Ve
.PP
The problem here is that, if the second call to \f(CW\*(C`<file>\*(C'\fR succeeds, its
result-hash will be stored under the key \f(CW\*(Aqfile\*(Aq\fR, clobbering the data that
was returned from the first call to \f(CW\*(C`<file>\*(C'\fR.
.PP
To avoid such problems, Regexp::Grammars allows you to \fIalias\fR any subrule
call, so that it is still invoked by the original name, but its result-hash is
stored under a different key. The syntax for that is:
\&\f(CW\*(C`<\fR\f(CIalias\fR\f(CW=\fR\f(CIrulename\fR\f(CW>\*(C'\fR. For example:
.PP
.Vb 2
\&    <rule: copy_cmd>
\&        copy <from=file> <to=file>
.Ve
.PP
Here, \f(CW\*(C`<rule: file>\*(C'\fR is called twice, with the first result-hash being
stored under the key \f(CW\*(Aqfrom\*(Aq\fR, and the second result-hash being stored under
the key \f(CW\*(Aqto\*(Aq\fR.
.PP
Note, however, that the alias before the \f(CW\*(C`=\*(C'\fR must be a proper
identifier (i.e. a letter or underscore, followed by letters, digits,
and/or underscores). Aliases that start with an underscore and aliases named
\&\f(CW\*(C`MATCH\*(C'\fR have special meaning (see "Private subrule calls" and
"Result distillation" respectively).
.PP
Aliases can also be useful for normalizing data that may appear in different
formats and sequences. For example:
.PP
.Vb 5
\&    <rule: copy_cmd>
\&        copy <from=file>        <to=file>
\&      | dup    <to=file>  as  <from=file>
\&      |      <from=file>  \->    <to=file>
\&      |        <to=file>  <\-  <from=file>
.Ve
.PP
Here, regardless of which order the old and new files are specified, the
result-hash always gets:
.PP
.Vb 4
\&    copy_cmd => {
\&        from => \*(Aqoldfile\*(Aq,
\&          to => \*(Aqnewfile\*(Aq,
\&    }
.Ve
.SS "List-like subrule calls"
.IX Subsection "List-like subrule calls"
If a subrule call is quantified with a repetition specifier:
.PP
.Vb 2
\&    <rule: file_sequence>
\&        <file>+
.Ve
.PP
then each repeated match overwrites the corresponding entry in the
surrounding rule's result-hash, so only the result of the final
repetition will be retained. That is, if the above example matched
the string \f(CW"foo.pl\ bar.py\ baz.php"\fR, then the result-hash would contain:
.PP
.Vb 4
\&    file_sequence {
\&        ""   => \*(Aqfoo.pl bar.py baz.php\*(Aq,
\&        file => \*(Aqbaz.php\*(Aq,
\&    }
.Ve
.PP
Usually, that's not the desired outcome, so Regexp::Grammars provides
another mechanism by which to call a subrule; one that saves \fIall\fR
repetitions of its results.
.PP
A regular subrule call consists of the rule's name surrounded by angle
brackets. If, instead, you surround the rule's name with \f(CW\*(C`<[...]>\*(C'\fR
(angle \fIand\fR square brackets) like so:
.PP
.Vb 2
\&    <rule: file_sequence>
\&        <[file]>+
.Ve
.PP
then the rule is invoked in exactly the same way, but the result of that
submatch is pushed onto an array nested inside the appropriate result-hash
entry. In other words, if the above example matched the same
\&\f(CW"foo.pl\ bar.py\ baz.php"\fR string, the result-hash would contain:
.PP
.Vb 4
\&    file_sequence {
\&        ""   => \*(Aqfoo.pl bar.py baz.php\*(Aq,
\&        file => [ \*(Aqfoo.pl\*(Aq, \*(Aqbar.py\*(Aq, \*(Aqbaz.php\*(Aq ],
\&    }
.Ve
.PP
This "listifying subrule call" can also be useful for non-repeated subrule
calls, if the same subrule is invoked in several places in a grammar. For
example if a cmdline option could be given either one or two values, you
might parse it:
.PP
.Vb 2
\&    <rule: size_option>
\&        \-size <[size]> (?: x <[size]> )?
.Ve
.PP
The result-hash entry for \f(CW\*(Aqsize\*(Aq\fR would then always contain an array,
with either one or two elements, depending on the input being parsed.
.PP
Listifying subrules can also be given aliases,
just like ordinary subrules. The alias is always specified inside the square
brackets:
.PP
.Vb 2
\&    <rule: size_option>
\&        \-size <[size=pos_integer]> (?: x <[size=pos_integer]> )?
.Ve
.PP
Here, the sizes are parsed using the \f(CW\*(C`pos_integer\*(C'\fR rule, but saved in the
result-hash in an array under the key \f(CW\*(Aqsize\*(Aq\fR.
.SS "Parametric subrules"
.IX Subsection "Parametric subrules"
When a subrule is invoked, it can be passed a set of named arguments
(specified as \fIkey\fR\f(CW\*(C`=>\*(C'\fR\fIvalues\fR pairs). This argument list is
placed in a normal Perl regex code block and must appear immediately
after the subrule name, before the closing angle bracket.
.PP
Within the subrule that has been invoked, the arguments can be accessed
via the special hash \f(CW%ARG\fR. For example:
.PP
.Vb 4
\&    <rule: block>
\&        <tag>
\&            <[block]>*
\&        <end_tag(?{ tag=>$MATCH{tag} })>  # ...call subrule with argument
\&
\&    <token: end_tag>
\&        end_ (??{ quotemeta $ARG{tag} })
.Ve
.PP
Here the \f(CW\*(C`block\*(C'\fR rule first matches a \f(CW\*(C`<tag>\*(C'\fR, and the corresponding
substring is saved in \f(CW$MATCH{tag}\fR. It then matches any number of nested
blocks. Finally it invokes the \f(CW\*(C`<end_tag>\*(C'\fR subrule, passing it an
argument whose name is \f(CW\*(Aqtag\*(Aq\fR and whose value is the current value of
\&\f(CW$MATCH{tag}\fR (i.e. the original opening tag).
.PP
When it is thus invoked, the \f(CW\*(C`end_tag\*(C'\fR token first matches \f(CW\*(Aqend_\*(Aq\fR,
then interpolates the literal value of the \f(CW\*(Aqtag\*(Aq\fR argument and
attempts to match it.
.PP
Any number of named arguments can be passed when a subrule is invoked.
For example, we could generalize the \f(CW\*(C`end_tag\*(C'\fR rule to allow any prefix
(not just \f(CW\*(Aqend_\*(Aq\fR), and also to allow for 'if...fi'\-style reversed
tags, like so:
.PP
.Vb 4
\&    <rule: block>
\&        <tag>
\&            <[block]>*
\&        <end_tag (?{ prefix=>\*(Aqend\*(Aq, tag=>$MATCH{tag} })>
\&
\&    <token: end_tag>
\&        (??{ $ARG{prefix} // q{(?!)} })      # ...prefix as pattern
\&        (??{ quotemeta $ARG{tag} })          # ...tag as literal
\&      |
\&        (??{ quotemeta reverse $ARG{tag} })  # ...reversed tag
.Ve
.PP
Note that, if you do not need to interpolate values (such as
\&\f(CW$MATCH{tag}\fR) into a subrule's argument list, you can
use simple parentheses instead of \f(CW\*(C`(?{...})\*(C'\fR, like so:
.PP
.Vb 1
\&        <end_tag( prefix=>\*(Aqend\*(Aq, tag=>\*(Aqhead\*(Aq )>
.Ve
.PP
The only types of values you can use in this simplified
syntax are numbers and single-quote-delimited strings.
For anything more complex, put the argument list
in a full \f(CW\*(C`(?{...})\*(C'\fR.
.PP
As the earlier examples show, the single most common
type of argument is one of the form:
\&\fIIDENTIFIER\fR \f(CW\*(C`=> $MATCH{\*(C'\fR\fIIDENTIFIER\fR\f(CW\*(C`}\*(C'\fR. That is,
it's a common requirement to pass an element of \f(CW%MATCH\fR
into a subrule, named with its own key.
.PP
Because this is such a common usage, Regexp::Grammars
provides a shortcut. If you use simple parentheses (instead
of \f(CW\*(C`(?{...})\*(C'\fR parentheses) then instead of a pair, you can
specify an argument using a colon followed by an identifier.
This argument is replaced by a named argument whose name
is the identifier and whose value is the corresponding item
from \f(CW%MATCH\fR. So, for example, instead of:
.PP
.Vb 1
\&        <end_tag(?{ prefix=>\*(Aqend\*(Aq, tag=>$MATCH{tag} })>
.Ve
.PP
you can just write:
.PP
.Vb 1
\&        <end_tag( prefix=>\*(Aqend\*(Aq, :tag )>
.Ve
.PP
Note that, from Perl 5.20 onwards, due to changes in the way that
Perl parses regexes, Regexp::Grammars does not support explicitly passing
elements of \f(CW%MATCH\fR as argument values within a list subrule
(yeah, it's a very specific and obscure edge-case):
.PP
.Vb 1
\&        <[end_tag(?{ prefix=>\*(Aqend\*(Aq, tag=>$MATCH{tag} })]>   # Does not work
.Ve
.PP
Note, however, that the shortcut:
.PP
.Vb 1
\&        <[end_tag( prefix=>\*(Aqend\*(Aq, :tag )]>
.Ve
.PP
still works correctly.
.PP
\fIAccessing subrule arguments more cleanly\fR
.IX Subsection "Accessing subrule arguments more cleanly"
.PP
As the preceding examples illustrate, using subrule arguments
effectively generally requires the use of run-time interpolated
subpatterns via the \f(CW\*(C`(??{...})\*(C'\fR construct.
.PP
This produces ugly rule bodies such as:
.PP
.Vb 5
\&    <token: end_tag>
\&        (??{ $ARG{prefix} // q{(?!)} })      # ...prefix as pattern
\&        (??{ quotemeta $ARG{tag} })          # ...tag as literal
\&      |
\&        (??{ quotemeta reverse $ARG{tag} })  # ...reversed tag
.Ve
.PP
To simplify these common usages, Regexp::Grammars provides
three convenience constructs.
.PP
A subrule call of the form \f(CW\*(C`<:\*(C'\fR\fIidentifier\fR\f(CW\*(C`>\*(C'\fR
is equivalent to:
.PP
.Vb 1
\&    (??{ $ARG{\*(Aqidentifier\*(Aq} // q{(?!)} })
.Ve
.PP
Namely: \fI"Match the contents of \fR\f(CI$ARG{\*(Aqidentifier\*(Aq}\fR\fI,
treating those contents as a pattern."\fR
.PP
A subrule call of the form \f(CW\*(C`<\e:\*(C'\fR\fIidentifier\fR\f(CW\*(C`>\*(C'\fR
(that is: a matchref
with a colon after the backslash) is equivalent to:
.PP
.Vb 4
\&    (??{ defined $ARG{\*(Aqidentifier\*(Aq}
\&            ? quotemeta($ARG{\*(Aqidentifier\*(Aq})
\&            : \*(Aq(?!)\*(Aq
\&    })
.Ve
.PP
Namely: \fI"Match the contents of \fR\f(CI$ARG{\*(Aqidentifier\*(Aq}\fR\fI,
treating those contents as a literal."\fR
.PP
A subrule call of the form \f(CW\*(C`</:\*(C'\fR\fIidentifier\fR\f(CW\*(C`>\*(C'\fR
(that is: an invertref
with a colon after the forward slash) is equivalent to:
.PP
.Vb 4
\&    (??{ defined $ARG{\*(Aqidentifier\*(Aq}
\&            ? quotemeta(reverse $ARG{\*(Aqidentifier\*(Aq})
\&            : \*(Aq(?!)\*(Aq
\&    })
.Ve
.PP
Namely: \fI"Match the closing delimiter corresponding to
the contents of \fR\f(CI$ARG{\*(Aqidentifier\*(Aq}\fR\fI, as if it were a literal"\fR.
.PP
The availability of these three constructs mean that we could rewrite
the above \f(CW\*(C`<end_tag>\*(C'\fR token much more cleanly as:
.PP
.Vb 5
\&    <token: end_tag>
\&        <:prefix>      # ...prefix as pattern
\&        <\e:tag>        # ...tag as a literal
\&      |
\&        </:tag>        # ...reversed tag
.Ve
.PP
In general these constructs mean that, within a subrule,
if you want to match an argument passed to that subrule,
you use \f(CW\*(C`<:\*(C'\fR\fIARGNAME\fR\f(CW\*(C`>\*(C'\fR (to match the argument
as a pattern) or \f(CW\*(C`<\e:\*(C'\fR\fIARGNAME\fR\f(CW\*(C`>\*(C'\fR (to match
the argument as a literal).
.PP
Note the consistent mnemonic in these various subrule-like
interpolations of named arguments: the name is always prefixed by a
colon.
.PP
In other words, the \f(CW\*(C`<:ARGNAME>\*(C'\fR form works just like
a \f(CW\*(C`<RULENAME>\*(C'\fR, except that the leading colon tells
Regexp::Grammars to use the contents of \f(CW$ARG{\*(AqARGNAME\*(Aq}\fR
as the subpattern, instead of the contents of \f(CW\*(C`(?&RULENAME)\*(C'\fR
.PP
Likewise, the \f(CW\*(C`<\e:ARGNAME>\*(C'\fR and \f(CW\*(C`</:ARGNAME>\*(C'\fR constructs work
exactly like \f(CW\*(C`<\e_MATCHNAME>\*(C'\fR and \f(CW\*(C`</INVERTNAME>\*(C'\fR respectively,
except that the leading colon indicates that the matchref or invertref
should be taken from \f(CW%ARG\fR instead of from \f(CW%MATCH\fR.
.SS Pseudo-subrules
.IX Subsection "Pseudo-subrules"
Aliases can also be given to standard Perl subpatterns, as well as to
code blocks within a regex. The syntax for subpatterns is:
.PP
.Vb 1
\&    <ALIAS= (SUBPATTERN) >
.Ve
.PP
In other words, the syntax is exactly like an aliased subrule call, except
that the rule name is replaced with a set of parentheses containing the
subpattern. Any parentheses\-\-capturing or non\-capturing\-\-will do.
.PP
The effect of aliasing a standard subpattern is to cause whatever that
subpattern matches to be saved in the result-hash, using the alias as
its key. For example:
.PP
.Vb 1
\&    <rule: file_command>
\&
\&        <cmd=(mv|cp|ln)>  <from=file>  <to=file>
.Ve
.PP
Here, the \f(CW\*(C`<cmd=(mv|cp|ln)>\*(C'\fR is treated exactly like a regular
\&\f(CW\*(C`(mv|cp|ln)\*(C'\fR, but whatever substring it matches is saved in the result-hash
under the key \f(CW\*(Aqcmd\*(Aq\fR.
.PP
The syntax for aliasing code blocks is:
.PP
.Vb 1
\&    <ALIAS= (?{ your($code\->here) }) >
.Ve
.PP
Note, however, that the code block must be specified in the standard Perl 5.10
regex notation: \f(CW\*(C`(?{...})\*(C'\fR. A common mistake is to write:
.PP
.Vb 1
\&    <ALIAS= { your($code\->here } >
.Ve
.PP
instead, which will attempt to interpolate \f(CW$code\fR before
the regex is even compiled, as such variables are only "protected" from
interpolation inside a \f(CW\*(C`(?{...})\*(C'\fR.
.PP
When correctly specified, this construct executes the code in the block
and saves the result of that execution in the result-hash, using the
alias as its key. Aliased code blocks are useful for adding semantic
information based on which branch of a rule is executed. For example,
consider the \f(CW\*(C`copy_cmd\*(C'\fR alternatives shown earlier:
.PP
.Vb 5
\&    <rule: copy_cmd>
\&        copy <from=file>        <to=file>
\&      | dup    <to=file>  as  <from=file>
\&      |      <from=file>  \->    <to=file>
\&      |        <to=file>  <\-  <from=file>
.Ve
.PP
Using aliased code blocks, you could add an extra field to the result\-
hash to describe which form of the command was detected, like so:
.PP
.Vb 5
\&    <rule: copy_cmd>
\&        copy <from=file>        <to=file>  <type=(?{ \*(Aqstd\*(Aq })>
\&      | dup    <to=file>  as  <from=file>  <type=(?{ \*(Aqrev\*(Aq })>
\&      |      <from=file>  \->    <to=file>  <type=(?{  +1   })>
\&      |        <to=file>  <\-  <from=file>  <type=(?{  \-1   })>
.Ve
.PP
Now, if the rule matched, the result-hash would contain something like:
.PP
.Vb 5
\&    copy_cmd => {
\&        from => \*(Aqoldfile\*(Aq,
\&          to => \*(Aqnewfile\*(Aq,
\&        type => \*(Aqfwd\*(Aq,
\&    }
.Ve
.PP
Note that, in addition to the semantics described above, aliased
subpatterns and code blocks also become visible to Regexp::Grammars'
integrated debugger (see Debugging).
.SS "Aliased literals"
.IX Subsection "Aliased literals"
As the previous example illustrates, it is inconveniently verbose to
assign constants via aliased code blocks. So Regexp::Grammars provides a
short-cut. It is possible to directly alias a numeric literal or a
single-quote delimited literal string, without putting either inside a code
block. For example, the previous example could also be written:
.PP
.Vb 5
\&    <rule: copy_cmd>
\&        copy <from=file>        <to=file>  <type=\*(Aqstd\*(Aq>
\&      | dup    <to=file>  as  <from=file>  <type=\*(Aqrev\*(Aq>
\&      |      <from=file>  \->    <to=file>  <type= +1  >
\&      |        <to=file>  <\-  <from=file>  <type= \-1  >
.Ve
.PP
Note that only these two forms of literal are supported in this
abbreviated syntax.
.SS "Amnesiac subrule calls"
.IX Subsection "Amnesiac subrule calls"
By default, every subrule call saves its result into the result-hash, either
under its own name, or under an alias.
.PP
However, sometimes you may want to refactor some literal part of a rule
into one or more subrules, without having those submatches added to the
result-hash. The syntax for calling a subrule, but ignoring its return value
is:
.PP
.Vb 1
\&    <.SUBRULE>
.Ve
.PP
(which is stolen directly from Perl 6).
.PP
For example, you may prefer to rewrite a rule such as:
.PP
.Vb 1
\&    <rule: paren_pair>
\&
\&        \e(
\&            (?: <escape> | <paren_pair> | <brace_pair> | [^()] )*
\&        \e)
.Ve
.PP
without any literal matching, like so:
.PP
.Vb 1
\&    <rule: paren_pair>
\&
\&        <.left_paren>
\&            (?: <escape> | <paren_pair> | <brace_pair> | <.non_paren> )*
\&        <.right_paren>
\&
\&    <token: left_paren>   \e(
\&    <token: right_paren>  \e)
\&    <token: non_paren>    [^()]
.Ve
.PP
Moreover, as the individual components inside the parentheses probably
aren't being captured for any useful purpose either, you could further
optimize that to:
.PP
.Vb 1
\&    <rule: paren_pair>
\&
\&        <.left_paren>
\&            (?: <.escape> | <.paren_pair> | <.brace_pair> | <.non_paren> )*
\&        <.right_paren>
.Ve
.PP
Note that you can also use the dot modifier on an aliased subpattern:
.PP
.Vb 1
\&    <.Alias= (SUBPATTERN) >
.Ve
.PP
This seemingly contradictory behaviour (of giving a subpattern a name,
then deliberately ignoring that name) actually does make sense in one
situation. Providing the alias makes the subpattern visible to the
debugger, while using the dot stops it from affecting the result-hash.
See "Debugging non-grammars" for an example of this usage.
.SS "Private subrule calls"
.IX Subsection "Private subrule calls"
If a rule name (or an alias) begins with an underscore:
.PP
.Vb 2
\&     <_RULENAME>       <_ALIAS=RULENAME>
\&    <[_RULENAME]>     <[_ALIAS=RULENAME]>
.Ve
.PP
then matching proceeds as normal, and any result that is returned is
stored in the current result-hash in the usual way.
.PP
However, when any rule finishes (and just before it returns) it first
filters its result-hash, removing any entries whose keys begin with an
underscore. This means that any subrule with an underscored name (or
with an underscored alias) remembers its result, but only until the end
of the current rule. Its results are effectively private to the current
rule.
.PP
This is especially useful in conjunction with
result distillation.
.SS "Lookahead (zero-width) subrules"
.IX Subsection "Lookahead (zero-width) subrules"
Non-capturing subrule calls can be used in normal lookaheads:
.PP
.Vb 3
\&    <rule: qualified_typename>
\&        # A valid typename and has a :: in it...
\&        (?= <.typename> )  [^\es:]+ :: \eS+
\&
\&    <rule: identifier>
\&        # An alpha followed by alnums (but not a valid typename)...
\&        (?! <.typename> )    [^\eW\ed]\ew*
.Ve
.PP
but the syntax is a little unwieldy. More importantly, an internal
problem with backtracking causes positive lookaheads to mess up
the module's named capturing mechanism.
.PP
So Regexp::Grammars provides two shorthands:
.PP
.Vb 2
\&    <!typename>        same as: (?! <.typename> )
\&    <?typename>        same as: (?= <.typename> ) ...but works correctly!
.Ve
.PP
These two constructs can also be called with arguments, if necessary:
.PP
.Vb 6
\&    <rule: Command>
\&        <Keyword>
\&        (?:
\&            <!Terminator(:Keyword)>  <Args=(\eS+)>
\&        )?
\&        <Terminator(:Keyword)>
.Ve
.PP
Note that, as the above equivalences imply, neither of these forms of a
subroutine call ever captures what it matches.
.SS "Matching separated lists"
.IX Subsection "Matching separated lists"
One of the commonest tasks in text parsing is to match a list of unspecified
length, in which items are separated by a fixed token. Things like:
.PP
.Vb 1
\&    1, 2, 3 , 4 ,13, 91        # Numbers separated by commas and spaces
\&
\&    g\-c\-a\-g\-t\-t\-a\-c\-a          # DNA bases separated by dashes
\&
\&    /usr/local/bin             # Names separated by directory markers
\&
\&    /usr:/usr/local:bin        # Directories separated by colons
.Ve
.PP
The usual construct required to parse these kinds of structures is either:
.PP
.Vb 1
\&    <rule: list>
\&
\&        <item> <separator> <list>     # recursive definition
\&      | <item>                        # base case
.Ve
.PP
or, if you want to allow zero-or-more items instead of requiring one-or-more:
.PP
.Vb 2
\&    <rule: list_opt>
\&        <list>?                       # entire list may be missing
\&
\&    <rule: list>                      # as before...
\&        <item> <separator> <list>     #   recursive definition
\&      | <item>                        #   base case
.Ve
.PP
Or, more efficiently, but less prettily:
.PP
.Vb 2
\&    <rule: list>
\&        <[item]> (?: <separator> <[item]> )*           # one\-or\-more
\&
\&    <rule: list_opt>
\&        (?: <[item]> (?: <separator> <[item]> )* )?    # zero\-or\-more
.Ve
.PP
Because separated lists are such a common component of grammars,
Regexp::Grammars provides cleaner ways to specify them:
.PP
.Vb 2
\&    <rule: list>
\&        <[item]>+ % <separator>      # one\-or\-more
\&
\&    <rule: list_zom>
\&        <[item]>* % <separator>      # zero\-or\-more
.Ve
.PP
Note that these are just regular repetition qualifiers (i.e. \f(CW\*(C`+\*(C'\fR
and \f(CW\*(C`*\*(C'\fR) applied to a subrule (\f(CW\*(C`<[item]>\*(C'\fR), with a \f(CW\*(C`%\*(C'\fR
modifier after them to specify the required separator between the
repeated matches.
.PP
The number of repetitions matched is controlled both by the nature of
the qualifier (\f(CW\*(C`+\*(C'\fR vs \f(CW\*(C`*\*(C'\fR) and by the subrule specified after the \f(CW\*(C`%\*(C'\fR.
The qualified subrule will be repeatedly matched
for as long as its qualifier allows, provided that the second subrule
also matches \fIbetween\fR those repetitions.
.PP
For example, you can match a parenthesized sequence of one-or-more
numbers separated by commas, such as:
.PP
.Vb 1
\&    (1, 2, 3, 4, 13, 91)        # Numbers separated by commas (and spaces)
.Ve
.PP
with:
.PP
.Vb 1
\&    <rule: number_list>
\&
\&        \e(  <[number]>+ % <comma>  \e)
\&
\&    <token: number>  \ed+
\&    <token: comma>   ,
.Ve
.PP
Note that any spaces round the commas will be ignored because
\&\f(CW\*(C`<number_list>\*(C'\fR is specified as a rule and the \f(CW\*(C`+%\*(C'\fR specifier
has spaces within and around it. To disallow spaces around the commas,
make sure there are no spaces in or around the \f(CW\*(C`+%\*(C'\fR:
.PP
.Vb 1
\&    <rule: number_list_no_spaces>
\&
\&        \e( <[number]>+%<comma> \e)
.Ve
.PP
(or else specify the rule as a token instead).
.PP
Because the \f(CW\*(C`%\*(C'\fR is a modifier applied to a qualifier, you can modify
\&\fIany\fR other repetition qualifier in the same way. For example:
.PP
.Vb 1
\&    <[item]>{2,4} % <sep>   # two\-to\-four items, separated
\&
\&    <[item]>{7}   % <sep>   # exactly 7 items, separated
\&
\&    <[item]>{10,}? % <sep>   # minimum of 10 or more items, separated
.Ve
.PP
You can even do this:
.PP
.Vb 1
\&    <[item]>? % <sep>       # one\-or\-zero items, (theoretically) separated
.Ve
.PP
though the separator specification is, of course, meaningless in that case
as it will never be needed to separate a maximum of one item.
.PP
Within a Regexp::Grammars regex a simple \f(CW\*(C`%\*(C'\fR is always metasyntax, so it cannot
be used to match a literal \f(CW\*(Aq%\*(Aq\fR. Any attempt to do so is immediately fatal
when the regex is compiled:
.PP
.Vb 2
\&    <token: percentage>
\&        \ed{1,3} %                # Fatal. Will not match "7%", "100%", etc.
\&
\&    <token: perl_hash>
\&        % <ident>                # Fatal. Will not match "%foo", "%bar", etc.
\&
\&    <token: perl_mod>
\&        <expr> % <expr>          # Fatal. Will not match "$n % 2", etc.
.Ve
.PP
If you need to match a literal \f(CW\*(C`%\*(C'\fR immediately after a repetition, quote it
with a backslash:
.PP
.Vb 2
\&    <token: percentage>
\&        \ed{1,3} \e%               # Okay. Will match "7%", "100%", etc.
\&
\&    <token: perl_hash>
\&        \e% <ident>               # Okay. Will match "%foo", "%bar", etc.
\&
\&    <token: perl_mod>
\&        <expr> \e% <expr>         # Okay. Will match "$n % 2", etc.
.Ve
.PP
Note that it's usually necessary to use the \f(CW\*(C`<[...]>\*(C'\fR form for the
repeated items being matched, so that all of them are saved in the
result hash. You can also save all the separators (if they're important)
by specifying them as a list-like subrule too:
.PP
.Vb 1
\&    \e(  <[number]>* % <[comma]>  \e)  # save numbers *and* separators
.Ve
.PP
The repeated item \fImust\fR be specified as a subrule call of some kind
(i.e. in angles), but the separators may be specified either as a
subrule or as a raw bracketed pattern (i.e. brackets without any
nested subrule calls). For example:
.PP
.Vb 1
\&    <[number]>* % ( , | : )    # Numbers separated by commas or colons
\&
\&    <[number]>* % [,:]         # Same, but more efficiently matched
.Ve
.PP
The separator should always be specified within matched delimiters of
some kind: either matching \f(CW\*(C`<...>\*(C'\fR or matching \f(CW\*(C`(...)\*(C'\fR or matching
\&\f(CW\*(C`[...]\*(C'\fR. Simple, non-bracketed separators will sometimes also work:
.PP
.Vb 1
\&    <[number]>+ % ,
.Ve
.PP
but not always:
.PP
.Vb 1
\&    <[number]>+ % ,\es+     # Oops! Separator is just: ,
.Ve
.PP
This is because of the limited way in which the module internally parses
ordinary regex components (i.e. without full understanding of their
implicit precedence). As a consequence, consistently placing brackets
around any separator is a much safer approach:
.PP
.Vb 1
\&    <[number]>+ % (,\es+)
.Ve
.PP
You can also use a simple pattern on the left of the \f(CW\*(C`%\*(C'\fR as the item
matcher, but in this case it \fImust always\fR be aliased into a
list-collecting subrule, like so:
.PP
.Vb 1
\&    <[item=(\ed+)]>* % [,]
.Ve
.PP
Note that, for backwards compatibility with earlier versions of
Regexp::Grammars, the \f(CW\*(C`+%\*(C'\fR operator can also be written: \f(CW\*(C`**\*(C'\fR.
However, there can be no space between the two asterisks of this
variant. That is:
.PP
.Vb 1
\&    <[item]> ** <sep>      # same as <[item]>* % <sep>
\&
\&    <[item]>* * <sep>      # error (two * qualifiers in a row)
.Ve
.PP
\fIMatching separated lists with a trailing separator\fR
.IX Subsection "Matching separated lists with a trailing separator"
.PP
Some languages allow a separated list to include an extra trailing
separator. For example:
.PP
.Vb 2
\&    ~/bin/perl5/        # Trailing /\-separator in filepath
\&    (1,2,3,)            # Trailing ,\-separator in Perl list
.Ve
.PP
To match such constructs using the \f(CW\*(C`%\*(C'\fR operator, you would need
to add something to explicitly match the optional trailing separator:
.PP
.Vb 1
\&    <dir>+ % [/] [/]?    # Slash\-separated dirs, then optional final slash
\&
\&    <elem>+ % [,] [,]?   # Comma\-separated elems, then optional final comma
.Ve
.PP
which is tedious.
.PP
So the module also supports a second kind of "separated list" operator,
that allows an optional trailing separator as well: the \f(CW\*(C`%%\*(C'\fR operator.
THis operator behaves exactly like the \f(CW\*(C`%\*(C'\fR operator, except that it
also matches a final trailing separator, if one is present.
.PP
So the previous examples could be (better) written as:
.PP
.Vb 1
\&    <dir>+ %% [/]     # Slash\-separated dirs, with optional final slash
\&
\&    <elem>+ %% [,]    # Comma\-separated elems, with optional final comma
.Ve
.SS "Matching hash keys"
.IX Subsection "Matching hash keys"
In some situations a grammar may need a rule that matches dozens,
hundreds, or even thousands of one-word alternatives. For example, when
matching command names, or valid userids, or English words. In such
cases it is often impractical (and always inefficient) to list all the
alternatives between \f(CW\*(C`|\*(C'\fR alternators:
.PP
.Vb 4
\&    <rule: shell_cmd>
\&        a2p | ac | apply | ar | automake | awk | ...
\&        # ...and 400 lines later
\&        ... | zdiff | zgrep | zip | zmore | zsh
\&
\&    <rule: valid_word>
\&        a | aa | aal | aalii | aam | aardvark | aardwolf | aba | ...
\&        # ...and 40,000 lines later...
\&        ... | zymotize | zymotoxic | zymurgy | zythem | zythum
.Ve
.PP
To simplify such cases, Regexp::Grammars provides a special construct
that allows you to specify all the alternatives as the keys of a normal
hash. The syntax for that construct is simply to put the hash name
inside angle brackets (with no space between the angles and the hash name).
.PP
Which means that the rules in the previous example could also be written:
.PP
.Vb 2
\&    <rule: shell_cmd>
\&        <%cmds>
\&
\&    <rule: valid_word>
\&        <%dict>
.Ve
.PP
provided that the two hashes (\f(CW%cmds\fR and \f(CW%dict\fR) are visible in the scope
where the grammar is created.
.PP
Matching a hash key in this way is typically \fIsignificantly\fR faster
than matching a large set of alternations. Specifically, it is
\&\fIO(length of longest potential key) ^ 2\fR, instead of \fIO(number of keys)\fR.
.PP
Internally, the construct is converted to something equivalent to:
.PP
.Vb 2
\&    <rule: shell_cmd>
\&        (<.hk>)  <require: (?{ exists $cmds{$CAPTURE} })>
\&
\&    <rule: valid_word>
\&        (<.hk>)  <require: (?{ exists $dict{$CAPTURE} })>
.Ve
.PP
The special \f(CW\*(C`<hk>\*(C'\fR rule is created automatically, and defaults to
\&\f(CW\*(C`\eS+\*(C'\fR, but you can also define it explicitly to handle other kinds of
keys. For example:
.PP
.Vb 2
\&    <rule: hk>
\&        [^\en]+        # Key may be any number of chars on a single line
\&
\&    <rule: hk>
\&        [ACGT]{10,}   # Key is a base sequence of at least 10 pairs
.Ve
.PP
Alternatively, you can specify a different key-matching pattern for
each hash you're matching, by placing the required pattern in braces
immediately after the hash name. For example:
.PP
.Vb 3
\&    <rule: client_name>
\&        # Valid keys match <.hk> (default or explicitly specified)
\&        <%clients>
\&
\&    <rule: shell_cmd>
\&        # Valid keys contain only word chars, hyphen, slash, or dot...
\&        <%cmds { [\ew\-/.]+ }>
\&
\&    <rule: valid_word>
\&        # Valid keys contain only alphas or internal hyphen or apostrophe...
\&        <%dict{ (?i: (?:[a\-z]+[\-\*(Aq])* [a\-z]+ ) }>
\&
\&    <rule: DNA_sequence>
\&        # Valid keys are base sequences of at least 10 pairs...
\&        <%sequences{[ACGT]{10,}}>
.Ve
.PP
This second approach to key-matching is preferred, because it localizes
any non-standard key-matching behaviour to each individual hash.
.PP
Note that changes in the compilation process from Perl 5.18 onwards
mean that in some cases the \f(CW\*(C`<%hash>\*(C'\fR construct only works
reliably if the hash itself is declared at the outermost lexical scope
(i.e. file scope).
.PP
Specifically, if the regex grammar does not include any interpolated
scalars or arrays \fIand\fR the hash was declared within a subroutine (even
within the same subroutine as the regex grammar that uses it), the regex
will not be able to "see" the hash variable at compile-time. This will
produce a \fI"Global symbol "%hash" requires explicit package name"\fR
compile-time error. For example:
.PP
.Vb 3
\&    sub build_keyword_parser {
\&        # Hash declared inside subroutine...
\&        my %keywords = (foo => 1, bar => 1);
\&
\&        # ...then used in <%hash> construct within uninterpolated regex...
\&        return qr{
\&                    ^<keyword>$
\&                    <rule: keyword> <%keywords>
\&                 }x;
\&
\&        # ...produces compile\-time error
\&    }
.Ve
.PP
The solution is to place the hash outside the subroutine containing the
grammar:
.PP
.Vb 2
\&    # Hash declared OUTSIDE subroutine...
\&    my %keywords = (foo => 1, bar => 1);
\&
\&    sub build_keyword_parser {
\&        return qr{
\&                    ^<keyword>$
\&                    <rule: keyword> <%keywords>
\&                 }x;
\&    }
.Ve
.PP
\&...or else to explicitly interpolate at least one scalar (even
just a scalar containing an empty string):
.PP
.Vb 3
\&    sub build_keyword_parser {
\&        my %keywords = (foo => 1, bar => 1);
\&        my $DEFER_REGEX_COMPILATION = "";
\&
\&        return qr{
\&                    ^<keyword>$
\&                    <rule: keyword> <%keywords>
\&
\&                    $DEFER_REGEX_COMPILATION
\&                 }x;
\&    }
.Ve
.SS "Rematching subrule results"
.IX Subsection "Rematching subrule results"
Sometimes it is useful to be able to rematch a string that has previously
been matched by some earlier subrule. For example, consider a rule to
match shell-like control blocks:
.PP
.Vb 5
\&    <rule: control_block>
\&          for   <expr> <[command]>+ endfor
\&        | while <expr> <[command]>+ endwhile
\&        | if    <expr> <[command]>+ endif
\&        | with  <expr> <[command]>+ endwith
.Ve
.PP
This would be much tidier if we could factor out the command names
(which are the only differences between the four alternatives). The
problem is that the obvious solution:
.PP
.Vb 4
\&    <rule: control_block>
\&        <keyword> <expr>
\&            <[command]>+
\&        end<keyword>
.Ve
.PP
doesn't work, because it would also match an incorrect input like:
.PP
.Vb 4
\&    for 1..10
\&        echo $n
\&        ls subdir/$n
\&    endif
.Ve
.PP
We need some way to ensure that the \f(CW\*(C`<keyword>\*(C'\fR matched immediately
after "end" is the same \f(CW\*(C`<keyword>\*(C'\fR that was initially matched.
.PP
That's not difficult, because the first \f(CW\*(C`<keyword>\*(C'\fR will have
captured what it matched into \f(CW$MATCH{keyword}\fR, so we could just
write:
.PP
.Vb 4
\&    <rule: control_block>
\&        <keyword> <expr>
\&            <[command]>+
\&        end(??{quotemeta $MATCH{keyword}})
.Ve
.PP
This is such a useful technique, yet so ugly, scary, and prone to error,
that Regexp::Grammars provides a cleaner equivalent:
.PP
.Vb 4
\&    <rule: control_block>
\&        <keyword> <expr>
\&            <[command]>+
\&        end<\e_keyword>
.Ve
.PP
A directive of the form \f(CW\*(C`<\e_\fR\f(CIIDENTIFIER\fR\f(CW>\*(C'\fR is known as a
"matchref" (an abbreviation of "%MATCH\-supplied backreference").
Matchrefs always attempt to match, as a literal, the current value of
\&\f(CW$MATCH{\fR\f(CIIDENTIFIER\fR\f(CW}\fR.
.PP
By default, a matchref does not capture what it matches, but you
can have it do so by giving it an alias:
.PP
.Vb 2
\&    <token: delimited_string>
\&        <ldelim=str_delim>  .*?  <rdelim=\e_ldelim>
\&
\&    <token: str_delim> ["\*(Aq\`]
.Ve
.PP
At first glance this doesn't seem very useful as, by definition,
\&\f(CW$MATCH{ldelim}\fR and \f(CW$MATCH{rdelim}\fR must necessarily
always end up with identical values. However, it can be useful
if the rule also has other alternatives and you want to create a
consistent internal representation for those alternatives, like so:
.PP
.Vb 6
\&    <token: delimited_string>
\&          <ldelim=str_delim>  .*?  <rdelim=\e_ldelim>
\&        | <ldelim=( \e[ )      .*?  <rdelim=( \e] )
\&        | <ldelim=( \e{ )      .*?  <rdelim=( \e} )
\&        | <ldelim=( \e( )      .*?  <rdelim=( \e) )
\&        | <ldelim=( \e< )      .*?  <rdelim=( \e> )
.Ve
.PP
You can also force a matchref to save repeated matches
as a nested array, in the usual way:
.PP
.Vb 2
\&    <token: marked_text>
\&        <marker> <text> <[endmarkers=\e_marker]>+
.Ve
.PP
Be careful though, as the following will not do as you may expect:
.PP
.Vb 1
\&        <[marker]>+ <text> <[endmarkers=\e_marker]>+
.Ve
.PP
because the value of \f(CW$MATCH{marker}\fR will be an array reference, which
the matchref will flatten and concatenate, then match the
resulting string as a literal, which will mean the previous example will
match endmarkers that are exact multiples of the complete start marker,
rather than endmarkers that consist of any number of repetitions of the
individual start marker delimiter. So:
.PP
.Vb 3
\&        ""text here""
\&        ""text here""""
\&        ""text here""""""
.Ve
.PP
but not:
.PP
.Vb 2
\&        ""text here"""
\&        ""text here"""""
.Ve
.PP
Uneven start and end markers such as these are extremely unusual, so
this problem rarely arises in practice.
.PP
\&\fR\f(BINote:\fR\fI Prior to Regexp::Grammars version 1.020, the syntax for matchrefs
was \fR\f(CI\*(C`<\eIDENTIFIER>\*(C'\fR\fI instead of \fR\f(CI\*(C`<\e_IDENTIFIER>\*(C'\fR\fI. This
created problems when the identifier started with any of \fR\f(CI\*(C`l\*(C'\fR\fI, \fR\f(CI\*(C`u\*(C'\fR\fI, \fR\f(CI\*(C`L\*(C'\fR\fI,
\&\fR\f(CI\*(C`U\*(C'\fR\fI, \fR\f(CI\*(C`Q\*(C'\fR\fI, or \fR\f(CI\*(C`E\*(C'\fR\fI, so the syntax has had to be altered in a backwards
incompatible way. It will not be altered again.
\&\fR
.SS "Rematching balanced delimiters"
.IX Subsection "Rematching balanced delimiters"
Consider the example in the previous section:
.PP
.Vb 6
\&    <token: delimited_string>
\&          <ldelim=str_delim>  .*?  <rdelim=\e_ldelim>
\&        | <ldelim=( \e[ )      .*?  <rdelim=( \e] )
\&        | <ldelim=( \e{ )      .*?  <rdelim=( \e} )
\&        | <ldelim=( \e( )      .*?  <rdelim=( \e) )
\&        | <ldelim=( \e< )      .*?  <rdelim=( \e> )
.Ve
.PP
The repeated pattern of the last four alternatives is gauling,
but we can't just refactor those delimiters as well:
.PP
.Vb 3
\&    <token: delimited_string>
\&          <ldelim=str_delim>  .*?  <rdelim=\e_ldelim>
\&        | <ldelim=bracket>    .*?  <rdelim=\e_ldelim>
.Ve
.PP
because that would incorrectly match:
.PP
.Vb 1
\&    { delimited content here {
.Ve
.PP
while failing to match:
.PP
.Vb 1
\&    { delimited content here }
.Ve
.PP
To refactor balanced delimiters like those, we need a second
kind of matchref; one that's a little smarter.
.PP
Or, preferably, a lot smarter...because there are many other kinds of
balanced delimiters, apart from single brackets. For example:
.PP
.Vb 5
\&      {{{ delimited content here }}}
\&       /* delimited content here */
\&       (* delimited content here *)
\&       \`\` delimited content here \*(Aq\*(Aq
\&       if delimited content here fi
.Ve
.PP
The common characteristic of these delimiter pairs is that the closing
delimiter is the \fIinverse\fR of the opening delimiter: the sequence of
characters is reversed and certain characters (mainly brackets, but also
single\-quotes/backticks) are mirror-reflected.
.PP
Regexp::Grammars supports the parsing of such delimiters with a
construct known as an \fIinvertref\fR, which is specified using the
\&\f(CW\*(C`</\fR\f(CIIDENT\fR\f(CW>\*(C'\fR directive. An invertref acts very like a
matchref, except that it does not
convert to:
.PP
.Vb 1
\&    (??{ quotemeta( $MATCH{I<IDENT>} ) })
.Ve
.PP
but rather to:
.PP
.Vb 1
\&    (??{ quotemeta( inverse( $MATCH{I<IDENT> ))} })
.Ve
.PP
With this directive available, the balanced delimiters of the previous
example can be refactored to:
.PP
.Vb 3
\&    <token: delimited_string>
\&          <ldelim=str_delim>  .*?  <rdelim=\e_ldelim>
\&        | <ldelim=( [[{(<] )  .*?  <rdelim=/ldelim>
.Ve
.PP
Like matchrefs, invertrefs come in the usual range of flavours:
.PP
.Vb 3
\&    </ident>            # Match the inverse of $MATCH{ident}
\&    <ALIAS=/ident>      # Match inverse and capture to $MATCH{ident}
\&    <[ALIAS=/ident]>    # Match inverse and push on @{$MATCH{ident}}
.Ve
.PP
The character pairs that are reversed during mirroring are: \f(CW\*(C`{\*(C'\fR and \f(CW\*(C`}\*(C'\fR,
\&\f(CW\*(C`[\*(C'\fR and \f(CW\*(C`]\*(C'\fR, \f(CW\*(C`(\*(C'\fR and \f(CW\*(C`)\*(C'\fR, \f(CW\*(C`<\*(C'\fR and \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`\*(C'\fR and \f(CW\*(C`\*(C'\fR,
\&\f(CW\*(C`\`\*(C'\fR and \f(CW\*(C`\*(Aq\*(C'\fR.
.PP
The following mnemonics may be useful in distinguishing inverserefs from
backrefs: a backref starts with a \f(CW\*(C`\e\*(C'\fR (just like the standard Perl
regex backrefs \f(CW\*(C`\e1\*(C'\fR and \f(CW\*(C`\eg{\-2}\*(C'\fR and \f(CW\*(C`\ek<name>\*(C'\fR), whereas an
inverseref starts with a \f(CW\*(C`/\*(C'\fR (like an HTML or XML closing tag). Or
just remember that \f(CW\*(C`<\e_IDENT>\*(C'\fR is "match the same again", and if you
want "the same again, only mirrored" instead, just mirror the \f(CW\*(C`\e\*(C'\fR
to get \f(CW\*(C`</IDENT>\*(C'\fR.
.SS "Rematching parametric results and delimiters"
.IX Subsection "Rematching parametric results and delimiters"
The \f(CW\*(C`<\e_\fR\f(CIIDENTIFIER\fR\f(CW>\*(C'\fR and \f(CW\*(C`</\fR\f(CIIDENTIFIER\fR\f(CW>\*(C'\fR mechanisms
normally locate the literal to be matched by looking in
\&\f(CW$MATCH{\fR\f(CIIDENTIFIER\fR\f(CW}\fR.
.PP
However, you can cause them to look in \f(CW$ARG{\fR\f(CIIDENTIFIER\fR\f(CW}\fR instead,
by prefixing the identifier with a single \f(CW\*(C`:\*(C'\fR. This is especially
useful when refactoring subrules. For example, instead of:
.PP
.Vb 2
\&    <rule: Command>
\&        <Keyword>  <CommandBody>  end_ <\e_Keyword>
\&
\&    <rule: Placeholder>
\&        <Keyword>    \e.\e.\e.   end_ <\e_Keyword>
.Ve
.PP
you could parameterize the Terminator rule, like so:
.PP
.Vb 2
\&    <rule: Command>
\&        <Keyword>  <CommandBody>  <Terminator(:Keyword)>
\&
\&    <rule: Placeholder>
\&        <Keyword>    \e.\e.\e.   <Terminator(:Keyword)>
\&
\&    <token: Terminator>
\&        end_ <\e:Keyword>
.Ve
.SS "Tracking and reporting match positions"
.IX Subsection "Tracking and reporting match positions"
Regexp::Grammars automatically predefines a special token that makes it
easy to track exactly where in its input a particular subrule matches.
That token is: \f(CW\*(C`<matchpos>\*(C'\fR.
.PP
The \f(CW\*(C`<matchpos>\*(C'\fR token implements a zero-width match that never
fails. It always returns the current index within the string that the
grammar is matching.
.PP
So, for example you could have your \f(CW\*(C`<delimited_text>\*(C'\fR subrule
detect and report unterminated text like so:
.PP
.Vb 5
\&    <token: delimited_text>
\&        qq? <delim> <text=(.*?)> </delim>
\&    |
\&        <matchpos> qq? <delim>
\&        <error: (?{"Unterminated string starting at index $MATCH{matchpos}"})>
.Ve
.PP
Matching \f(CW\*(C`<matchpos>\*(C'\fR in the second alternative causes
\&\f(CW$MATCH{matchpos}\fR to contain the position in the string at which the
\&\f(CW\*(C`<matchpos>\*(C'\fR subrule was matched (in this example: the start of the
unterminated text).
.PP
If you want the line number instead of the string index, use the
predefined \f(CW\*(C`<matchline>\*(C'\fR subrule instead:
.PP
.Vb 4
\&    <token: delimited_text>
\&              qq? <delim> <text=(.*?)> </delim>
\&    |   <matchline> qq? <delim>
\&        <error: (?{"Unterminated string starting at line $MATCH{matchline}"})>
.Ve
.PP
Note that the line numbers returned by \f(CW\*(C`<matchline>\*(C'\fR start at 1
(not at zero, as with \f(CW\*(C`<matchpos>\*(C'\fR).
.PP
The \f(CW\*(C`<matchpos>\*(C'\fR and \f(CW\*(C`<matchline>\*(C'\fR subrules are just like any
other subrules; you can alias them (\f(CW\*(C`<started_at=matchpos>\*(C'\fR) or
match them repeatedly ( \f(CW\*(C`(?: <[matchline]> <[item]> )++\*(C'\fR), etc.
.SH Autoactions
.IX Header "Autoactions"
The module also supports event-based parsing. You can specify a grammar
in the usual way and then, for a particular parse, layer a collection of
call-backs (known as "autoactions") over the grammar to handle the data
as it is parsed.
.PP
Normally, a grammar rule returns the result hash it has accumulated
(or whatever else was aliased to \f(CW\*(C`MATCH=\*(C'\fR within the rule). However,
you can specify an autoaction object before the grammar is matched.
.PP
Once the autoaction object is specified, every time a rule succeeds
during the parse, its result is passed to the object via one of its
methods; specifically it is passed to the method whose name is the same
as the rule's.
.PP
For example, suppose you had a grammar that recognizes simple algebraic
expressions:
.PP
.Vb 4
\&    my $expr_parser = do{
\&        use Regexp::Grammars;
\&        qr{
\&            <Expr>
\&
\&            <rule: Expr>       <[Operand=Mult]>+ % <[Op=(\e+|\e\-)]>
\&
\&            <rule: Mult>       <[Operand=Pow]>+  % <[Op=(\e*|/|%)]>
\&
\&            <rule: Pow>        <[Operand=Term]>+ % <Op=(\e^)>
\&
\&            <rule: Term>          <MATCH=Literal>
\&                       |       \e( <MATCH=Expr> \e)
\&
\&            <token: Literal>   <MATCH=( [+\-]? \ed++ (?: \e. \ed++ )?+ )>
\&        }xms
\&    };
.Ve
.PP
You could convert this grammar to a calculator, by installing a set of
autoactions that convert each rule's result hash to the corresponding
value of the sub-expression that the rule just parsed. To do that, you
would create a class with methods whose names match the rules whose
results you want to change. For example:
.PP
.Vb 2
\&    package Calculator;
\&    use List::Util qw< reduce >;
\&
\&    sub new {
\&        my ($class) = @_;
\&
\&        return bless {}, $class
\&    }
\&
\&    sub Answer {
\&        my ($self, $result_hash) = @_;
\&
\&        my $sum = shift @{$result_hash\->{Operand}};
\&
\&        for my $term (@{$result_hash\->{Operand}}) {
\&            my $op = shift @{$result_hash\->{Op}};
\&            if ($op eq \*(Aq+\*(Aq) { $sum += $term; }
\&            else            { $sum \-= $term; }
\&        }
\&
\&        return $sum;
\&    }
\&
\&    sub Mult {
\&        my ($self, $result_hash) = @_;
\&
\&        return reduce { eval($a . shift(@{$result_hash\->{Op}}) . $b) }
\&                      @{$result_hash\->{Operand}};
\&    }
\&
\&    sub Pow {
\&        my ($self, $result_hash) = @_;
\&
\&        return reduce { $b ** $a } reverse @{$result_hash\->{Operand}};
\&    }
.Ve
.PP
Objects of this class (and indeed the class itself) now have methods
corresponding to some of the rules in the expression grammar. To
apply those methods to the results of the rules (as they parse) you
simply install an object as the "autoaction" handler, immediately
before you initiate the parse:
.PP
.Vb 3
\&    if ($text ~= $expr_parser\->with_actions(Calculator\->new)) {
\&        say $/{Answer};   # Now prints the result of the expression
\&    }
.Ve
.PP
The \f(CWwith_actions()\fR method expects to be passed an object or
classname. This object or class will be installed as the autoaction
handler for the next match against any grammar. After that match, the
handler will be uninstalled. \f(CWwith_actions()\fR returns the grammar it's
called on, making it easy to call it as part of a match (which is the
recommended idiom).
.PP
With a \f(CW\*(C`Calculator\*(C'\fR object set as the autoaction handler, whenever
the \f(CW\*(C`Answer\*(C'\fR, \f(CW\*(C`Mult\*(C'\fR, or \f(CW\*(C`Pow\*(C'\fR rule of the grammar matches, the
corresponding \f(CW\*(C`Answer\*(C'\fR, \f(CW\*(C`Mult\*(C'\fR, or \f(CW\*(C`Pow\*(C'\fR method of the
\&\f(CW\*(C`Calculator\*(C'\fR object will be called (with the rule's result value
passed as its only argument), and the result of the method will be
used as the result of the rule.
.PP
Note that nothing new happens when a \f(CW\*(C`Term\*(C'\fR or \f(CW\*(C`Literal\*(C'\fR rule matches,
because the \f(CW\*(C`Calculator\*(C'\fR object doesn't have methods with those names.
.PP
The overall effect, then, is to allow you to specify a grammar without
rule-specific bahaviours and then, later, specify a set of final actions
(as methods) for some or all of the rules of the grammar.
.PP
Note that, if a particular callback method returns \f(CW\*(C`undef\*(C'\fR, the result
of the corresponding rule will be passed through without modification.
.SH "Named grammars"
.IX Header "Named grammars"
All the grammars shown so far are confined to a single regex. However,
Regexp::Grammars also provides a mechanism that allows you to defined
named grammars, which can then be imported into other regexes. This
gives the a way of modularizing common grammatical components.
.SS "Defining a named grammar"
.IX Subsection "Defining a named grammar"
You can create a named grammar using the \f(CW\*(C`<grammar:...>\*(C'\fR
directive. This directive must appear before the first rule definition
in the grammar, and instead of any start-rule. For example:
.PP
.Vb 2
\&    qr{
\&        <grammar: List::Generic>
\&
\&        <rule: List>
\&            <[MATCH=Item]>+ % <Separator>
\&
\&        <rule: Item>
\&            \eS++
\&
\&        <token: Separator>
\&            \es* , \es*
\&    }x;
.Ve
.PP
This creates a grammar named \f(CW\*(C`List::Generic\*(C'\fR, and installs it in the module's
internal caches, for future reference.
.PP
Note that there is no need (or reason) to assign the resulting regex to
a variable, as the named grammar cannot itself be matched against.
.SS "Using a named grammar"
.IX Subsection "Using a named grammar"
To make use of a named grammar, you need to incorporate it into another
grammar, by inheritance. To do that, use the \f(CW\*(C`<extends:...>\*(C'\fR
directive, like so:
.PP
.Vb 2
\&    my $parser = qr{
\&        <extends: List::Generic>
\&
\&        <List>
\&    }x;
.Ve
.PP
The \f(CW\*(C`<extends:...>\*(C'\fR directive incorporates the rules defined in the
specified grammar into the current regex. You can then call any of those
rules in the start-pattern.
.SS "Overriding an inherited rule or token"
.IX Subsection "Overriding an inherited rule or token"
Subrule dispatch within a grammar is always polymorphic. That is, when a
subrule is called, the most-derived rule of the same name within the
grammar's hierarchy is invoked.
.PP
So, to replace a particular rule within grammar, you simply need to inherit
that grammar and specify new, more-specific versions of any rules you
want to change. For example:
.PP
.Vb 2
\&    my $list_of_integers = qr{
\&        <List>
\&
\&        # Inherit rules from base grammar...
\&        <extends: List::Generic>
\&
\&        # Replace Item rule from List::Generic...
\&        <rule: Item>
\&            [+\-]? \ed++
\&    }x;
.Ve
.PP
You can also use \f(CW\*(C`<extends:...>\*(C'\fR in other named grammars, to create
hierarchies:
.PP
.Vb 3
\&    qr{
\&        <grammar: List::Integral>
\&        <extends: List::Generic>
\&
\&        <token: Item>
\&            [+\-]? <MATCH=(<.Digit>+)>
\&
\&        <token: Digit>
\&            \ed
\&    }x;
\&
\&    qr{
\&        <grammar: List::ColonSeparated>
\&        <extends: List::Generic>
\&
\&        <token: Separator>
\&            \es* : \es*
\&    }x;
\&
\&    qr{
\&        <grammar: List::Integral::ColonSeparated>
\&        <extends: List::Integral>
\&        <extends: List::ColonSeparated>
\&    }x;
.Ve
.PP
As shown in the previous example, Regexp::Grammars allows you
to multiply inherit two (or more) base grammars. For example, the
\&\f(CW\*(C`List::Integral::ColonSeparated\*(C'\fR grammar takes the definitions of
\&\f(CW\*(C`List\*(C'\fR and \f(CW\*(C`Item\*(C'\fR from the \f(CW\*(C`List::Integral\*(C'\fR grammar, and the
definition of \f(CW\*(C`Separator\*(C'\fR from \f(CW\*(C`List::ColonSeparated\*(C'\fR.
.PP
Note that grammars dispatch subrule calls using C3 method lookup, rather
than Perl's older DFS lookup. That's why \f(CW\*(C`List::Integral::ColonSeparated\*(C'\fR
correctly gets the more-specific \f(CW\*(C`Separator\*(C'\fR rule defined in
\&\f(CW\*(C`List::ColonSeparated\*(C'\fR, rather than the more-generic version defined in
\&\f(CW\*(C`List::Generic\*(C'\fR (via \f(CW\*(C`List::Integral\*(C'\fR). See \f(CW\*(C`perldoc mro\*(C'\fR for more
discussion of the C3 dispatch algorithm.
.SS "Augmenting an inherited rule or token"
.IX Subsection "Augmenting an inherited rule or token"
Instead of replacing an inherited rule, you can augment it.
.PP
For example, if you need a grammar for lists of hexademical
numbers, you could inherit the behaviour of \f(CW\*(C`List::Integral\*(C'\fR
and add the hex digits to its \f(CW\*(C`Digit\*(C'\fR token:
.PP
.Vb 2
\&    my $list_of_hexadecimal = qr{
\&        <List>
\&
\&        <extends: List::Integral>
\&
\&        <token: Digit>
\&            <List::Integral::Digit>
\&          | [A\-Fa\-f]
\&    }x;
.Ve
.PP
If you call a subrule using a fully qualified name (such as
\&\f(CW\*(C`<List::Integral::Digit>\*(C'\fR), the grammar calls that
version of the rule, rather than the most-derived version.
.SS "Debugging named grammars"
.IX Subsection "Debugging named grammars"
Named grammars are independent of each other, even when inherited. This
means that, if debugging is enabled in a derived grammar, it will not be
active in any rules inherited from a base grammar, unless the base
grammar also included a \f(CW\*(C`<debug:...>\*(C'\fR directive.
.PP
This is a deliberate design decision, as activating the debugger adds a
significant amount of code to each grammar's implementation, which is
detrimental to the matching performance of the resulting regexes.
.PP
If you need to debug a named grammar, the best approach is to include a
\&\f(CW\*(C`<debug: same>\*(C'\fR directive at the start of the grammar. The presence
of this directive will ensure the necessary extra debugging code is
included in the regex implementing the grammar, while setting \f(CW\*(C`same\*(C'\fR
mode will ensure that the debugging mode isn't altered when the matcher
uses the inherited rules.
.SH "Common parsing techniques"
.IX Header "Common parsing techniques"
.SS "Result distillation"
.IX Subsection "Result distillation"
Normally, calls to subrules produce nested result-hashes within the
current result-hash. Those nested hashes always have at least one
automatically supplied key (\f(CW""\fR), whose value is the entire substring
that the subrule matched.
.PP
If there are no other nested captures within the subrule, there will be
no other keys in the result-hash. This would be annoying as a typical
nested grammar would then produce results consisting of hashes of
hashes, with each nested hash having only a single key (\f(CW""\fR). This in
turn would make postprocessing the result-hash (in \f(CW\*(C`%/\*(C'\fR) far more
complicated than it needs to be.
.PP
To avoid this behaviour, if a subrule's result-hash doesn't contain any keys
except \f(CW""\fR, the module "flattens" the result-hash, by replacing it with
the value of its single key.
.PP
So, for example, the grammar:
.PP
.Vb 1
\&    mv \es* <from> \es* <to>
\&
\&    <rule: from>   [\ew/.\-]+
\&    <rule: to>     [\ew/.\-]+
.Ve
.PP
\&\fIdoesn't\fR return a result-hash like this:
.PP
.Vb 5
\&    {
\&        ""     => \*(Aqmv /usr/local/lib/libhuh.dylib  /dev/null/badlib\*(Aq,
\&        \*(Aqfrom\*(Aq => { "" => \*(Aq/usr/local/lib/libhuh.dylib\*(Aq },
\&        \*(Aqto\*(Aq   => { "" => \*(Aq/dev/null/badlib\*(Aq            },
\&    }
.Ve
.PP
Instead, it returns:
.PP
.Vb 5
\&    {
\&        ""     => \*(Aqmv /usr/local/lib/libhuh.dylib  /dev/null/badlib\*(Aq,
\&        \*(Aqfrom\*(Aq => \*(Aq/usr/local/lib/libhuh.dylib\*(Aq,
\&        \*(Aqto\*(Aq   => \*(Aq/dev/null/badlib\*(Aq,
\&    }
.Ve
.PP
That is, because the \f(CW\*(Aqfrom\*(Aq\fR and \f(CW\*(Aqto\*(Aq\fR subhashes each have only a single
entry, they are each "flattened" to the value of that entry.
.PP
This flattening also occurs if a result-hash contains only "private" keys
(i.e. keys starting with underscores). For example:
.PP
.Vb 1
\&    mv \es* <from> \es* <to>
\&
\&    <rule: from>   <_dir=path>? <_file=filename>
\&    <rule: to>     <_dir=path>? <_file=filename>
\&
\&    <token: path>      [\ew/.\-]*/
\&    <token: filename>  [\ew.\-]+
.Ve
.PP
Here, the \f(CW\*(C`from\*(C'\fR rule produces a result like this:
.PP
.Vb 5
\&    from => {
\&          "" => \*(Aq/usr/local/bin/perl\*(Aq,
\&        _dir => \*(Aq/usr/local/bin/\*(Aq,
\&       _file => \*(Aqperl\*(Aq,
\&    }
.Ve
.PP
which is automatically stripped of "private" keys, leaving:
.PP
.Vb 3
\&    from => {
\&          "" => \*(Aq/usr/local/bin/perl\*(Aq,
\&    }
.Ve
.PP
which is then automatically flattened to:
.PP
.Vb 1
\&    from => \*(Aq/usr/local/bin/perl\*(Aq
.Ve
.PP
\fIList result distillation\fR
.IX Subsection "List result distillation"
.PP
A special case of result distillation occurs in a separated
list, such as:
.PP
.Vb 1
\&    <rule: List>
\&
\&        <[Item]>+ % <[Sep=(,)]>
.Ve
.PP
If this construct matches just a single item, the result hash will
contain a single entry consisting of a nested array with a single
value, like so:
.PP
.Vb 1
\&    { Item => [ \*(Aqdata\*(Aq ] }
.Ve
.PP
Instead of returning this annoyingly nested data structure, you can tell
Regexp::Grammars to flatten it to just the inner data with a special
directive:
.PP
.Vb 1
\&    <rule: List>
\&
\&        <[Item]>+ % <[Sep=(,)]>
\&
\&        <minimize:>
.Ve
.PP
The \f(CW\*(C`<minimize:>\*(C'\fR directive examines the result hash (i.e.
\&\f(CW%MATCH\fR). If that hash contains only a single entry, which is a
reference to an array with a single value, then the directive assigns
that single value directly to \f(CW$MATCH\fR, so that it will be returned
instead of the usual result hash.
.PP
This means that a normal separated list still results in a hash
containing all elements and separators, but a "degenerate" list of only
one item results in just that single item.
.PP
\fIManual result distillation\fR
.IX Subsection "Manual result distillation"
.PP
Regexp::Grammars also offers full manual control over the distillation
process. If you use the reserved word \f(CW\*(C`MATCH\*(C'\fR as the alias for
a subrule call:
.PP
.Vb 1
\&    <MATCH=filename>
.Ve
.PP
or a subpattern match:
.PP
.Vb 1
\&    <MATCH=( \ew+ )>
.Ve
.PP
or a code block:
.PP
.Vb 1
\&    <MATCH=(?{ 42 })>
.Ve
.PP
then the current rule will treat the return value of that subrule,
pattern, or code block as its complete result, and return that value
instead of the usual result-hash it constructs. This is the case even if
the result has other entries that would normally also be returned.
.PP
For example, consider a rule like:
.PP
.Vb 3
\&    <rule: term>
\&          <MATCH=literal>
\&        | <left_paren> <MATCH=expr> <right_paren>
.Ve
.PP
The use of \f(CW\*(C`MATCH\*(C'\fR aliases causes the rule to return either whatever
\&\f(CW\*(C`<literal>\*(C'\fR returns, or whatever \f(CW\*(C`<expr>\*(C'\fR returns (provided
it's between left and right parentheses).
.PP
Note that, in this second case, even though \f(CW\*(C`<left_paren>\*(C'\fR and
\&\f(CW\*(C`<right_paren>\*(C'\fR \fIare\fR captured to the result-hash, they are
not returned, because the \f(CW\*(C`MATCH\*(C'\fR alias overrides the normal "return
the result-hash" semantics and returns only what its associated
subrule (i.e. \f(CW\*(C`<expr>\*(C'\fR) produces.
.PP
Note also that the return value is only assigned, if the subrule call
actually matches. For example:
.PP
.Vb 2
\&    <rule: optional_names>
\&        <[MATCH=name]>*
.Ve
.PP
If the repeated subrule call to \f(CW\*(C`<name>\*(C'\fR matches zero times,
the return value of the \f(CW\*(C`optional_names\*(C'\fR rule will not be an empty
array, because the \f(CW\*(C`MATCH=\*(C'\fR will not have executed at all. Instead,
the default return value (an empty string) will be returned.
If you had specifically wanted to return an empty array, you could
use any of the following:
.PP
.Vb 3
\&    <rule: optional_names>
\&        <MATCH=(?{ [] })>     # Set up empty array before first match attempt
\&        <[MATCH=name]>*
.Ve
.PP
or:
.PP
.Vb 4
\&    <rule: optional_names>
\&        <[MATCH=name]>+       # Match one or more times
\&      |                       #          or
\&        <MATCH=(?{ [] })>     # Set up empty array, if no match
.Ve
.PP
\fIProgrammatic result distillation\fR
.IX Subsection "Programmatic result distillation"
.PP
It's also possible to control what a rule returns from within a code block.
Regexp::Grammars provides a set of reserved variables that give direct
access to the result-hash.
.PP
The result-hash itself can be accessed as \f(CW%MATCH\fR within any code block
inside a rule. For example:
.PP
.Vb 3
\&    <rule: sum>
\&        <X=product> \e+ <Y=product>
\&            <MATCH=(?{ $MATCH{X} + $MATCH{Y} })>
.Ve
.PP
Here, the rule matches a product (aliased \f(CW\*(AqX\*(Aq\fR in the result-hash),
then a literal \f(CW\*(Aq+\*(Aq\fR, then another product (aliased to \f(CW\*(AqY\*(Aq\fR in the
result-hash). The rule then executes the code block, which accesses the two
saved values (as \f(CW$MATCH{X}\fR and \f(CW$MATCH{Y}\fR), adding them together.
Because the block is itself aliased to \f(CW\*(C`MATCH\*(C'\fR, the sum produced by the block
becomes the (only) result of the rule.
.PP
It is also possible to set the rule result from within a code block (instead
of aliasing it). The special "override" return value is represented by the
special variable \f(CW$MATCH\fR. So the previous example could be rewritten:
.PP
.Vb 3
\&    <rule: sum>
\&        <X=product> \e+ <Y=product>
\&            (?{ $MATCH = $MATCH{X} + $MATCH{Y} })
.Ve
.PP
Both forms are identical in effect. Any assignment to \f(CW$MATCH\fR overrides the
normal "return all subrule results" behaviour.
.PP
Assigning to \f(CW$MATCH\fR directly is particularly handy if the result
may not always be "distillable", for example:
.PP
.Vb 11
\&    <rule: sum>
\&        <X=product> \e+ <Y=product>
\&            (?{ if (!ref $MATCH{X} && !ref $MATCH{Y}) {
\&                    # Reduce to sum, if both terms are simple scalars...
\&                    $MATCH = $MATCH{X} + $MATCH{Y};
\&                }
\&                else {
\&                    # Return full syntax tree for non\-simple case...
\&                    $MATCH{op} = \*(Aq+\*(Aq;
\&                }
\&            })
.Ve
.PP
Note that you can also partially override the subrule return behaviour.
Normally, the subrule returns the complete text it matched as its context
substring (i.e. under the "empty key") in its result-hash. That is, of
course, \f(CW$MATCH{""}\fR, so you can override just that behaviour by
directly assigning to that entry.
.PP
For example, if you have a rule that matches key/value pairs from a
configuration file, you might prefer that any trailing comments not be
included in the "matched text" entry of the rule's result-hash. You could
hide such comments like so:
.PP
.Vb 6
\&    <rule: config_line>
\&        <key> : <value>  <comment>?
\&            (?{
\&                # Edit trailing comments out of "matched text" entry...
\&                $MATCH = "$MATCH{key} : $MATCH{value}";
\&            })
.Ve
.PP
Some more examples of the uses of \f(CW$MATCH\fR:
.PP
.Vb 3
\&    <rule: FuncDecl>
\&      # Keyword  Name               Keep return the name (as a string)...
\&        func     <Identifier> ;     (?{ $MATCH = $MATCH{\*(AqIdentifier\*(Aq} })
\&
\&
\&    <rule: NumList>
\&      # Numbers in square brackets...
\&        \e[
\&            ( \ed+ (?: , \ed+)* )
\&        \e]
\&
\&      # Return only the numbers...
\&        (?{ $MATCH = $CAPTURE })
\&
\&
\&    <token: Cmd>
\&      # Match standard variants then standardize the keyword...
\&        (?: mv | move | rename )      (?{ $MATCH = \*(Aqmv\*(Aq; })
.Ve
.SS "Parse-time data processing"
.IX Subsection "Parse-time data processing"
Using code blocks in rules, it's often possible to fully process data as
you parse it. For example, the \f(CW\*(C`<sum>\*(C'\fR rule shown in the previous section
might be part of a simple calculator, implemented entirely in a single
grammar. Such a calculator might look like this:
.PP
.Vb 4
\&    my $calculator = do{
\&        use Regexp::Grammars;
\&        qr{
\&            <Answer>
\&
\&            <rule: Answer>
\&                ( <.Mult>+ % <.Op=([+\-])> )
\&                    <MATCH= (?{ eval $CAPTURE })>
\&
\&            <rule: Mult>
\&                ( <.Pow>+ % <.Op=([*/%])> )
\&                    <MATCH= (?{ eval $CAPTURE })>
\&
\&            <rule: Pow>
\&                <X=Term> \e^ <Y=Pow>
\&                    <MATCH= (?{ $MATCH{X} ** $MATCH{Y}; })>
\&              |
\&                    <MATCH=Term>
\&
\&            <rule: Term>
\&                    <MATCH=Literal>
\&              | \e(  <MATCH=Answer>  \e)
\&
\&            <token: Literal>
\&                    <MATCH= ( [+\-]? \ed++ (?: \e. \ed++ )?+ )>
\&        }xms
\&    };
\&
\&    while (my $input = <>) {
\&        if ($input =~ $calculator) {
\&            say "\-\-> $/{Answer}";
\&        }
\&    }
.Ve
.PP
Because every rule computes a value using the results of the subrules
below it, and aliases that result to its \f(CW\*(C`MATCH\*(C'\fR, each rule returns a
complete evaluation of the subexpression it matches, passing that back
to higher-level rules, which then do the same.
.PP
Hence, the result returned to the very top-level rule (i.e. to \f(CW\*(C`<Answer>\*(C'\fR) is the complete evaluation of the entire expression that
was matched. That means that, in the very process of having matched a
valid expression, the calculator has also computed the value of that
expression, which can then simply be printed directly.
.PP
It is often possible to have a grammar fully (or sometimes at least
partially) evaluate or transform the data it is parsing, and this
usually leads to very efficient and easy-to-maintain implementations.
.PP
The main limitation of this technique is that the data has to be in a
well-structured form, where subsets of the data can be evaluated using
only local information. In cases where the meaning of the data is
distributed through that data non-hierarchically, or relies on global
state, or on external information, it is often better to have the grammar
simply construct a complete syntax tree for the data first, and then evaluate
that syntax tree separately, after parsing is complete. The following section
describes a feature of Regexp::Grammars that can make this second style of
data processing simpler and more maintainable.
.SS "Object-oriented parsing"
.IX Subsection "Object-oriented parsing"
When a grammar has parsed successfully, the \f(CW\*(C`%/\*(C'\fR variable will contain a
series of nested hashes (and possibly arrays) representing the hierarchical
structure of the parsed data.
.PP
Typically, the next step is to walk that tree, extracting or
converting or otherwise processing that information. If the tree has nodes of
many different types, it can be difficult to build a recursive subroutine that
can navigate it easily.
.PP
A much cleaner solution is possible if the nodes of the tree are proper
objects.  In that case, you just define a \f(CWprocess()\fR or \f(CWtraverse()\fR method
for eah of the classes, and have every node call that method on each of its
children. For example, if the parser were to return a tree of nodes
representing the contents of a LaTeX file, then you could define the following
methods:
.PP
.Vb 7
\&    sub Latex::file::explain
\&    {
\&        my ($self, $level) = @_;
\&        for my $element (@{$self\->{element}}) {
\&            $element\->explain($level);
\&        }
\&    }
\&
\&    sub Latex::element::explain {
\&        my ($self, $level) = @_;
\&        (  $self\->{command} || $self\->{literal})\->explain($level)
\&    }
\&
\&    sub Latex::command::explain {
\&        my ($self, $level) = @_;
\&        say "\et"x$level, "Command:";
\&        say "\et"x($level+1), "Name: $self\->{name}";
\&        if ($self\->{options}) {
\&            say "\et"x$level, "\etOptions:";
\&            $self\->{options}\->explain($level+2)
\&        }
\&
\&        for my $arg (@{$self\->{arg}}) {
\&            say "\et"x$level, "\etArg:";
\&            $arg\->explain($level+2)
\&        }
\&    }
\&
\&    sub Latex::options::explain {
\&        my ($self, $level) = @_;
\&        $_\->explain($level) foreach @{$self\->{option}};
\&    }
\&
\&    sub Latex::literal::explain {
\&        my ($self, $level, $label) = @_;
\&        $label //= \*(AqLiteral\*(Aq;
\&        say "\et"x$level, "$label: ", $self\->{q{}};
\&    }
.Ve
.PP
and then simply write:
.PP
.Vb 3
\&    if ($text =~ $LaTeX_parser) {
\&        $/{LaTeX_file}\->explain();
\&    }
.Ve
.PP
and the chain of \f(CWexplain()\fR calls would cascade down the nodes of the tree,
each one invoking the appropriate \f(CWexplain()\fR method according to the type of
node encountered.
.PP
The only problem is that, by default, Regexp::Grammars returns a tree of
plain-old hashes, not LaTeX::Whatever objects. Fortunately, it's easy to
request that the result hashes be automatically blessed into the appropriate
classes, using the \f(CW\*(C`<objrule:...>\*(C'\fR and \f(CW\*(C`<objtoken:...>\*(C'\fR directives.
.PP
These directives are identical to the \f(CW\*(C`<rule:...>\*(C'\fR and \f(CW\*(C`<token:...>\*(C'\fR directives (respectively), except that the rule or token
they create will also convert the hash it normally returns into an
object of a specified class. This conversion is done by passing the result
hash to the class's constructor:
.PP
.Vb 1
\&    $class\->new(\e%result_hash)
.Ve
.PP
if the class has a constructor method named \f(CWnew()\fR, or else (if
the class doesn't provide a constructor) by directly blessing the
result hash:
.PP
.Vb 1
\&    bless \e%result_hash, $class
.Ve
.PP
Note that, even if object is constructed via its own constructor, the
module still expects the new object to be hash-based, and will fail if
the object is anything but a blessed hash. The module issues an
error in this case.
.PP
The generic syntax for these types of rules and tokens is:
.PP
.Vb 2
\&    <objrule:  CLASS::NAME = RULENAME  >
\&    <objtoken: CLASS::NAME = TOKENNAME >
.Ve
.PP
For example:
.PP
.Vb 3
\&    <objrule: LaTeX::Element=component>
\&        # ...Defines a rule that can be called as <component>
\&        # ...and which returns a hash\-based LaTeX::Element object
\&
\&    <objtoken: LaTex::Literal=atom>
\&        # ...Defines a token that can be called as <atom>
\&        # ...and which returns a hash\-based LaTeX::Literal object
.Ve
.PP
Note that, just as in aliased subrule calls,
the name by which something is referred to outside the grammar (in this
case, the class name) comes \fIbefore\fR the \f(CW\*(C`=\*(C'\fR, whereas the name that it
is referred to inside the grammar comes \fIafter\fR the \f(CW\*(C`=\*(C'\fR.
.PP
You can freely mix object-returning and plain-old-hash-returning rules
and tokens within a single grammar, though you have to be careful not to
subsequently try to call a method on any of the unblessed nodes.
.PP
An important caveat regarding OO rules
.IX Subsection "An important caveat regarding OO rules"
.PP
Prior to Perl 5.14.0, Perl's regex engine was not fully re-entrant.
This means that in older versions of Perl, it is not possible to
re-invoke the regex engine when already inside the regex engine.
.PP
This means that you need to be careful that the \f(CWnew()\fR
constructors that are called by your object-rules do not themselves
use regexes in any way, unless you're running under Perl 5.14 or later
(in which case you can ignore what follows).
.PP
The two ways this is most likely to happen are:
.IP 1. 4
If you're using a class built on Moose, where one or more of the \f(CW\*(C`has\*(C'\fR
uses a type constraint (such as \f(CW\*(AqInt\*(Aq\fR) that is implemented via regex
matching. For example:
.Sp
.Vb 1
\&    has \*(Aqid\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
.Ve
.Sp
The workaround (for pre\-5.14 Perls) is to replace the type
constraint with one that doesn't use a regex. For example:
.Sp
.Vb 1
\&    has \*(Aqid\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqNum\*(Aq);
.Ve
.Sp
Alternatively, you could define your own type constraint that
avoids regexes:
.Sp
.Vb 1
\&    use Moose::Util::TypeConstraints;
\&
\&    subtype \*(AqNon::Regex::Int\*(Aq,
\&         as \*(AqNum\*(Aq,
\&      where { int($_) == $_ };
\&
\&    no Moose::Util::TypeConstraints;
\&
\&    # and later...
\&
\&    has \*(Aqid\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqNon::Regex::Int\*(Aq);
.Ve
.IP 2. 4
If your class uses an \f(CWAUTOLOAD()\fR method to implement its constructor
and that method uses the typical:
.Sp
.Vb 1
\&    $AUTOLOAD =~ s/.*://;
.Ve
.Sp
technique. The workaround here is to achieve the same effect without a
regex. For example:
.Sp
.Vb 2
\&    my $last_colon_pos = rindex($AUTOLOAD, \*(Aq:\*(Aq);
\&    substr $AUTOLOAD, 0, $last_colon_pos+1, q{};
.Ve
.PP
Note that this caveat against using nested regexes also applies to any
code blocks executed inside a rule or token (whether or not those rules
or tokens are object-oriented).
.PP
\fIA naming shortcut\fR
.IX Subsection "A naming shortcut"
.PP
If an \f(CW\*(C`<objrule:...>\*(C'\fR or \f(CW\*(C`<objtoken:...>\*(C'\fR is defined with a
class name that is \fInot\fR followed by \f(CW\*(C`=\*(C'\fR and a rule name, then the
rule name is determined automatically from the classname.
Specifically, the final component of the classname (i.e. after the last
\&\f(CW\*(C`::\*(C'\fR, if any) is used.
.PP
For example:
.PP
.Vb 3
\&    <objrule: LaTeX::Element>
\&        # ...Defines a rule that can be called as <Element>
\&        # ...and which returns a hash\-based LaTeX::Element object
\&
\&    <objtoken: LaTex::Literal>
\&        # ...Defines a token that can be called as <Literal>
\&        # ...and which returns a hash\-based LaTeX::Literal object
\&
\&    <objtoken: Comment>
\&        # ...Defines a token that can be called as <Comment>
\&        # ...and which returns a hash\-based Comment object
.Ve
.SH Debugging
.IX Header "Debugging"
Regexp::Grammars provides a number of features specifically designed to help
debug both grammars and the data they parse.
.PP
All debugging messages are written to a log file (which, by default, is
just STDERR). However, you can specify a disk file explicitly by placing a
\&\f(CW\*(C`<logfile:...>\*(C'\fR directive at the start of your grammar:
.PP
.Vb 1
\&    $grammar = qr{
\&
\&        <logfile: LaTeX_parser_log >
\&
\&        \eA <LaTeX_file> \eZ    # Pattern to match
\&
\&        <rule: LaTeX_file>
\&            # etc.
\&    }x;
.Ve
.PP
You can also explicitly specify that messages go to the terminal:
.PP
.Vb 1
\&        <logfile: \- >
.Ve
.ie n .SS "Debugging grammar creation with ""<logfile:...>"""
.el .SS "Debugging grammar creation with \f(CW<logfile:...>\fP"
.IX Subsection "Debugging grammar creation with <logfile:...>"
Whenever a log file has been directly specified,
Regexp::Grammars automatically does verbose static analysis of your grammar.
That is, whenever it compiles a grammar containing an explicit
\&\f(CW\*(C`<logfile:...>\*(C'\fR directive it logs a series of messages explaining how it
has interpreted the various components of that grammar. For example, the
following grammar:
.PP
.Vb 1
\&    <logfile: parser_log >
\&
\&    <cmd>
\&
\&    <rule: cmd>
\&        mv <from=file> <to=file>
\&      | cp <source> <[file]>  <.comment>?
.Ve
.PP
would produce the following analysis in the 'parser_log' file:
.PP
.Vb 10
\&    info | Processing the main regex before any rule definitions
\&         |    |
\&         |    |...Treating <cmd> as:
\&         |    |      |  match the subrule <cmd>
\&         |    |       \e saving the match in $MATCH{\*(Aqcmd\*(Aq}
\&         |    |
\&         |     \e_\|_\|_End of main regex
\&         |
\&    info | Defining a rule: <cmd>
\&         |    |...Returns: a hash
\&         |    |
\&         |    |...Treating \*(Aq mv \*(Aq as:
\&         |    |       \e normal Perl regex syntax
\&         |    |
\&         |    |...Treating <from=file> as:
\&         |    |      |  match the subrule <file>
\&         |    |       \e saving the match in $MATCH{\*(Aqfrom\*(Aq}
\&         |    |
\&         |    |...Treating <to=file> as:
\&         |    |      |  match the subrule <file>
\&         |    |       \e saving the match in $MATCH{\*(Aqto\*(Aq}
\&         |    |
\&         |    |...Treating \*(Aq | cp \*(Aq as:
\&         |    |       \e normal Perl regex syntax
\&         |    |
\&         |    |...Treating <source> as:
\&         |    |      |  match the subrule <source>
\&         |    |       \e saving the match in $MATCH{\*(Aqsource\*(Aq}
\&         |    |
\&         |    |...Treating <[file]> as:
\&         |    |      |  match the subrule <file>
\&         |    |       \e appending the match to $MATCH{\*(Aqfile\*(Aq}
\&         |    |
\&         |    |...Treating <.comment>? as:
\&         |    |      |  match the subrule <comment> if possible
\&         |    |       \e but don\*(Aqt save anything
\&         |    |
\&         |     \e_\|_\|_End of rule definition
.Ve
.PP
This kind of static analysis is a useful starting point in debugging a
miscreant grammar, because it enables you to see what you actually
specified (as opposed to what you \fIthought\fR you'd specified).
.ie n .SS "Debugging grammar execution with ""<debug:...>"""
.el .SS "Debugging grammar execution with \f(CW<debug:...>\fP"
.IX Subsection "Debugging grammar execution with <debug:...>"
Regexp::Grammars also provides a simple interactive debugger, with which you
can observe the process of parsing and the data being collected in any
result-hash.
.PP
To initiate debugging, place a \f(CW\*(C`<debug:...>\*(C'\fR directive anywhere in your
grammar. When parsing reaches that directive the debugger will be activated,
and the command specified in the directive immediately executed. The available
commands are:
.PP
.Vb 6
\&    <debug: on>    \- Enable debugging, stop when a rule matches
\&    <debug: match> \- Enable debugging, stop when a rule matches
\&    <debug: try>   \- Enable debugging, stop when a rule is tried
\&    <debug: run>   \- Enable debugging, run until the match completes
\&    <debug: same>  \- Continue debugging (or not) as currently
\&    <debug: off>   \- Disable debugging and continue parsing silently
\&
\&    <debug: continue> \- Synonym for <debug: run>
\&    <debug: step>     \- Synonym for <debug: try>
.Ve
.PP
These directives can be placed anywhere within a grammar and take effect
when that point is reached in the parsing. Hence, adding a
\&\f(CW\*(C`<debug:step>\*(C'\fR directive is very much like setting a breakpoint at that
point in the grammar. Indeed, a common debugging strategy is to turn
debugging on and off only around a suspect part of the grammar:
.PP
.Vb 4
\&    <rule: tricky>   # This is where we think the problem is...
\&        <debug:step>
\&        <preamble> <text> <postscript>
\&        <debug:off>
.Ve
.PP
Once the debugger is active, it steps through the parse, reporting rules
that are tried, matches and failures, backtracking and restarts, and the
parser's location within both the grammar and the text being matched. That
report looks like this:
.PP
.Vb 10
\&    ===============> Trying <grammar> from position 0
\&    > cp file1 file2 |...Trying <cmd>
\&                     |   |...Trying <cmd=(cp)>
\&                     |   |    \eFAIL <cmd=(cp)>
\&                     |    \eFAIL <cmd>
\&                      \eFAIL <grammar>
\&    ===============> Trying <grammar> from position 1
\&     cp file1 file2  |...Trying <cmd>
\&                     |   |...Trying <cmd=(cp)>
\&     file1 file2     |   |    \e_\|_\|_\|_\|_<cmd=(cp)> matched \*(Aqcp\*(Aq
\&    file1 file2      |   |...Trying <[file]>+
\&     file2           |   |    \e_\|_\|_\|_\|_<[file]>+ matched \*(Aqfile1\*(Aq
\&                     |   |...Trying <[file]>+
\&    [eos]            |   |    \e_\|_\|_\|_\|_<[file]>+ matched \*(Aq file2\*(Aq
\&                     |   |...Trying <[file]>+
\&                     |   |    \eFAIL <[file]>+
\&                     |   |...Trying <target>
\&                     |   |   |...Trying <file>
\&                     |   |   |    \eFAIL <file>
\&                     |   |    \eFAIL <target>
\&     <~~~~~~~~~~~~~~ |   |...Backtracking 5 chars and trying new match
\&    file2            |   |...Trying <target>
\&                     |   |   |...Trying <file>
\&                     |   |   |    \e_\|_\|_\|_ <file> matched \*(Aqfile2\*(Aq
\&    [eos]            |   |    \e_\|_\|_\|_\|_<target> matched \*(Aqfile2\*(Aq
\&                     |    \e_\|_\|_\|_\|_<cmd> matched \*(Aq cp file1 file2\*(Aq
\&                      \e_\|_\|_\|_\|_<grammar> matched \*(Aq cp file1 file2\*(Aq
.Ve
.PP
The first column indicates the point in the input at which the parser is
trying to match, as well as any backtracking or forward searching it may
need to do. The remainder of the columns track the parser's hierarchical
traversal of the grammar, indicating which rules are tried, which
succeed, and what they match.
.PP
Provided the logfile is a terminal (as it is by default), the debugger
also pauses at various points in the parsing process\-\-before trying a
rule, after a rule succeeds, or at the end of the parse\-\-according to
the most recent command issued. When it pauses, you can issue a new
command by entering a single letter:
.PP
.Vb 4
\&    m       \- to continue until the next subrule matches
\&    t or s  \- to continue until the next subrule is tried
\&    r or c  \- to continue to the end of the grammar
\&    o       \- to switch off debugging
.Ve
.PP
Note that these are the first letters of the corresponding
\&\f(CW\*(C`<debug:...>\*(C'\fR commands, listed earlier. Just hitting ENTER while the
debugger is paused repeats the previous command.
.PP
While the debugger is paused you can also type a 'd', which will display
the result-hash for the current rule. This can be useful for detecting
which rule isn't returning the data you expected.
.PP
\fIResizing the context string\fR
.IX Subsection "Resizing the context string"
.PP
By default, the first column of the debugger output (which shows the
current matching position within the string) is limited to a width of
20 columns.
.PP
However, you can change that limit calling the
\&\f(CWRegexp::Grammars::set_context_width()\fR subroutine. You have to specify
the fully qualified name, however, as Regexp::Grammars does not export
this (or any other) subroutine.
.PP
\&\f(CWset_context_width()\fR expects a single argument: a positive integer
indicating the maximal allowable width for the context column. It issues
a warning if an invalid value is passed, and ignores it.
.PP
If called in a void context, \f(CWset_context_width()\fR changes the context
width permanently throughout your application. If called in a scalar or
list context, \f(CWset_context_width()\fR returns an object whose destructor
will cause the context width to revert to its previous value. This means
you can temporarily change the context width within a given block with
something like:
.PP
.Vb 2
\&    {
\&        my $temporary = Regexp::Grammars::set_context_width(50);
\&
\&        if ($text =~ $parser) {
\&            do_stuff_with( %/ );
\&        }
\&
\&    } # <\-\-\- context width automagically reverts at this point
.Ve
.PP
and the context width will change back to its previous value when
\&\f(CW$temporary\fR goes out of scope at the end of the block.
.ie n .SS "User-defined logging with ""<log:...>"""
.el .SS "User-defined logging with \f(CW<log:...>\fP"
.IX Subsection "User-defined logging with <log:...>"
Both static and interactive debugging send a series of predefined log messages
to whatever log file you have specified. It is also possible to send
additional, user-defined messages to the log, using the \f(CW\*(C`<log:...>\*(C'\fR
directive.
.PP
This directive expects either a simple text or a codeblock as its single
argument. If the argument is a code block, that code is expected to
return the text of the message; if the argument is anything else, that
something else \fIis\fR the literal message. For example:
.PP
.Vb 1
\&    <rule: ListElem>
\&
\&        <Elem=   ( [a\-z]\ed+) >
\&            <log: Checking for a suffix, too...>
\&
\&        <Suffix= ( : \ed+   ) >?
\&            <log: (?{ "ListElem: $MATCH{Elem} and $MATCH{Suffix}" })>
.Ve
.PP
User-defined log messages implemented using a codeblock can also specify
a severity level. If the codeblock of a \f(CW\*(C`<log:...>\*(C'\fR directive
returns two or more values, the first is treated as a log message
severity indicator, and the remaining values as separate lines of text
to be logged. For example:
.PP
.Vb 3
\&    <rule: ListElem>
\&        <Elem=   ( [a\-z]\ed+) >
\&        <Suffix= ( : \ed+   ) >?
\&
\&            <log: (?{
\&                warn => "Elem was: $MATCH{Elem}",
\&                        "Suffix was $MATCH{Suffix}",
\&            })>
.Ve
.PP
When they are encountered, user-defined log messages are interspersed
between any automatic log messages (i.e. from the debugger), at the correct
level of nesting for the current rule.
.SS "Debugging non-grammars"
.IX Subsection "Debugging non-grammars"
\&\fI[Note that, with the release in 2012 of the Regexp::Debugger module (on
CPAN) the techniques described below are unnecessary. If you need to
debug plain Perl regexes, use Regexp::Debugger instead.]\fR
.PP
It is possible to use Regexp::Grammars without creating \fIany\fR subrule
definitions, simply to debug a recalcitrant regex. For example, if the
following regex wasn't working as expected:
.PP
.Vb 9
\&    my $balanced_brackets = qr{
\&        \e(             # left delim
\&        (?:
\&            \e\e         # escape or
\&        |   (?R)       # recurse or
\&        |   .          # whatever
\&        )*
\&        \e)             # right delim
\&    }xms;
.Ve
.PP
you could instrument it with aliased subpatterns and then debug it
step-by-step, using Regexp::Grammars:
.PP
.Vb 1
\&    use Regexp::Grammars;
\&
\&    my $balanced_brackets = qr{
\&        <debug:step>
\&
\&        <.left_delim=  (  \e(  )>
\&        (?:
\&            <.escape=  (  \e\e  )>
\&        |   <.recurse= ( (?R) )>
\&        |   <.whatever=(  .   )>
\&        )*
\&        <.right_delim= (  \e)  )>
\&    }xms;
\&
\&    while (<>) {
\&        say \*(Aqmatched\*(Aq if /$balanced_brackets/;
\&    }
.Ve
.PP
Note the use of amnesiac aliased subpatterns
to avoid needlessly building a result-hash. Alternatively, you could use
listifying aliases to preserve the matching structure as an additional
debugging aid:
.PP
.Vb 1
\&    use Regexp::Grammars;
\&
\&    my $balanced_brackets = qr{
\&        <debug:step>
\&
\&        <[left_delim=  (  \e(  )]>
\&        (?:
\&            <[escape=  (  \e\e  )]>
\&        |   <[recurse= ( (?R) )]>
\&        |   <[whatever=(  .   )]>
\&        )*
\&        <[right_delim= (  \e)  )]>
\&    }xms;
\&
\&    if ( \*(Aq(a(bc)d)\*(Aq =~ /$balanced_brackets/) {
\&        use Data::Dumper \*(AqDumper\*(Aq;
\&        warn Dumper \e%/;
\&    }
.Ve
.SH "Handling errors when parsing"
.IX Header "Handling errors when parsing"
Assuming you have correctly debugged your grammar, the next source of problems
will probably be invalid input (especially if that input is being provided
interactively). So Regexp::Grammars also provides some support for detecting
when a parse is likely to fail...and informing the user why.
.SS Requirements
.IX Subsection "Requirements"
The \f(CW\*(C`<require:...>\*(C'\fR directive is useful for testing conditions
that it's not easy (or even possible) to check within the syntax of the
the regex itself. For example:
.PP
.Vb 3
\&    <rule: IPV4_Octet_Decimal>
\&        # Up three digits...
\&        <MATCH= ( \ed{1,3}+ )>
\&
\&        # ...but less than 256...
\&        <require: (?{ $MATCH <= 255 })>
.Ve
.PP
A require expects a regex codeblock as its argument and succeeds if the final
value of that codeblock is true. If the final value is false, the directive
fails and the rule starts backtracking.
.PP
Note, in this example that the digits are matched with \f(CW\*(C` \ed{1,3}+ \*(C'\fR. The
trailing \f(CW\*(C`+\*(C'\fR prevents the \f(CW\*(C`{1,3}\*(C'\fR repetition from backtracking to a smaller
number of digits if the \f(CW\*(C`<require:...>\*(C'\fR fails.
.SS "Handling failure"
.IX Subsection "Handling failure"
The module has limited support for error reporting from within a grammar,
in the form of the \f(CW\*(C`<error:...>\*(C'\fR and \f(CW\*(C`<warning:...>\*(C'\fR directives
and their shortcuts: \f(CW\*(C`<...>\*(C'\fR, \f(CW\*(C`<!!!>\*(C'\fR, and \f(CW\*(C`<???>\*(C'\fR
.PP
\fIError messages\fR
.IX Subsection "Error messages"
.PP
The \f(CW\*(C`<error: MSG>\*(C'\fR directive queues a \fIconditional\fR error message
within \f(CW\*(C`@!\*(C'\fR and then fails to match (that is, it is equivalent to a
\&\f(CW\*(C`(?!)\*(C'\fR when matching). For example:
.PP
.Vb 4
\&    <rule: ListElem>
\&        <SerialNumber>
\&      | <ClientName>
\&      | <error: (?{ $errcount++ . \*(Aq: Missing list element\*(Aq })>
.Ve
.PP
So a common code pattern when using grammars that do this kind of error
detection is:
.PP
.Vb 6
\&    if ($text =~ $grammar) {
\&        # Do something with the data collected in %/
\&    }
\&    else {
\&        say {*STDERR} $_ for @!;   # i.e. report all errors
\&    }
.Ve
.PP
Each error message is conditional in the sense that, if any surrounding rule
subsequently matches, the message is automatically removed from \f(CW\*(C`@!\*(C'\fR. This
implies that you can queue up as many error messages as you wish, but they
will only remain in \f(CW\*(C`@!\*(C'\fR if the match ultimately fails. Moreover, only those
error messages originating from rules that actually contributed to the
eventual failure-to-match will remain in \f(CW\*(C`@!\*(C'\fR.
.PP
If a code block is specified as the argument, the error message is whatever
final value is produced when the block is executed. Note that this final value
does not have to be a string (though it does have to be a scalar).
.PP
.Vb 7
\&    <rule: ListElem>
\&        <SerialNumber>
\&      | <ClientName>
\&      | <error: (?{
\&            # Return a hash, with the error information...
\&            { errnum => $errcount++, msg => \*(AqMissing list element\*(Aq }
\&        })>
.Ve
.PP
If anything else is specified as the argument, it is treated as a
literal error string (and may not contain an unbalanced \f(CW\*(Aq<\*(Aq\fR
or \f(CW\*(Aq>\*(Aq\fR, nor any interpolated variables).
.PP
However, if the literal error string begins with "Expected " or
"Expecting ", then the error string automatically has the following
"context suffix" appended:
.PP
.Vb 1
\&    , but found \*(Aq$CONTEXT\*(Aq instead
.Ve
.PP
For example:
.PP
.Vb 3
\&    qr{ <Arithmetic_Expression>                # ...Match arithmetic expression
\&      |                                        # Or else
\&        <error: Expected a valid expression>   # ...Report error, and fail
\&
\&        # Rule definitions here...
\&    }xms;
.Ve
.PP
On an invalid input this example might produce an error message like:
.PP
.Vb 1
\&    "Expected a valid expression, but found \*(Aq(2+3]*7/\*(Aq instead"
.Ve
.PP
The value of the special \f(CW$CONTEXT\fR variable is found by looking ahead in
the string being matched against, to locate the next sequence of non-blank
characters after the current parsing position. This variable may also be
explicitly used within the \f(CW\*(C`<error: (?{...})>\*(C'\fR form of the directive.
.PP
As a special case, if you omit the message entirely from the directive,
it is supplied automatically, derived from the name of the current rule.
For example, if the following rule were to fail to match:
.PP
.Vb 3
\&    <rule: Arithmetic_expression>
\&          <Multiplicative_Expression>+ % ([+\-])
\&        | <error:>
.Ve
.PP
the error message queued would be:
.PP
.Vb 1
\&    "Expected arithmetic expression, but found \*(Aqone plus two\*(Aq instead"
.Ve
.PP
Note however, that it is still essential to include the colon in the
directive. A common mistake is to write:
.PP
.Vb 3
\&    <rule: Arithmetic_expression>
\&          <Multiplicative_Expression>+ % ([+\-])
\&        | <error>
.Ve
.PP
which merely attempts to call \f(CW\*(C`<rule: error>\*(C'\fR if the first
alternative fails.
.PP
\fIWarning messages\fR
.IX Subsection "Warning messages"
.PP
Sometimes, you want to detect problems, but not invalidate the entire
parse as a result. For those occasions, the module provides a "less stringent"
form of error reporting: the \f(CW\*(C`<warning:...>\*(C'\fR directive.
.PP
This directive is exactly the same as an \f(CW\*(C`<error:...>\*(C'\fR in every respect
except that it does not induce a failure to match at the point it appears.
.PP
The directive is, therefore, useful for reporting \fInon-fatal\fR problems
in a parse. For example:
.PP
.Vb 2
\&    qr{ \eA            # ...Match only at start of input
\&        <ArithExpr>   # ...Match a valid arithmetic expression
\&
\&        (?:
\&            # Should be at end of input...
\&            \es* \eZ
\&          |
\&            # If not, report the fact but don\*(Aqt fail...
\&            <warning: Expected end\-of\-input>
\&            <warning: (?{ "Extra junk at index $INDEX: $CONTEXT" })>
\&        )
\&
\&        # Rule definitions here...
\&    }xms;
.Ve
.PP
Note that, because they do not induce failure, two or more
\&\f(CW\*(C`<warning:...>\*(C'\fR directives can be "stacked" in sequence,
as in the previous example.
.PP
\fIStubbing\fR
.IX Subsection "Stubbing"
.PP
The module also provides three useful shortcuts, specifically to
make it easy to declare, but not define, rules and tokens.
.PP
The \f(CW\*(C`<...>\*(C'\fR and \f(CW\*(C`<!!!>\*(C'\fR directives are equivalent to
the directive:
.PP
.Vb 1
\&    <error: Cannot match RULENAME (not implemented)>
.Ve
.PP
The \f(CW\*(C`<???>\*(C'\fR is equivalent to the directive:
.PP
.Vb 1
\&    <warning: Cannot match RULENAME (not implemented)>
.Ve
.PP
For example, in the following grammar:
.PP
.Vb 1
\&    <grammar: List::Generic>
\&
\&    <rule: List>
\&        <[Item]>+ % (\es*,\es*)
\&
\&    <rule: Item>
\&        <...>
.Ve
.PP
the \f(CW\*(C`Item\*(C'\fR rule is declared but not defined. That means the grammar
will compile correctly, (the \f(CW\*(C`List\*(C'\fR rule won't complain about a call to
a non-existent \f(CW\*(C`Item\*(C'\fR), but if the \f(CW\*(C`Item\*(C'\fR rule isn't overridden in
some derived grammar, a match-time error will occur when \f(CW\*(C`List\*(C'\fR tries
to match the \f(CW\*(C`<...>\*(C'\fR within \f(CW\*(C`Item\*(C'\fR.
.PP
\fILocalizing the (semi\-)automatic error messages\fR
.IX Subsection "Localizing the (semi-)automatic error messages"
.PP
Error directives of any of the following forms:
.PP
.Vb 1
\&    <error: Expecting identifier>
\&
\&    <error: >
\&
\&    <...>
\&
\&    <!!!>
.Ve
.PP
or their warning equivalents:
.PP
.Vb 1
\&    <warning: Expecting identifier>
\&
\&    <warning: >
\&
\&    <???>
.Ve
.PP
each autogenerate part or all of the actual error message they produce.
By default, that autogenerated message is always produced in English.
.PP
However, the module provides a mechanism by which you can
intercept \fIevery\fR error or warning that is queued to \f(CW\*(C`@!\*(C'\fR
via these directives...and localize those messages.
.PP
To do this, you call \f(CWRegexp::Grammars::set_error_translator()\fR
(with the full qualification, since Regexp::Grammars does not
export it...nor anything else, for that matter).
.PP
The \f(CWset_error_translator()\fR subroutine expect as single
argument, which must be a reference to another subroutine.
This subroutine is then called whenever an error or warning
message is queued to \f(CW\*(C`@!\*(C'\fR.
.PP
The subroutine is passed three arguments:
.IP \(bu 4
the message string,
.IP \(bu 4
the name of the rule from which the error or warning was queued, and
.IP \(bu 4
the value of \f(CW$CONTEXT\fR when the error or warning was encountered
.PP
The subroutine is expected to return the final version of the message
that is actually to be appended to \f(CW\*(C`@!\*(C'\fR. To accomplish this it may make
use of one of the many internationalization/localization modules
available in Perl, or it may do the conversion entirely by itself.
.PP
The first argument is always exactly what appeared as a message in the
original directive (regardless of whether that message is supposed to
trigger autogeneration, or is just a "regular" error message).
That is:
.PP
.Vb 1
\&    Directive                         1st argument
\&
\&    <error: Expecting identifier>     "Expecting identifier"
\&    <warning: That\*(Aqs not a moon!>     "That\*(Aqs not a moon!"
\&    <error: >                         ""
\&    <warning: >                       ""
\&    <...>                             ""
\&    <!!!>                             ""
\&    <???>                             ""
.Ve
.PP
The second argument always contains the name of the rule in which the
directive was encountered. For example, when invoked from within
\&\f(CW\*(C`<rule: Frinstance>\*(C'\fR the following directives produce:
.PP
.Vb 1
\&    Directive                         2nd argument
\&
\&    <error: Expecting identifier>     "Frinstance"
\&    <warning: That\*(Aqs not a moon!>     "Frinstance"
\&    <error: >                         "Frinstance"
\&    <warning: >                       "Frinstance"
\&    <...>                             "\-Frinstance"
\&    <!!!>                             "\-Frinstance"
\&    <???>                             "\-Frinstance"
.Ve
.PP
Note that the "unimplemented" markers pass the rule name with a
preceding \f(CW\*(Aq\-\*(Aq\fR. This allows your translator to distinguish between
"empty" messages (which should then be generated automatically) and the
"unimplemented" markers (which should report that the rule is not yet
properly defined).
.PP
If you call \f(CWRegexp::Grammars::set_error_translator()\fR in a void
context, the error translator is permanently replaced (at least,
until the next call to \f(CWset_error_translator()\fR).
.PP
However, if you call \f(CWRegexp::Grammars::set_error_translator()\fR in a
scalar or list context, it returns an object whose destructor will
restore the previous translator. This allows you to install a
translator only within a given scope, like so:
.PP
.Vb 3
\&    {
\&        my $temporary
\&            = Regexp::Grammars::set_error_translator(\e&my_translator);
\&
\&        if ($text =~ $parser) {
\&            do_stuff_with( %/ );
\&        }
\&        else {
\&            report_errors_in( @! );
\&        }
\&
\&    } # <\-\-\- error translator automagically reverts at this point
.Ve
.PP
\&\fBWarning\fR: any error translation subroutine you install will be
called during the grammar's parsing phase (i.e. as the grammar's regex
is matching). You should therefore ensure that your translator does
not itself use regular expressions, as nested evaluations of regexes
inside other regexes are extremely problematical (i.e. almost always
disastrous) in Perl.
.SS "Restricting how long a parse runs"
.IX Subsection "Restricting how long a parse runs"
Like the core Perl 5 regex engine on which they are built, the grammars
implemented by Regexp::Grammars are essentially top-down parsers. This
means that they may occasionally require an exponentially long time to
parse a particular input. This usually occurs if a particular grammar
includes a lot of recursion or nested backtracking, especially if the
grammar is then matched against a long string.
.PP
The judicious use of non-backtracking repetitions (i.e. \f(CW\*(C`x*+\*(C'\fR and
\&\f(CW\*(C`x++\*(C'\fR) can significantly improve parsing performance in many such
cases. Likewise, carefully reordering any high-level alternatives
(so as to test simple common cases first) can substantially reduce
parsing times.
.PP
However, some languages are just intrinsically slow to parse using
top-down techniques (or, at least, may have slow-to-parse corner cases).
.PP
To help cope with this constraint, Regexp::Grammars provides a mechanism
by which you can limit the total effort that a given grammar will expend
in attempting to match. The \f(CW\*(C`<timeout:...>\*(C'\fR directive allows you
to specify how long a grammar is allowed to continue trying to match
before giving up. It expects a single argument, which must be an
unsigned integer, and it treats this integer as the number of seconds
to continue attempting to match.
.PP
For example:
.PP
.Vb 1
\&    <timeout: 10>    # Give up after 10 seconds
.Ve
.PP
indicates that the grammar should keep attempting to match for another
10 seconds from the point where the directive is encountered during a
parse. If the complete grammar has not matched in that time, the entire
match is considered to have failed, the matching process is immediately
terminated, and a standard error message
(\f(CW\*(AqInternal error: Timed out after 10 seconds (as requested)\*(Aq\fR)
is returned in \f(CW\*(C`@!\*(C'\fR.
.PP
A \f(CW\*(C`<timeout:...>\*(C'\fR directive can be placed anywhere in a grammar,
but is most usually placed at the very start, so that the entire grammar
is governed by the specified time limit. The second most common alternative
is to place the timeout at the start of a particular subrule that is known
to be potentially very slow.
.PP
A common mistake is to put the timeout specification at the top level
of the grammar, but place it \fIafter\fR the actual subrule to be matched,
like so:
.PP
.Vb 1
\&    my $grammar = qr{
\&
\&        <Text_Corpus>      # Subrule to be matched
\&        <timeout: 10>      # Useless use of timeout
\&
\&        <rule: Text_Corpus>
\&            # et cetera...
\&    }xms;
.Ve
.PP
Since the parser will only reach the \f(CW\*(C`<timeout: 10>\*(C'\fR directive
\&\fIafter\fR it has completely matched \f(CW\*(C`<Text_Corpus>\*(C'\fR, the timeout is
only initiated at the very end of the matching process and so does not
limit that process in any useful way.
.PP
\fIImmediate timeouts\fR
.IX Subsection "Immediate timeouts"
.PP
As you might expect, a \f(CW\*(C`<timeout: 0>\*(C'\fR directive tells the parser to
keep trying for only zero more seconds, and therefore will immediately
cause the entire surrounding grammar to fail (no matter how deeply
within that grammar the directive is encountered).
.PP
This can occasionally be exteremely useful. If you know that detecting a
particular datum means that the grammar will never match, no matter how
many other alternatives may subsequently be tried, you can short-circuit
the parser by injecting a \f(CW\*(C`<timeout: 0>\*(C'\fR immediately after the
offending datum is detected.
.PP
For example, if your grammar only accepts certain versions of the
language being parsed, you could write:
.PP
.Vb 6
\&    <rule: Valid_Language_Version>
\&            vers = <%AcceptableVersions>
\&        |
\&            vers = <bad_version=(\eS++)>
\&            <warning: (?{ "Cannot parse language version $MATCH{bad_version}" })>
\&            <timeout: 0>
.Ve
.PP
In fact, this \f(CW\*(C`<warning: MSG> <timeout: 0>\*(C'\fR sequence
is sufficiently useful, sufficiently complex, and sufficiently easy
to get wrong, that Regexp::Grammars provides a handy shortcut for it:
the \f(CW\*(C`<fatal:...>\*(C'\fR directive. A \f(CW\*(C`<fatal:...>\*(C'\fR is exactly
equivalent to a \f(CW\*(C`<warning:...>\*(C'\fR followed by a zero-timeout,
so the previous example could also be written:
.PP
.Vb 5
\&    <rule: Valid_Language_Version>
\&            vers = <%AcceptableVersions>
\&        |
\&            vers = <bad_version=(\eS++)>
\&            <fatal: (?{ "Cannot parse language version $MATCH{bad_version}" })>
.Ve
.PP
Like \f(CW\*(C`<error:...>\*(C'\fR and \f(CW\*(C`<warning:...>\*(C'\fR, \f(CW\*(C`<fatal:...>\*(C'\fR also
provides its own failure context in \f(CW$CONTEXT\fR, so the previous example
could be further simplified to:
.PP
.Vb 4
\&    <rule: Valid_Language_Version>
\&            vers = <%AcceptableVersions>
\&        |
\&            vers = <fatal:(?{ "Cannot parse language version $CONTEXT" })>
.Ve
.PP
Also like \f(CW\*(C`<error:...>\*(C'\fR, \f(CW\*(C`<fatal:...>\*(C'\fR can autogenerate an
error message if none is provided, so the example could be still further
reduced to:
.PP
.Vb 4
\&    <rule: Valid_Language_Version>
\&            vers = <%AcceptableVersions>
\&        |
\&            vers = <fatal:>
.Ve
.PP
In this last case, however, the error message returned in \f(CW\*(C`@!\*(C'\fR would no
longer be:
.PP
.Vb 1
\&    Cannot parse language version 0.95
.Ve
.PP
It would now be:
.PP
.Vb 1
\&    Expected valid language version, but found \*(Aq0.95\*(Aq instead
.Ve
.SH "Scoping considerations"
.IX Header "Scoping considerations"
If you intend to use a grammar as part of a larger program that contains
other (non-grammatical) regexes, it is more efficient\-\-and less
error\-prone\-\-to avoid having Regexp::Grammars process those regexes as
well. So it's often a good idea to declare your grammar in a \f(CW\*(C`do\*(C'\fR
block, thereby restricting the scope of the module's effects.
.PP
For example:
.PP
.Vb 4
\&    my $grammar = do {
\&        use Regexp::Grammars;
\&        qr{
\&            <file>
\&
\&            <rule: file>
\&                <prelude>
\&                <data>
\&                <postlude>
\&
\&            <rule: prelude>
\&                # etc.
\&        }x;
\&    };
.Ve
.PP
Because the effects of Regexp::Grammars are lexically scoped, any regexes
defined outside that \f(CW\*(C`do\*(C'\fR block will be unaffected by the module.
.SH INTERFACE
.IX Header "INTERFACE"
.SS "Perl API"
.IX Subsection "Perl API"
.ie n .IP """use Regexp::Grammars;""" 4
.el .IP "\f(CWuse Regexp::Grammars;\fR" 4
.IX Item "use Regexp::Grammars;"
Causes all regexes in the current lexical scope to be compile-time processed
for grammar elements.
.ie n .IP """$str =~ $grammar""" 4
.el .IP "\f(CW$str =~ $grammar\fR" 4
.IX Item "$str =~ $grammar"
.PD 0
.ie n .IP """$str =~ /$grammar/""" 4
.el .IP "\f(CW$str =~ /$grammar/\fR" 4
.IX Item "$str =~ /$grammar/"
.PD
Attempt to match the grammar against the string, building a nested data
structure from it.
.ie n .IP """%/""" 4
.el .IP \f(CW%/\fR 4
.IX Item "%/"
This hash is assigned the nested data structure created by any successful
match of a grammar regex.
.ie n .IP """@!""" 4
.el .IP \f(CW@!\fR 4
.IX Item "@!"
This array is assigned the queue of error messages created by any
unsuccessful match attempt of a grammar regex.
.SS "Grammar syntax"
.IX Subsection "Grammar syntax"
\fIDirectives\fR
.IX Subsection "Directives"
.ie n .IP """<rule: IDENTIFIER>""" 4
.el .IP "\f(CW<rule: IDENTIFIER>\fR" 4
.IX Item "<rule: IDENTIFIER>"
Define a rule whose name is specified by the supplied identifier.
.Sp
Everything following the \f(CW\*(C`<rule:...>\*(C'\fR directive
(up to the next \f(CW\*(C`<rule:...>\*(C'\fR or \f(CW\*(C`<token:...>\*(C'\fR directive) is
treated as part of the rule being defined.
.Sp
Any whitespace in the rule is replaced by a call to the \f(CW\*(C`<.ws>\*(C'\fR
subrule (which defaults to matching \f(CW\*(C`\es*\*(C'\fR, but may be explicitly redefined).
.ie n .IP """<token: IDENTIFIER>""" 4
.el .IP "\f(CW<token: IDENTIFIER>\fR" 4
.IX Item "<token: IDENTIFIER>"
Define a rule whose name is specified by the supplied identifier.
.Sp
Everything following the \f(CW\*(C`<token:...>\*(C'\fR directive (up to the next
\&\f(CW\*(C`<rule:...>\*(C'\fR or \f(CW\*(C`<token:...>\*(C'\fR directive) is treated as part
of the rule being defined.
.Sp
Any whitespace in the rule is ignored (under the \f(CW\*(C`/x\*(C'\fR modifier), or
explicitly matched (if \f(CW\*(C`/x\*(C'\fR is not used).
.ie n .IP """<objrule:  IDENTIFIER>""" 4
.el .IP "\f(CW<objrule:  IDENTIFIER>\fR" 4
.IX Item "<objrule: IDENTIFIER>"
.PD 0
.ie n .IP """<objtoken: IDENTIFIER>""" 4
.el .IP "\f(CW<objtoken: IDENTIFIER>\fR" 4
.IX Item "<objtoken: IDENTIFIER>"
.PD
Identical to a \f(CW\*(C`<rule: IDENTIFIER>\*(C'\fR or \f(CW\*(C`<token: IDENTIFIER>\*(C'\fR
declaration, except that the rule or token will also bless the hash it
normally returns, converting it to an object of a class whose name is
the same as the rule or token itself.
.ie n .IP """<require: (?{ CODE }) >""" 4
.el .IP "\f(CW<require: (?{ CODE }) >\fR" 4
.IX Item "<require: (?{ CODE }) >"
The code block is executed and if its final value is true, matching continues
from the same position. If the block's final value is false, the match fails at
that point and starts backtracking.
.ie n .IP """<error: (?{ CODE })  >""" 4
.el .IP "\f(CW<error: (?{ CODE })  >\fR" 4
.IX Item "<error: (?{ CODE }) >"
.PD 0
.ie n .IP """<error: LITERAL TEXT >""" 4
.el .IP "\f(CW<error: LITERAL TEXT >\fR" 4
.IX Item "<error: LITERAL TEXT >"
.ie n .IP """<error: >""" 4
.el .IP "\f(CW<error: >\fR" 4
.IX Item "<error: >"
.PD
This directive queues a \fIconditional\fR error message within the global
special variable \f(CW\*(C`@!\*(C'\fR and then fails to match at that point (that is,
it is equivalent to a \f(CW\*(C`(?!)\*(C'\fR or \f(CW\*(C`(*FAIL)\*(C'\fR when matching).
.ie n .IP """<fatal: (?{ CODE })  >""" 4
.el .IP "\f(CW<fatal: (?{ CODE })  >\fR" 4
.IX Item "<fatal: (?{ CODE }) >"
.PD 0
.ie n .IP """<fatal: LITERAL TEXT >""" 4
.el .IP "\f(CW<fatal: LITERAL TEXT >\fR" 4
.IX Item "<fatal: LITERAL TEXT >"
.ie n .IP """<fatal: >""" 4
.el .IP "\f(CW<fatal: >\fR" 4
.IX Item "<fatal: >"
.PD
This directive is exactly the same as an \f(CW\*(C`<error:...>\*(C'\fR in every
respect except that it immediately causes the entire surrounding
grammar to fail, and parsing to immediate cease.
.ie n .IP """<warning: (?{ CODE })  >""" 4
.el .IP "\f(CW<warning: (?{ CODE })  >\fR" 4
.IX Item "<warning: (?{ CODE }) >"
.PD 0
.ie n .IP """<warning: LITERAL TEXT >""" 4
.el .IP "\f(CW<warning: LITERAL TEXT >\fR" 4
.IX Item "<warning: LITERAL TEXT >"
.PD
This directive is exactly the same as an \f(CW\*(C`<error:...>\*(C'\fR in every
respect except that it does not induce a failure to match at the point
it appears. That is, it is equivalent to a \f(CW\*(C`(?=)\*(C'\fR ["succeed and
continue matching"], rather than a \f(CW\*(C`(?!)\*(C'\fR ["fail and backtrack"].
.ie n .IP """<debug: COMMAND >""" 4
.el .IP "\f(CW<debug: COMMAND >\fR" 4
.IX Item "<debug: COMMAND >"
During the matching of grammar regexes send debugging and warning
information to the specified log file (see \f(CW\*(C`<logfile: LOGFILE>\*(C'\fR).
.Sp
The available \f(CW\*(C`COMMAND\*(C'\fR's are:
.Sp
.Vb 2
\&    <debug: continue>    _\|_\|_ Debug until end of complete parse
\&    <debug: run>         _/
\&
\&    <debug: on>          _\|_\|_ Debug until next subrule match
\&    <debug: match>       _/
\&
\&    <debug: try>         _\|_\|_ Debug until next subrule call or match
\&    <debug: step>        _/
\&
\&    <debug: same>        _\|_\|_ Maintain current debugging mode
\&
\&    <debug: off>         _\|_\|_ No debugging
.Ve
.Sp
See also the \f(CW$DEBUG\fR special variable.
.ie n .IP """<logfile: LOGFILE>""" 4
.el .IP "\f(CW<logfile: LOGFILE>\fR" 4
.IX Item "<logfile: LOGFILE>"
.PD 0
.ie n .IP """<logfile:    \-   >""" 4
.el .IP "\f(CW<logfile:    \-   >\fR" 4
.IX Item "<logfile: - >"
.PD
During the compilation of grammar regexes, send debugging and warning
information to the specified LOGFILE (or to \f(CW*STDERR\fR if \f(CW\*(C`\-\*(C'\fR is
specified).
.Sp
If the specified LOGFILE name contains a \f(CW%t\fR, it is replaced with a
(sortable) "YYYYMMDD.HHMMSS" timestamp. For example:
.Sp
.Vb 1
\&    <logfile: test\-run\-%t >
.Ve
.Sp
executed at around 9.30pm on the 21st of March 2009, would generate a
log file named: \f(CW\*(C`test\-run\-20090321.213056\*(C'\fR
.ie n .IP """<log: (?{ CODE })  >""" 4
.el .IP "\f(CW<log: (?{ CODE })  >\fR" 4
.IX Item "<log: (?{ CODE }) >"
.PD 0
.ie n .IP """<log: LITERAL TEXT >""" 4
.el .IP "\f(CW<log: LITERAL TEXT >\fR" 4
.IX Item "<log: LITERAL TEXT >"
.PD
Append a message to the log file. If the argument is a code block,
that code is expected to return the text of the message; if the
argument is anything else, that something else \fIis\fR the literal
message.
.Sp
If the block returns two or more values, the first is treated as a log
message severity indicator, and the remaining values as separate lines
of text to be logged.
.ie n .IP """<timeout: INT >""" 4
.el .IP "\f(CW<timeout: INT >\fR" 4
.IX Item "<timeout: INT >"
Restrict the match-time of the parse to the specified number of seconds.
Queues a error message and terminates the entire match process
if the parse does not complete within the nominated time limit.
.PP
\fISubrule calls\fR
.IX Subsection "Subrule calls"
.ie n .IP """<IDENTIFIER>""" 4
.el .IP \f(CW<IDENTIFIER>\fR 4
.IX Item "<IDENTIFIER>"
Call the subrule whose name is IDENTIFIER.
.Sp
If it matches successfully, save the hash it returns in the current
scope's result-hash, under the key \f(CW\*(AqIDENTIFIER\*(Aq\fR.
.ie n .IP """<IDENTIFIER_1=IDENTIFIER_2>""" 4
.el .IP \f(CW<IDENTIFIER_1=IDENTIFIER_2>\fR 4
.IX Item "<IDENTIFIER_1=IDENTIFIER_2>"
Call the subrule whose name is IDENTIFIER_1.
.Sp
If it matches successfully, save the hash it returns in the current
scope's result-hash, under the key \f(CW\*(AqIDENTIFIER_2\*(Aq\fR.
.Sp
In other words, the \f(CW\*(C`IDENTIFIER_1=\*(C'\fR prefix changes the key under which the
result of calling a subrule is stored.
.ie n .IP """<.IDENTIFIER>""" 4
.el .IP \f(CW<.IDENTIFIER>\fR 4
.IX Item "<.IDENTIFIER>"
Call the subrule whose name is IDENTIFIER.
Don't save the hash it returns.
.Sp
In other words, the "dot" prefix disables saving of subrule results.
.ie n .IP """<IDENTIFIER= ( PATTERN )>""" 4
.el .IP "\f(CW<IDENTIFIER= ( PATTERN )>\fR" 4
.IX Item "<IDENTIFIER= ( PATTERN )>"
Match the subpattern PATTERN.
.Sp
If it matches successfully, capture the substring it matched and save
that substring in the current scope's result-hash, under the key
\&'IDENTIFIER'.
.ie n .IP """<.IDENTIFIER= ( PATTERN )>""" 4
.el .IP "\f(CW<.IDENTIFIER= ( PATTERN )>\fR" 4
.IX Item "<.IDENTIFIER= ( PATTERN )>"
Match the subpattern PATTERN.
Don't save the substring it matched.
.ie n .IP """<IDENTIFIER= %HASH>""" 4
.el .IP "\f(CW<IDENTIFIER= %HASH>\fR" 4
.IX Item "<IDENTIFIER= %HASH>"
Match a sequence of non-whitespace then verify that the sequence is a
key in the specified hash
.Sp
If it matches successfully, capture the sequence it matched and save
that substring in the current scope's result-hash, under the key
\&'IDENTIFIER'.
.ie n .IP """<%HASH>""" 4
.el .IP \f(CW<%HASH>\fR 4
.IX Item "<%HASH>"
Match a key from the hash.
Don't save the substring it matched.
.ie n .IP """<IDENTIFIER= (?{ CODE })>""" 4
.el .IP "\f(CW<IDENTIFIER= (?{ CODE })>\fR" 4
.IX Item "<IDENTIFIER= (?{ CODE })>"
Execute the specified CODE.
.Sp
Save the result (of the final expression that the CODE evaluates) in the
current scope's result-hash, under the key \f(CW\*(AqIDENTIFIER\*(Aq\fR.
.ie n .IP """<[IDENTIFIER]>""" 4
.el .IP \f(CW<[IDENTIFIER]>\fR 4
.IX Item "<[IDENTIFIER]>"
Call the subrule whose name is IDENTIFIER.
.Sp
If it matches successfully, append the hash it returns to a nested array
within the current scope's result-hash, under the key <'IDENTIFIER'>.
.ie n .IP """<[IDENTIFIER_1=IDENTIFIER_2]>""" 4
.el .IP \f(CW<[IDENTIFIER_1=IDENTIFIER_2]>\fR 4
.IX Item "<[IDENTIFIER_1=IDENTIFIER_2]>"
Call the subrule whose name is IDENTIFIER_1.
.Sp
If it matches successfully, append the hash it returns to a nested array
within the current scope's result-hash, under the key \f(CW\*(AqIDENTIFIER_2\*(Aq\fR.
.ie n .IP """<ANY_SUBRULE>+ % <ANY_OTHER_SUBRULE>""" 4
.el .IP "\f(CW<ANY_SUBRULE>+ % <ANY_OTHER_SUBRULE>\fR" 4
.IX Item "<ANY_SUBRULE>+ % <ANY_OTHER_SUBRULE>"
.PD 0
.ie n .IP """<ANY_SUBRULE>* % <ANY_OTHER_SUBRULE>""" 4
.el .IP "\f(CW<ANY_SUBRULE>* % <ANY_OTHER_SUBRULE>\fR" 4
.IX Item "<ANY_SUBRULE>* % <ANY_OTHER_SUBRULE>"
.ie n .IP """<ANY_SUBRULE>+ % (PATTERN)""" 4
.el .IP "\f(CW<ANY_SUBRULE>+ % (PATTERN)\fR" 4
.IX Item "<ANY_SUBRULE>+ % (PATTERN)"
.ie n .IP """<ANY_SUBRULE>* % (PATTERN)""" 4
.el .IP "\f(CW<ANY_SUBRULE>* % (PATTERN)\fR" 4
.IX Item "<ANY_SUBRULE>* % (PATTERN)"
.PD
Repeatedly call the first subrule.
Keep matching as long as the subrule matches, provided successive
matches are separated by matches of the second subrule or the pattern.
.Sp
In other words, match a list of ANY_SUBRULE's separated by
ANY_OTHER_SUBRULE's or PATTERN's.
.Sp
Note that, if a pattern is used to specify the separator, it must be
specified in some kind of matched parentheses. These may be capturing
[\f(CW\*(C`(...)\*(C'\fR], non-capturing [\f(CW\*(C`(?:...)\*(C'\fR], non-backtracking [\f(CW\*(C`(?>...)\*(C'\fR],
or any other construct enclosed by an opening and closing paren.
.ie n .IP """<ANY_SUBRULE>+ %% <ANY_OTHER_SUBRULE>""" 4
.el .IP "\f(CW<ANY_SUBRULE>+ %% <ANY_OTHER_SUBRULE>\fR" 4
.IX Item "<ANY_SUBRULE>+ %% <ANY_OTHER_SUBRULE>"
.PD 0
.ie n .IP """<ANY_SUBRULE>* %% <ANY_OTHER_SUBRULE>""" 4
.el .IP "\f(CW<ANY_SUBRULE>* %% <ANY_OTHER_SUBRULE>\fR" 4
.IX Item "<ANY_SUBRULE>* %% <ANY_OTHER_SUBRULE>"
.ie n .IP """<ANY_SUBRULE>+ %% (PATTERN)""" 4
.el .IP "\f(CW<ANY_SUBRULE>+ %% (PATTERN)\fR" 4
.IX Item "<ANY_SUBRULE>+ %% (PATTERN)"
.ie n .IP """<ANY_SUBRULE>* %% (PATTERN)""" 4
.el .IP "\f(CW<ANY_SUBRULE>* %% (PATTERN)\fR" 4
.IX Item "<ANY_SUBRULE>* %% (PATTERN)"
.PD
Repeatedly call the first subrule.
Keep matching as long as the subrule matches, provided successive
matches are separated by matches of the second subrule or the pattern.
.Sp
Also allow an optional final trailing instance of the second subrule
or pattern (this is where \f(CW\*(C`%%\*(C'\fR differs from \f(CW\*(C`%\*(C'\fR).
.Sp
In other words, match a list of ANY_SUBRULE's separated by
ANY_OTHER_SUBRULE's or PATTERN's, with a possible final separator.
.Sp
As for the single \f(CW\*(C`%\*(C'\fR operator, if a pattern is used to specify the
separator, it must be specified in some kind of matched parentheses.
These may be capturing [\f(CW\*(C`(...)\*(C'\fR], non-capturing [\f(CW\*(C`(?:...)\*(C'\fR],
non-backtracking [\f(CW\*(C`(?>...)\*(C'\fR], or any other construct enclosed by an
opening and closing paren.
.SS "Special variables within grammar actions"
.IX Subsection "Special variables within grammar actions"
.ie n .IP $CAPTURE 4
.el .IP \f(CW$CAPTURE\fR 4
.IX Item "$CAPTURE"
.PD 0
.ie n .IP $CONTEXT 4
.el .IP \f(CW$CONTEXT\fR 4
.IX Item "$CONTEXT"
.PD
These are both aliases for the built-in read-only \f(CW$^N\fR variable, which
always contains the substring matched by the nearest preceding \f(CW\*(C`(...)\*(C'\fR
capture. \f(CW$^N\fR still works perfectly well, but these are provided to
improve the readability of code blocks and error messages respectively.
.ie n .IP $INDEX 4
.el .IP \f(CW$INDEX\fR 4
.IX Item "$INDEX"
This variable contains the index at which the next match will be attempted
within the string being parsed. It is most commonly used in \f(CW\*(C`<error:...>\*(C'\fR
or \f(CW\*(C`<log:...>\*(C'\fR directives:
.Sp
.Vb 8
\&    <rule: ListElem>
\&        <log: (?{ "Trying words at index $INDEX" })>
\&        <MATCH=( \ew++ )>
\&      |
\&        <log: (?{ "Trying digits at index $INDEX" })>
\&        <MATCH=( \ed++ )>
\&      |
\&        <error: (?{ "Missing ListElem near index $INDEX" })>
.Ve
.ie n .IP %MATCH 4
.el .IP \f(CW%MATCH\fR 4
.IX Item "%MATCH"
This variable contains all the saved results of any subrules called from the
current rule. In other words, subrule calls like:
.Sp
.Vb 1
\&    <ListElem>  <Separator= (,)>
.Ve
.Sp
stores their respective match results in \f(CW$MATCH{\*(AqListElem\*(Aq}\fR and
\&\f(CW$MATCH{\*(AqSeparator\*(Aq}\fR.
.ie n .IP $MATCH 4
.el .IP \f(CW$MATCH\fR 4
.IX Item "$MATCH"
This variable is an alias for \f(CW$MATCH{"="}\fR. This is the \f(CW%MATCH\fR
entry for the special "override value". If this entry is defined, its
value overrides the usual "return \e%MATCH" semantics of a successful
rule.
.ie n .IP %ARG 4
.el .IP \f(CW%ARG\fR 4
.IX Item "%ARG"
This variable contains all the key/value pairs that were passed into
a particular subrule call.
.Sp
.Vb 1
\&    <Keyword>  <Command>  <Terminator(:Keyword)>
.Ve
.Sp
the \f(CW\*(C`Terminator\*(C'\fR rule could get access to the text matched by
\&\f(CW\*(C`<Keyword>\*(C'\fR like so:
.Sp
.Vb 2
\&    <token: Terminator>
\&        end_ (??{ $ARG{\*(AqKeyword\*(Aq} })
.Ve
.Sp
Note that to match against the calling subrules 'Keyword' value, it's
necessary to use either a deferred interpolation (\f(CW\*(C`(??{...})\*(C'\fR) or
a qualified matchref:
.Sp
.Vb 2
\&    <token: Terminator>
\&        end_ <\e:Keyword>
.Ve
.Sp
A common mistake is to attempt to directly interpolate the argument:
.Sp
.Vb 2
\&    <token: Terminator>
\&        end_ $ARG{\*(AqKeyword\*(Aq}
.Ve
.Sp
This evaluates \f(CW$ARG{\*(AqKeyword\*(Aq}\fR when the grammar is
compiled, rather than when the rule is matched.
.ie n .IP $_ 4
.el .IP \f(CW$_\fR 4
.IX Item "$_"
At the start of any code blocks inside any regex, the variable \f(CW$_\fR contains
the complete string being matched against. The current matching position
within that string is given by: \f(CWpos($_)\fR.
.ie n .IP $DEBUG 4
.el .IP \f(CW$DEBUG\fR 4
.IX Item "$DEBUG"
This variable stores the current debugging mode (which may be any of:
\&\f(CW\*(Aqoff\*(Aq\fR, \f(CW\*(Aqon\*(Aq\fR, \f(CW\*(Aqrun\*(Aq\fR, \f(CW\*(Aqcontinue\*(Aq\fR, \f(CW\*(Aqmatch\*(Aq\fR, \f(CW\*(Aqstep\*(Aq\fR, or
\&\f(CW\*(Aqtry\*(Aq\fR). It is set automatically by the \f(CW\*(C`<debug:...>\*(C'\fR command, but may
also be set manually in a code block (which can be useful for conditional
debugging). For example:
.Sp
.Vb 2
\&    <rule: ListElem>
\&        <Identifier>
\&
\&        # Conditionally debug if \*(Aqfoobar\*(Aq encountered...
\&        (?{ $DEBUG = $MATCH{Identifier} eq \*(Aqfoobar\*(Aq ? \*(Aqstep\*(Aq : \*(Aqoff\*(Aq })
\&
\&        <Modifier>?
.Ve
.Sp
See also: the \f(CW\*(C`<log: LOGFILE>\*(C'\fR and \f(CW\*(C`<debug: DEBUG_CMD>\*(C'\fR directives.
.SH "IMPORTANT CONSTRAINTS AND LIMITATIONS"
.IX Header "IMPORTANT CONSTRAINTS AND LIMITATIONS"
.IP \(bu 4
Prior to Perl 5.14, the Perl 5 regex engine as not reentrant. So any
attempt to perform a regex match inside a \f(CW\*(C`(?{ ... })\*(C'\fR or \f(CW\*(C`(??{
\&... })\*(C'\fR under Perl 5.12 or earlier will almost certainly lead to either
weird data corruption or a segfault.
.Sp
The same calamities can also occur in any constructor called by
\&\f(CW\*(C`<objrule:>\*(C'\fR. If the constructor invokes another regex in any
way, it will most likely fail catastrophically. In particular, this
means that Moose constructors will frequently crash and burn within
a Regex::Grammars grammar (for example, if the Moose-based class
declares an attribute type constraint such as 'Int', which Moose
checks using a regex).
.IP \(bu 4
The additional regex constructs this module provides are implemented by
rewriting regular expressions. This is a (safer) form of source
filtering, but still subject to all the same limitations and
fallibilities of any other macro-based solution.
.IP \(bu 4
In particular, rewriting the macros involves the insertion of (a lot of)
extra capturing parentheses. This means you can no longer assume that
particular capturing parens correspond to particular numeric variables:
i.e. to \f(CW$1\fR, \f(CW$2\fR, \f(CW$3\fR etc. If you want to capture directly use
Perl 5.10's named capture construct:
.Sp
.Vb 1
\&    (?<name> [^\eW\ed]\ew* )
.Ve
.Sp
Better still, capture the data in its correct hierarchical context
using the module's "named subpattern" construct:
.Sp
.Vb 1
\&    <name= ([^\eW\ed]\ew*) >
.Ve
.IP \(bu 4
No recursive descent parser\-\-including those created with
Regexp::Grammars\-\-can directly handle left-recursive grammars with rules
of the form:
.Sp
.Vb 2
\&    <rule: List>
\&        <List> , <ListElem>
.Ve
.Sp
If you find yourself attempting to write a left-recursive grammar (which
Perl 5.10 may or may not complain about, but will never successfully
parse with), then you probably need to use the "separated list"
construct instead:
.Sp
.Vb 2
\&    <rule: List>
\&        <[ListElem]>+ % (,)
.Ve
.IP \(bu 4
Grammatical parsing with Regexp::Grammars can fail if your grammar uses
"non-backtracking" directives (i.e. the \f(CW\*(C`(?>...)\*(C'\fR block or the
\&\f(CW\*(C`?+\*(C'\fR, \f(CW\*(C`*+\*(C'\fR, or \f(CW\*(C`++\*(C'\fR repetition specifiers). The problem appears to be
that preventing the regex from backtracking through the in-regex actions
that Regexp::Grammars adds causes the module's internal stack to fall
out of sync with the regex match.
.Sp
For the time being, if your grammar does not work as expected,
you may need to replace one or more "non-backtracking" directives,
with their regular (i.e. backtracking) equivalents.
.IP \(bu 4
Similarly, parsing with Regexp::Grammars will fail if your grammar
places a subrule call within a positive look-ahead, since
these don't play nicely with the data stack.
.Sp
This seems to be an internal problem with perl itself.
Investigations, and attempts at a workaround, are proceeding.
.Sp
For the time being, you need to make sure that grammar rules don't appear
inside a positive lookahead or use the
\&\f(CW\*(C`<?RULENAME>\*(C'\fR construct 
instead
.SH DIAGNOSTICS
.IX Header "DIAGNOSTICS"
Note that (because the author cannot find a way to throw exceptions from
within a regex) none of the following diagnostics actually throws an
exception.
.PP
Instead, these messages are simply written to the specified parser logfile
(or to \f(CW*STDERR\fR, if no logfile is specified).
.PP
However, any fatal match-time message will immediately terminate the
parser matching and will still set \f(CW$@\fR (as if an exception had been
thrown and caught at that point in the code). You then have the option
to check \f(CW$@\fR immediately after matching with the grammar, and rethrow if
necessary:
.PP
.Vb 6
\&    if ($input =~ $grammar) {
\&        process_data_in(\e%/);
\&    }
\&    else {
\&        die if $@;
\&    }
.Ve
.ie n .IP """Found call to %s, but no %s was defined in the grammar""" 4
.el .IP "\f(CWFound call to %s, but no %s was defined in the grammar\fR" 4
.IX Item "Found call to %s, but no %s was defined in the grammar"
You specified a call to a subrule for which there was no definition in
the grammar. Typically that's either because you forget to define the
rule, or because you misspelled either the definition or the subrule
call. For example:
.Sp
.Vb 1
\&    <file>
\&
\&    <rule: fiel>            <\-\-\-\- misspelled rule
\&        <lines>             <\-\-\-\- used but never defined
.Ve
.Sp
Regexp::Grammars converts any such subrule call attempt to an instant
catastrophic failure of the entire parse, so if your parser ever
actually tries to perform that call, Very Bad Things will happen.
.ie n .IP """Entire parse terminated prematurely while attempting to call non\-existent rule: %s""" 4
.el .IP "\f(CWEntire parse terminated prematurely while attempting to call non\-existent rule: %s\fR" 4
.IX Item "Entire parse terminated prematurely while attempting to call non-existent rule: %s"
You ignored the previous error and actually tried to call to a subrule
for which there was no definition in the grammar. Very Bad Things are
now happening. The parser got very upset, took its ball, and went home.
See the preceding diagnostic for remedies.
.Sp
This diagnostic should throw an exception, but can't. So it sets \f(CW$@\fR
instead, allowing you to trap the error manually if you wish.
.ie n .IP """Fatal error: <objrule: %s> returned a non\-hash\-based object""" 4
.el .IP "\f(CWFatal error: <objrule: %s> returned a non\-hash\-based object\fR" 4
.IX Item "Fatal error: <objrule: %s> returned a non-hash-based object"
An <objrule:> was specified and returned a blessed object that wasn't
a hash. This will break the behaviour of the grammar, so the module
immediately reports the problem and gives up.
.Sp
The solution is to use only hash-based classes with <objrule:>
.ie n .IP """Can\*(Aqt match against <grammar: %s>""" 4
.el .IP "\f(CWCan\*(Aqt match against <grammar: %s>\fR" 4
.IX Item "Cant match against <grammar: %s>"
The regex you attempted to match against defined a pure grammar, using
the \f(CW\*(C`<grammar:...>\*(C'\fR directive. Pure grammars have no start-pattern
and hence cannot be matched against directly.
.Sp
You need to define a matchable grammar that inherits from your pure
grammar and then calls one of its rules. For example, instead of:
.Sp
.Vb 2
\&    my $greeting = qr{
\&        <grammar: Greeting>
\&
\&        <rule: greet>
\&            Hi there
\&            | Hello
\&            | Yo!
\&    }xms;
.Ve
.Sp
you need:
.Sp
.Vb 2
\&    qr{
\&        <grammar: Greeting>
\&
\&        <rule: greet>
\&            Hi there
\&          | Hello
\&          | Yo!
\&    }xms;
\&
\&    my $greeting = qr{
\&        <extends: Greeting>
\&        <greet>
\&    }xms;
.Ve
.ie n .IP """Inheritance from unknown grammar requested by <%s>""" 4
.el .IP "\f(CWInheritance from unknown grammar requested by <%s>\fR" 4
.IX Item "Inheritance from unknown grammar requested by <%s>"
You used an \f(CW\*(C`<extends:...>\*(C'\fR directive to request that your
grammar inherit from another, but the grammar you asked to
inherit from doesn't exist.
.Sp
Check the spelling of the grammar name, and that it's already been
defined somewhere earlier in your program.
.ie n .IP """Redeclaration of <%s> will be ignored""" 4
.el .IP "\f(CWRedeclaration of <%s> will be ignored\fR" 4
.IX Item "Redeclaration of <%s> will be ignored"
You defined two or more rules or tokens with the same name.
The first one defined in the grammar will be used;
the rest will be ignored.
.Sp
To get rid of the warning, get rid of the extra definitions
(or, at least, comment them out or rename the rules).
.ie n .IP """Possible invalid subrule call %s""" 4
.el .IP "\f(CWPossible invalid subrule call %s\fR" 4
.IX Item "Possible invalid subrule call %s"
Your grammar contained something of the form:
.Sp
.Vb 3
\&    <identifier
\&    <.identifier
\&    <[identifier
.Ve
.Sp
which you might have intended to be a subrule call, but which didn't
correctly parse as one. If it was supposed to be a Regexp::Grammars
subrule call, you need to check the syntax you used. If it wasn't
supposed to be a subrule call, you can silence the warning by rewriting
it and quoting the leading angle:
.Sp
.Vb 3
\&    \e<identifier
\&    \e<.identifier
\&    \e<[identifier
.Ve
.ie n .IP """Possible failed attempt to specify a subrule call or directive: %s""" 4
.el .IP "\f(CWPossible failed attempt to specify a subrule call or directive: %s\fR" 4
.IX Item "Possible failed attempt to specify a subrule call or directive: %s"
Your grammar contained something of the form:
.Sp
.Vb 1
\&    <identifier...
.Ve
.Sp
but which wasn't a call to a known subrule or directive. If it was
supposed to be a subrule call, check the spelling of the rule name in
the angles. If it was supposed to be a Regexp::Grammars directive,
check the spelling of the directive name. If it wasn't supposed to be a
subrule call or directive, you can silence the warning by rewriting it
and quoting the leading angle:
.Sp
.Vb 1
\&    \e<identifier
.Ve
.ie n .IP """Invalid < metacharacter""" 4
.el .IP "\f(CWInvalid < metacharacter\fR" 4
.IX Item "Invalid < metacharacter"
The \f(CW\*(C`<\*(C'\fR character is always special in Regexp::Grammars regexes:
it either introduces a subrule call, or a rule/token declaration,
or a directive.
.Sp
If you need to match a literal \f(CW\*(Aq<\*(Aq\fR, use \f(CW\*(C`\e<\*(C'\fR in your regex.
.ie n .IP """Invalid separation specifier: %s""" 4
.el .IP "\f(CWInvalid separation specifier: %s\fR" 4
.IX Item "Invalid separation specifier: %s"
You used a \f(CW\*(C`%\*(C'\fR or a \f(CW\*(C`%%\*(C'\fR in the regex, but in a way that won't do what
you expect. \f(CW\*(C`%\*(C'\fR and \f(CW\*(C`%%\*(C'\fR are metacharacters in Regexp::Grammars
regexes, and can only be placed between a repeated atom (that matches a
list of items) and a simple atom (that matches the separator between
list items). See "Matching separated lists".
.Sp
If you were using \f(CW\*(C`%\*(C'\fR or \f(CW\*(C`%%\*(C'\fR as a metacharacter, then you either
forgot the repetition quantifier (\f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`{0,9}\*(C'\fR, etc.) on the
preceding list-matching atom, or you specified the following separator
atom as something too complex for the module to parse (for example,
a set of parens with nested subrule calls).
.Sp
On the other hand, if you were intending to match a literal \f(CW\*(C`%\*(C'\fR or \f(CW\*(C`%%\*(C'\fR
within a Regexp::Grammars regex, then you must explicitly specify it
as being a literal by quotemeta'ing it, like so: \f(CW\*(C`\e%\*(C'\fR or \f(CW\*(C`\e%\e%\*(C'\fR
.ie n .IP """Repeated subrule %s will only capture its final match""" 4
.el .IP "\f(CWRepeated subrule %s will only capture its final match\fR" 4
.IX Item "Repeated subrule %s will only capture its final match"
You specified a subrule call with a repetition qualifier, such as:
.Sp
.Vb 1
\&    <ListElem>*
.Ve
.Sp
or:
.Sp
.Vb 1
\&    <ListElem>+
.Ve
.Sp
Because each subrule call saves its result in a hash entry of the same name,
each repeated match will overwrite the previous ones, so only the last match
will ultimately be saved. If you want to save all the matches, you need to
tell Regexp::Grammars to save the sequence of results as a nested array within
the hash entry, like so:
.Sp
.Vb 1
\&    <[ListElem]>*
.Ve
.Sp
or:
.Sp
.Vb 1
\&    <[ListElem]>+
.Ve
.Sp
If you really did intend to throw away every result but the final one, you can
silence the warning by placing the subrule call inside any kind of
parentheses. For example:
.Sp
.Vb 1
\&    (<ListElem>)*
.Ve
.Sp
or:
.Sp
.Vb 1
\&    (?: <ListElem> )+
.Ve
.ie n .IP """Unable to open log file \*(Aq$filename\*(Aq (%s)""" 4
.el .IP "\f(CWUnable to open log file \*(Aq$filename\*(Aq (%s)\fR" 4
.IX Item "Unable to open log file $filename (%s)"
You specified a \f(CW\*(C`<logfile:...>\*(C'\fR directive but the
file whose name you specified could not be opened for
writing (for the reason given in the parens).
.Sp
Did you misspell the filename, or get the permissions wrong
somewhere in the filepath?
.ie n .IP """Non\-backtracking subrule %s may not revert correctly during backtracking""" 4
.el .IP "\f(CWNon\-backtracking subrule %s may not revert correctly during backtracking\fR" 4
.IX Item "Non-backtracking subrule %s may not revert correctly during backtracking"
Because of inherent limitations in the Perl regex engine,
non-backtracking constructs like \f(CW\*(C`++\*(C'\fR, \f(CW\*(C`*+\*(C'\fR, \f(CW\*(C`?+\*(C'\fR,
and \f(CW\*(C`(?>...)\*(C'\fR do not always work correctly when applied to
subrule calls, especially in earlier versions of Perl.
.Sp
If the grammar doesn't work properly, replace the offending constructs
with regular backtracking versions instead. If the grammar does work,
you can silence the warning by enclosing the subrule call in any
kind of parentheses. For example, change:
.Sp
.Vb 1
\&    <[ListElem]>++
.Ve
.Sp
to:
.Sp
.Vb 1
\&    (?: <[ListElem]> )++
.Ve
.ie n .IP """Unexpected item before first subrule specification in definition of <grammar: %s>""" 4
.el .IP "\f(CWUnexpected item before first subrule specification in definition of <grammar: %s>\fR" 4
.IX Item "Unexpected item before first subrule specification in definition of <grammar: %s>"
Named grammar definitions must consist only of rule and token definitions.
They cannot have patterns before the first definitions.
You had some kind of pattern before the first definition, which will be
completely ignored within the grammar.
.Sp
To silence the warning, either comment out or delete whatever is before
the first rule/token definition.
.ie n .IP """No main regex specified before rule definitions""" 4
.el .IP "\f(CWNo main regex specified before rule definitions\fR" 4
.IX Item "No main regex specified before rule definitions"
You specified an unnamed grammar (i.e. no \f(CW\*(C`<grammar:...>\*(C'\fR directive),
but didn't specify anything for it to actually match, just some rules
that you don't actually call. For example:
.Sp
.Vb 1
\&    my $grammar = qr{
\&
\&        <rule: list>    \e( <item> +% [,] \e)
\&
\&        <token: item>   <list> | \ed+
\&    }x;
.Ve
.Sp
You have to provide something before the first rule to start the matching
off. For example:
.Sp
.Vb 1
\&    my $grammar = qr{
\&
\&        <list>   # <\-\-\- This tells the grammar how to start matching
\&
\&        <rule: list>    \e( <item> +% [,] \e)
\&
\&        <token: item>   <list> | \ed+
\&    }x;
.Ve
.ie n .IP """Ignoring useless empty <ws:> directive""" 4
.el .IP "\f(CWIgnoring useless empty <ws:> directive\fR" 4
.IX Item "Ignoring useless empty <ws:> directive"
The \f(CW\*(C`<ws:...>\*(C'\fR directive specifies what whitespace matches within the
current rule. An empty \f(CW\*(C`<ws:>\*(C'\fR directive would cause whitespace
to match nothing at all, which is what happens in a token definition,
not in a rule definition.
.Sp
Either put some subpattern inside the empty \f(CW\*(C`<ws:...>\*(C'\fR or, if you
really do want whitespace to match nothing at all, remove the directive
completely and change the rule definition to a token definition.
.ie n .IP """Ignoring useless <ws: %s > directive in a token definition""" 4
.el .IP "\f(CWIgnoring useless <ws: %s > directive in a token definition\fR" 4
.IX Item "Ignoring useless <ws: %s > directive in a token definition"
The \f(CW\*(C`<ws:...>\*(C'\fR directive is used to specify what whitespace matches
within a rule. Since whitespace never matches anything inside tokens,
putting a \f(CW\*(C`<ws:...>\*(C'\fR directive in a token is a waste of time.
.Sp
Either remove the useless directive, or else change the surrounding
token definition to a rule definition.
.ie n .IP """Quantifier that doesn\*(Aqt quantify anything: <%s>""" 4
.el .IP "\f(CWQuantifier that doesn\*(Aqt quantify anything: <%s>\fR" 4
.IX Item "Quantifier that doesnt quantify anything: <%s>"
You specified a rule or token something like:
.Sp
.Vb 1
\&    <token: star>  *
.Ve
.Sp
or:
.Sp
.Vb 1
\&    <rule: add_op>  plus | add | +
.Ve
.Sp
but the \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR in those examples are both regex meta-operators:
quantifiers that usually cause what precedes them to match repeatedly.
In these cases however, nothing is preceding the quantifier, so it's a
Perl syntax error.
.Sp
You almost certainly need to escape the meta-characters in some way.
For example:
.Sp
.Vb 1
\&    <token: star>  \e*
\&
\&    <rule: add_op>  plus | add | [+]
.Ve
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Regexp::Grammars requires no configuration files or environment variables.
.SH DEPENDENCIES
.IX Header "DEPENDENCIES"
This module only works under Perl 5.10 or later.
.SH INCOMPATIBILITIES
.IX Header "INCOMPATIBILITIES"
This module is likely to be incompatible with any other module that
automagically rewrites regexes. For example it may conflict with
Regexp::DefaultFlags, Regexp::DeferredExecution, or Regexp::Extended.
.SH BUGS
.IX Header "BUGS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-regexp\-grammars@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH CONTRIBUTING
.IX Header "CONTRIBUTING"
Patches and other similar contributions are always welcome.
.PP
For more details on how best to contribute improvements to this module,
see <https://metacpan.org/dist/Regexp\-Grammars/contribute>
or the CONTRIBUTING file in the module's distribution.
.SH AUTHOR
.IX Header "AUTHOR"
Damian Conway  \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2009, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.
.PP
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.
