.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::Message::Head 3"
.TH Mail::Message::Head 3 2023-12-11 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Mail::Message::Head \- the header of one message
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Message::Head
\&   is a Mail::Reporter
\&
\& Mail::Message::Head is extended by
\&   Mail::Message::Head::Complete
\&   Mail::Message::Head::Delayed
\&   Mail::Message::Head::Subset
.Ve
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 7
\& my $head = Mail::Message::Head\->new;
\& $head\->add(\*(AqFrom: me@localhost\*(Aq);
\& $head\->add(From => \*(Aqme@localhost\*(Aq);
\& $head\->add(Mail::Message::Field\->new(From => \*(Aqme\*(Aq));
\& my $subject = $head\->get(\*(Aqsubject\*(Aq);
\& my @rec = $head\->get(\*(Aqreceived\*(Aq);
\& $head\->delete(\*(AqFrom\*(Aq);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Message::Head\*(C'\fR MIME headers are part of Mail::Message messages,
which are grouped in Mail::Box folders.
.PP
\&\fBATTENTION!!!\fR most functionality about e\-mail headers is described
in Mail::Message::Head::Complete, which is a matured header object.
Other kinds of headers will be translated to that type when time comes.
.PP
On this page, the general methods which are available on any header are
described.  Read about differences in the sub-class specific pages.
.PP
Extends "DESCRIPTION" in Mail::Reporter.
.SH OVERLOADED
.IX Header "OVERLOADED"
.IP "overload: \fB""""\fR" 4
.IX Item "overload: """""
(stringifaction) The header, when used as string, will format as if
\&\fBMail::Message::Head::Complete::string()\fR was called, so return a
nicely folder full header.  An exception is made for Carp, which will
get a simplified string to avoid unreadible messages from \f(CW\*(C`croak\*(C'\fR
and \f(CW\*(C`confess\*(C'\fR.
.Sp
example: using a header object as string
.Sp
.Vb 2
\& print $head;     # implicit stringification by print
\& $head\->print;    # the same
\&
\& print "$head";   # explicit stringication
.Ve
.IP "overload: \fBbool\fR" 4
.IX Item "overload: bool"
When the header does not contain any lines (which is illegal, according
to the RFCs), false is returned.  In all other cases, a true value is
produced.
.SH METHODS
.IX Header "METHODS"
Extends "METHODS" in Mail::Reporter.
.SS Constructors
.IX Subsection "Constructors"
Extends "Constructors" in Mail::Reporter.
.IP "Mail::Message::Head\->\fBbuild\fR( [PAIR|$field]\-LIST )" 4
.IX Item "Mail::Message::Head->build( [PAIR|$field]-LIST )"
A fast way to construct a header with many lines.
The PAIRs are \f(CW\*(C`(name, content)\*(C'\fR pairs of the header, but it is also possible
to pass Mail::Message::Field objects.   A
Mail::Message::Head::Complete header is created by simply calling
\&\fBMail::Message::Head::Complete::build()\fR, and then each field
is added.  Double field names are permitted.
.Sp
example:
.Sp
.Vb 1
\& my $subject = Mail::Message::Field\->new(Subject => \*(Aqxyz\*(Aq);
\&
\& my $head = Mail::Message::Head\->build
\&  ( From     => \*(Aqme@example.com\*(Aq
\&  , To       => \*(Aqyou@anywhere.aq\*(Aq
\&  , $subject
\&  , Received => \*(Aqone\*(Aq
\&  , Received => \*(Aqtwo\*(Aq
\&  );
\&
\& print ref $head;
\&  # \-\->  Mail::Message::Head::Complete
.Ve
.IP Mail::Message::Head\->\fBnew\fR(%options) 4
.IX Item "Mail::Message::Head->new(%options)"
Create a new message header object.  The object will store all the
fields of a header.  When you get information from the header, it
will be returned to you as Mail::Message::Field objects, although
the fields may be stored differently internally.
.Sp
If you try to instantiate a Mail::Message::Head, you will automatically
be upgraded to a Mail::Message::Head::Complete \-\-a full head.
.Sp
.Vb 6
\& \-Option    \-\-Defined in     \-\-Default
\&  field_type                   Mail::Message::Field::Fast
\&  log         Mail::Reporter   \*(AqWARNINGS\*(Aq
\&  message                      undef
\&  modified                     <false>
\&  trace       Mail::Reporter   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "field_type => CLASS" 2
.IX Item "field_type => CLASS"
The type of objects that all the fields will have.  This must be
an extension of Mail::Message::Field.
.IP "log => LEVEL" 2
.IX Item "log => LEVEL"
.PD 0
.IP "message => MESSAGE" 2
.IX Item "message => MESSAGE"
.PD
The MESSAGE where this header belongs to.  Usually, this is not known
at creation of the header, but sometimes it is.  If not, call the
\&\fBmessage()\fR method later to set it.
.IP "modified => BOOLEAN" 2
.IX Item "modified => BOOLEAN"
.PD 0
.IP "trace => LEVEL" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.PD
.SS "The header"
.IX Subsection "The header"
.ie n .IP $obj\->\fBisDelayed\fR() 4
.el .IP \f(CW$obj\fR\->\fBisDelayed\fR() 4
.IX Item "$obj->isDelayed()"
Headers may only be partially read, in which case they are called delayed.
This method returns true if some header information still needs to be
read. Returns false if all header data has been read.
Will never trigger completion.
.ie n .IP $obj\->\fBisEmpty\fR() 4
.el .IP \f(CW$obj\fR\->\fBisEmpty\fR() 4
.IX Item "$obj->isEmpty()"
Are there any fields defined in the current header?  Be warned that
the header will not be loaded for this: delayed headers will return
true in any case.
.ie n .IP $obj\->\fBisModified\fR() 4
.el .IP \f(CW$obj\fR\->\fBisModified\fR() 4
.IX Item "$obj->isModified()"
Returns whether the header has been modified after being read.
.Sp
example:
.Sp
.Vb 1
\& if($head\->isModified) { ... }
.Ve
.ie n .IP $obj\->\fBknownNames\fR() 4
.el .IP \f(CW$obj\fR\->\fBknownNames\fR() 4
.IX Item "$obj->knownNames()"
Like \fBMail::Message::Head::Complete::names()\fR, but only returns the known
header fields, which may be less than \f(CW\*(C`names\*(C'\fR for header types which are
partial.  \f(CWnames()\fR will trigger completion, where \f(CWknownNames()\fR does not.
.ie n .IP "$obj\->\fBmessage\fR( [$message] )" 4
.el .IP "\f(CW$obj\fR\->\fBmessage\fR( [$message] )" 4
.IX Item "$obj->message( [$message] )"
Get (after setting) the message where this header belongs to.
This does not trigger completion.
.ie n .IP "$obj\->\fBmodified\fR( [BOOLEAN] )" 4
.el .IP "\f(CW$obj\fR\->\fBmodified\fR( [BOOLEAN] )" 4
.IX Item "$obj->modified( [BOOLEAN] )"
Sets the modified flag to BOOLEAN.  Without value, the current setting is
returned, but in that case you can better use \fBisModified()\fR.
Changing this flag will not trigger header completion.
.Sp
example:
.Sp
.Vb 3
\& $head\->modified(1);
\& if($head\->modified) { ... }
\& if($head\->isModified) { ... }
.Ve
.ie n .IP $obj\->\fBorderedFields\fR() 4
.el .IP \f(CW$obj\fR\->\fBorderedFields\fR() 4
.IX Item "$obj->orderedFields()"
Returns the fields ordered the way they were read or added.
.SS "Access to the header"
.IX Subsection "Access to the header"
.ie n .IP "$obj\->\fBget\fR( $name, [$index] )" 4
.el .IP "\f(CW$obj\fR\->\fBget\fR( \f(CW$name\fR, [$index] )" 4
.IX Item "$obj->get( $name, [$index] )"
Get the data which is related to the field with the \f(CW$name\fR.  The case of the
characters in \f(CW$name\fR does not matter.
.Sp
If there is only one data element defined for the \f(CW$name\fR, or if there is an
\&\f(CW$index\fR specified as the second argument, only the specified element will be
returned. If the field \f(CW$name\fR matches more than one header the return value
depends on the context. In LIST context, all values will be returned in
the order they are read. In SCALAR context, only the last value will be
returned.
.Sp
example:
.Sp
.Vb 4
\& my $head = Mail::Message::Head\->new;
\& $head\->add(\*(AqReceived: abc\*(Aq);
\& $head\->add(\*(AqReceived: xyz\*(Aq);
\& $head\->add(\*(AqSubject: greetings\*(Aq);
\&
\& my @rec_list   = $head\->get(\*(AqReceived\*(Aq);
\& my $rec_scalar = $head\->get(\*(AqReceived\*(Aq);
\& print ",@rec_list,$rec_scalar,"     # ,abc xyz, xyz,
\& print $head\->get(\*(AqReceived\*(Aq, 0);    # abc
\& my @sub_list   = $head\->get(\*(AqSubject\*(Aq);
\& my $sub_scalar = $head\->get(\*(AqSubject\*(Aq);
\& print ",@sub_list,$sub_scalar,"     # ,greetings, greetings,
.Ve
.ie n .IP "$obj\->\fBstudy\fR( $name, [$index] )" 4
.el .IP "\f(CW$obj\fR\->\fBstudy\fR( \f(CW$name\fR, [$index] )" 4
.IX Item "$obj->study( $name, [$index] )"
Like \fBget()\fR, but puts more effort in understanding the contents of the
field.  \fBMail::Message::Field::study()\fR will be called for the field
with the specified FIELDNAME, which returns Mail::Message::Field::Full
objects. In scalar context only the last field with that name is returned.
When an \f(CW$index\fR is specified, that element is returned.
.SS "About the body"
.IX Subsection "About the body"
.ie n .IP $obj\->\fBguessBodySize\fR() 4
.el .IP \f(CW$obj\fR\->\fBguessBodySize\fR() 4
.IX Item "$obj->guessBodySize()"
Try to estimate the size of the body of this message, but without parsing
the header or body.  The result might be \f(CW\*(C`undef\*(C'\fR or a few percent of
the real size.  It may even be very far of the real value, that's why
this is a guess.
.ie n .IP $obj\->\fBisMultipart\fR() 4
.el .IP \f(CW$obj\fR\->\fBisMultipart\fR() 4
.IX Item "$obj->isMultipart()"
Returns whether the body of the related message is a multipart body.
May trigger completion, when the \f(CW\*(C`Content\-Type\*(C'\fR field is not defined.
.SS Internals
.IX Subsection "Internals"
.ie n .IP $obj\->\fBaddNoRealize\fR($field) 4
.el .IP \f(CW$obj\fR\->\fBaddNoRealize\fR($field) 4
.IX Item "$obj->addNoRealize($field)"
Add a field, like \fBMail::Message::Head::Complete::add()\fR does, but
avoid the loading of a possibly partial header.  This method does not
test the validity of the argument, nor flag the header as changed.
This does not trigger completion.
.ie n .IP $obj\->\fBaddOrderedFields\fR($fields) 4
.el .IP \f(CW$obj\fR\->\fBaddOrderedFields\fR($fields) 4
.IX Item "$obj->addOrderedFields($fields)"
.PD 0
.ie n .IP $obj\->\fBfileLocation\fR() 4
.el .IP \f(CW$obj\fR\->\fBfileLocation\fR() 4
.IX Item "$obj->fileLocation()"
.PD
Returns the location of the header in the file, as a pair begin and end.  The
begin is the first byte of the header.  The end is the first byte after
the header.
.ie n .IP $obj\->\fBload\fR() 4
.el .IP \f(CW$obj\fR\->\fBload\fR() 4
.IX Item "$obj->load()"
Be sure that the header is loaded.  This returns the loaded header
object.
.ie n .IP $obj\->\fBmoveLocation\fR($distance) 4
.el .IP \f(CW$obj\fR\->\fBmoveLocation\fR($distance) 4
.IX Item "$obj->moveLocation($distance)"
Move the registration of the header in the file.
.ie n .IP $obj\->\fBread\fR($parser) 4
.el .IP \f(CW$obj\fR\->\fBread\fR($parser) 4
.IX Item "$obj->read($parser)"
Read the header information of one message into this header structure.  This
method is called by the folder object (some Mail::Box sub-class), which
passes the \f(CW$parser\fR as an argument.
.ie n .IP $obj\->\fBsetNoRealize\fR($field) 4
.el .IP \f(CW$obj\fR\->\fBsetNoRealize\fR($field) 4
.IX Item "$obj->setNoRealize($field)"
Set a field, but avoid the loading of a possibly partial header as \fBset()\fR
does.  This method does not test the validity of the argument, nor flag the
header as changed.  This does not trigger completion.
.SS "Error handling"
.IX Subsection "Error handling"
Extends "Error handling" in Mail::Reporter.
.ie n .IP $obj\->\fBAUTOLOAD\fR() 4
.el .IP \f(CW$obj\fR\->\fBAUTOLOAD\fR() 4
.IX Item "$obj->AUTOLOAD()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBaddReport\fR($object) 4
.el .IP \f(CW$obj\fR\->\fBaddReport\fR($object) 4
.IX Item "$obj->addReport($object)"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "$obj->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD 0
.ie n .IP "Mail::Message::Head\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "Mail::Message::Head\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "Mail::Message::Head->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBerrors\fR() 4
.el .IP \f(CW$obj\fR\->\fBerrors\fR() 4
.IX Item "$obj->errors()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR( [$level, [$strings]] )" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "$obj->log( [$level, [$strings]] )"
.PD 0
.IP "Mail::Message::Head\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "Mail::Message::Head->log( [$level, [$strings]] )"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBlogPriority\fR($level) 4
.el .IP \f(CW$obj\fR\->\fBlogPriority\fR($level) 4
.IX Item "$obj->logPriority($level)"
.PD 0
.IP Mail::Message::Head\->\fBlogPriority\fR($level) 4
.IX Item "Mail::Message::Head->logPriority($level)"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBlogSettings\fR() 4
.el .IP \f(CW$obj\fR\->\fBlogSettings\fR() 4
.IX Item "$obj->logSettings()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBnotImplemented\fR() 4
.el .IP \f(CW$obj\fR\->\fBnotImplemented\fR() 4
.IX Item "$obj->notImplemented()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR( [$level] )" 4
.IX Item "$obj->report( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR( [$level] )" 4
.IX Item "$obj->reportAll( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR( [$level] )" 4
.IX Item "$obj->trace( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBwarnings\fR() 4
.el .IP \f(CW$obj\fR\->\fBwarnings\fR() 4
.IX Item "$obj->warnings()"
Inherited, see "Error handling" in Mail::Reporter
.SS Cleanup
.IX Subsection "Cleanup"
Extends "Cleanup" in Mail::Reporter.
.ie n .IP $obj\->\fBDESTROY\fR() 4
.el .IP \f(CW$obj\fR\->\fBDESTROY\fR() 4
.IX Item "$obj->DESTROY()"
Inherited, see "Cleanup" in Mail::Reporter
.SH DETAILS
.IX Header "DETAILS"
.SS "Ordered header fields"
.IX Subsection "Ordered header fields"
Many Perl implementations make a big mistake by disturbing the order
of header fields.  For some fields (especially the \fIresent groups\fR,
see Mail::Message::Head::ResentGroup) the order shall be
maintained.
.PP
MailBox will keep the order of the fields as they were found in the
source.  When your add a new field, it will be added at the end.  If
your replace a field with a new value, it will stay in the original
order.
.SS "Head class implementation"
.IX Subsection "Head class implementation"
The header of a MIME message object contains a set of lines, which are
called \fIfields\fR (by default represented by Mail::Message::Field
objects).  Dependent on the situation, the knowledge about the fields can
be in one of three situations, each represented by a sub-class of this
module:
.IP \(bu 4
Mail::Message::Head::Complete
.Sp
In this case, it is sure that all knowledge about the header is available.
When you \fBget()\fR information from the header and it is not there, it will
never be there.
.IP \(bu 4
Mail::Message::Head::Subset
.Sp
There is no certainty whether all header lines are known (probably not).  This
may be caused as result of reading a fast index file, as described in
Mail::Box::MH::Index.  The object is automatically transformed
into a Mail::Message::Head::Complete when all header lines must be known.
.IP \(bu 4
Mail::Message::Head::Partial
.Sp
A partial header is like a subset header: probably the header is incomplete.
The means that you are not sure whether a \fBget()\fR for a field fails because
the field is not a part of the message or that it fails because it is not
yet known to the program.  Where the subset header knows where to get the
other fields, the partial header does not know it.  It cannot hide its
imperfection.
.IP \(bu 4
Mail::Message::Head::Delayed
.Sp
In this case, there is no single field known.  Access to this header will
always trigger the loading of the full header.
.SS "Subsets of header fields"
.IX Subsection "Subsets of header fields"
Message headers can be quite large, and therefore MailBox provides
simplified access to some subsets of information.  You can grab these
sets of fields together, create and delete them as group.
.PP
On the moment, the following sets are defined:
.IP \(bu 4
Mail::Message::Head::ResentGroup
.Sp
A \fIresent group\fR is a set of fields which is used to log one step
in the transmission of the message from the original sender to the
destination.
.Sp
Each step adds a set of headers to indicate when the message was received
and how it was forwarded (without modification).  These fields are
best created using \fBMail::Message::bounce()\fR.
.IP \(bu 4
Mail::Message::Head::ListGroup
.Sp
Fields which are used to administer and log mailing list activity.  Mailing
list software has to play trics with the original message to be able to
get the reply on that message back to the mailing list.  Usually a large
number of lines are added.
.IP \(bu 4
Mail::Message::Head::SpamGroup
.Sp
A set of fields which contains header fields which are produced by
spam detection software.  You may want to remove these fields when
you store a message for a longer period of time.
.SH DIAGNOSTICS
.IX Header "DIAGNOSTICS"
.ie n .IP "Error: Package $package does not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR does not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package does not implement $method."
Fatal error: the specific package (or one of its superclasses) does not
implement this method where it should. This message means that some other
related classes do implement this method however the class at hand does
not.  Probably you should investigate this and probably inform the author
of the package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Message distribution version 3.015,
built on December 11, 2023. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH LICENSE
.IX Header "LICENSE"
Copyrights 2001\-2023 by [Mark Overmeer <markov@cpan.org>]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
