.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Convert::ASN1 3"
.TH Convert::ASN1 3 2023-08-07 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Convert::ASN1 \- ASN.1 Encode/Decode library
.SH VERSION
.IX Header "VERSION"
version 0.34
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use Convert::ASN1;
\&
\&  $asn = Convert::ASN1\->new;
\&  $asn\->prepare(q<
\&
\&    [APPLICATION 7] SEQUENCE {
\&      int INTEGER,
\&      str OCTET STRING
\&    }
\&
\&  >);
\&
\&  $pdu = $asn\->encode( int => 7, str => "string");
\&
\&  $out = $asn\->decode($pdu);
\&  print $out\->{int}," ",$out\->{str},"\en";
\&
\&  use Convert::ASN1 qw(:io);
\&
\&  $peer   = asn_recv($sock,$buffer,0);
\&  $nbytes = asn_read($fh, $buffer);
\&  $nbytes = asn_send($sock, $buffer, $peer);
\&  $nbytes = asn_send($sock, $buffer);
\&  $nbytes = asn_write($fh, $buffer);
\&  $buffer = asn_get($fh);
\&  $yes    = asn_ready($fh)
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Convert::ASN1 encodes and decodes ASN.1 data structures using BER/DER
rules.
.SH METHODS
.IX Header "METHODS"
.SS "new ( [OPTIONS] )"
.IX Subsection "new ( [OPTIONS] )"
Constructor, creates a new object.
.PP
If given, \fBOPTIONS\fR are the same ones as for "configure ( OPTIONS )" below.
.SS "error ()"
.IX Subsection "error ()"
Returns the last error.
.SS "configure ( OPTIONS )"
.IX Subsection "configure ( OPTIONS )"
Configure options to control how Convert::ASN1 will perform various tasks.
Options are passed as name-value pairs.
.IP encode 4
.IX Item "encode"
Reference to a hash which contains various encode options.
.IP decode 4
.IX Item "decode"
Reference to a hash which contains various decode options.
.IP encoding 4
.IX Item "encoding"
One of 'BER' or 'DER'. The default is 'BER'
.IP tagdefault 4
.IX Item "tagdefault"
One of 'EXPLICIT' or 'IMPLICIT'.
Default tagging conventions are normally given in the ASN.1 module definition (not supported by the parser). The ASN.1 spec states EXPLICIT tagging is the default, but this option has IMPLICIT tagging default for backward compatibility reasons.
.PP
Encode options
.IP real 4
.IX Item "real"
Which encoding to use for real's. One of 'binary', 'nr1', 'nr2', 'nr3'
.IP time 4
.IX Item "time"
This controls how UTCTime and GeneralizedTime elements are encoded. The default
is \f(CW\*(C`withzone\*(C'\fR.
.RS 4
.IP utctime 4
.IX Item "utctime"
The value passed will be encoded without a zone, ie a UTC value.
.IP withzone 4
.IX Item "withzone"
The value will be encoded with a zone. By default it will be encoded
using the local time offset. The offset may be set using the \f(CW\*(C`timezone\*(C'\fR
configure option.
.IP raw 4
.IX Item "raw"
The value passed should already be in the correct format and will be copied
into the PDU as-is.
.RE
.RS 4
.RE
.IP timezone 4
.IX Item "timezone"
By default UTCTime and GeneralizedTime will be encoded using the local
time offset from UTC. This will over-ride that. It is an offset from UTC
in seconds.  This option can be overridden by passing a reference to a
list of two values as the time value. The list should contain the time
value and the offset from UTC in seconds.
.IP bigint 4
.IX Item "bigint"
If during encoding an value greater than 32 bits is discovered and
is not already a big integer object, then the value will first be
converted into a big integer object. This option controls the big
integer class into which the objects will be blessed. The default
is to use Math::BigInt
.PP
Decode options
.IP time 4
.IX Item "time"
This controls how a UTCTime or a GeneralizedTime element will be decoded. The default
is \f(CW\*(C`utctime\*(C'\fR.
.RS 4
.IP utctime 4
.IX Item "utctime"
The value returned will be a time value as returned by the \f(CW\*(C`time\*(C'\fR function.
.IP withzone 4
.IX Item "withzone"
The value returned will be a reference to an array of two values. The first is the
same as with \f(CW\*(C`utctime\*(C'\fR, the second is the timezone offset, in seconds, that was
used in the encoding.
.IP raw 4
.IX Item "raw"
The value returned will be the raw encoding as extracted from the PDU.
.RE
.RS 4
.RE
.IP bigint 4
.IX Item "bigint"
If during decoding any big integers are discovered (integers greater
than 32 bits), they will be decoded into big integer objects. This option
controls the big integer class into which the objects will be blessed.
The default is to use Math::BigInt.
.IP null 4
.IX Item "null"
The value to decode ASN.1 NULL types into.
If not set, it defaults to \f(CW1\fR.
.SS "prepare ( ASN )"
.IX Subsection "prepare ( ASN )"
Compile the given ASN.1 description which can be passed as a string
or as a filehandle. The syntax used is very close to ASN.1, but has
a few differences. If the ASN describes only one macro then encode/decode can be
called on this object. If ASN describes more than one ASN.1 macro then \f(CW\*(C`find\*(C'\fR
must be called. The method returns undef on error.
.SS "prepare_file ( ASNPATH )"
.IX Subsection "prepare_file ( ASNPATH )"
Compile the ASN.1 description to be read from the specified pathname.
.SS "find ( MACRO )"
.IX Subsection "find ( MACRO )"
Find a macro from a prepared ASN.1 description. Returns an object which can
be used for encode/decode.
.SS "encode ( VARIABLES )"
.IX Subsection "encode ( VARIABLES )"
Encode a PDU. Top-level variable are passed as name-value pairs, or as a reference
to a hash containing them. Returns the encoded PDU, or undef on error.
.SS "decode ( PDU )"
.IX Subsection "decode ( PDU )"
Decode the PDU, returns a reference to a hash containing the values for the PDU. Returns
undef if there was an error.
.SS "registeroid ( OID, HANDLER )"
.IX Subsection "registeroid ( OID, HANDLER )"
Register a handler for all ASN.1 elements
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given OID.
.PP
\&\fBHANDLER\fR must be a Convert::ASN1 object, e.g. as returned by "find ( MACRO )".
.SS "registertype ( NAME, OID, HANDLER )"
.IX Subsection "registertype ( NAME, OID, HANDLER )"
Register a handler for all ASN.1 elements named \f(CW\*(C`NAME\*(C'\fR,
that are \f(CW\*(C`DEFINED BY\*(C'\fR the given OID.
.PP
\&\fBHANDLER\fR must be a Convert::ASN1 object, e.g. as returned by "find ( MACRO )".
.SH EXPORTS
.IX Header "EXPORTS"
As well as providing an object interface for encoding/decoding PDUs Convert::ASN1
also provides the following functions.
.SS "IO Functions"
.IX Subsection "IO Functions"
.IP "asn_recv ( SOCK, BUFFER, FLAGS )" 4
.IX Item "asn_recv ( SOCK, BUFFER, FLAGS )"
Will read a single element from the socket SOCK into BUFFER.  FLAGS may
be MSG_PEEK as exported by \f(CW\*(C`Socket\*(C'\fR. Returns the address of the sender,
or undef if there was an error. Some systems do not support the return
of the peer address when the socket is a connected socket, in these
cases the empty string will be returned. This is the same behaviour
as the \f(CW\*(C`recv\*(C'\fR function in perl itself.
.Sp
It is recommended that if the socket is of type SOCK_DGRAM then \f(CW\*(C`recv\*(C'\fR
be called directly instead of calling \f(CW\*(C`asn_recv\*(C'\fR.
.IP "asn_read ( FH, BUFFER, OFFSET )" 4
.IX Item "asn_read ( FH, BUFFER, OFFSET )"
.PD 0
.IP "asn_read ( FH, BUFFER )" 4
.IX Item "asn_read ( FH, BUFFER )"
.PD
Will read a single element from the filehandle FH into BUFFER. Returns the
number of bytes read if a complete element was read, \-1 if an incomplete
element was read or undef if there was an error. If OFFSET is specified
then it is assumed that BUFFER already contains an incomplete element
and new data will be appended starting at OFFSET.
.Sp
If FH is a socket the asn_recv is used to read the element, so the same
restriction applies if FH is a socket of type SOCK_DGRAM.
.IP "asn_send ( SOCK, BUFFER, FLAGS, TO )" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS, TO )"
.PD 0
.IP "asn_send ( SOCK, BUFFER, FLAGS )" 4
.IX Item "asn_send ( SOCK, BUFFER, FLAGS )"
.PD
Identical to calling \f(CW\*(C`send\*(C'\fR, see perlfunc
.IP "asn_write ( FH, BUFFER )" 4
.IX Item "asn_write ( FH, BUFFER )"
Identical to calling \f(CW\*(C`syswrite\*(C'\fR with 2 arguments, see perlfunc
.IP "asn_get ( FH )" 4
.IX Item "asn_get ( FH )"
\&\f(CW\*(C`asn_get\*(C'\fR provides buffered IO. Because it needs a buffer FH must be a GLOB
or a reference to a GLOB. \f(CW\*(C`asn_get\*(C'\fR will use two entries in the hash element
of the GLOB to use as its buffer:
.Sp
.Vb 2
\&  asn_buffer \- input buffer
\&  asn_need   \- number of bytes needed for the next element, if known
.Ve
.Sp
Returns an element or undef if there was an error.
.IP "asn_ready ( FH )" 4
.IX Item "asn_ready ( FH )"
\&\f(CW\*(C`asn_ready\*(C'\fR works with \f(CW\*(C`asn_get\*(C'\fR. It will return true if \f(CW\*(C`asn_get\*(C'\fR has already
read enough data into the buffer to return a complete element.
.SS "Encode/Decode Functions"
.IX Subsection "Encode/Decode Functions"
.IP "asn_tag ( CLASS, VALUE )" 4
.IX Item "asn_tag ( CLASS, VALUE )"
Given \fBCLASS\fR and a \fBVALUE\fR, calculate an integer which when encoded
will become the tag.
.IP "asn_decode_tag ( TAG )" 4
.IX Item "asn_decode_tag ( TAG )"
Decode the given ASN.1 encoded \f(CW\*(C`TAG\*(C'\fR.
.IP "asn_encode_tag ( TAG )" 4
.IX Item "asn_encode_tag ( TAG )"
Encode \fBTAG\fR value for encoding.
We assume that the tag has been correctly generated with "asn_tag ( CLASS, VALUE )".
.IP "asn_decode_length ( LEN )" 4
.IX Item "asn_decode_length ( LEN )"
Decode the given ASN.1 decoded \f(CW\*(C`LEN\*(C'\fR.
.IP "asn_encode_length ( LEN )" 4
.IX Item "asn_encode_length ( LEN )"
Encode the given \f(CW\*(C`LEN\*(C'\fR to its ASN.1 encoding.
.SS Constants
.IX Subsection "Constants"
.IP ASN_BIT_STR 4
.IX Item "ASN_BIT_STR"
.PD 0
.IP ASN_BOOLEAN 4
.IX Item "ASN_BOOLEAN"
.IP ASN_ENUMERATED 4
.IX Item "ASN_ENUMERATED"
.IP ASN_GENERAL_TIME 4
.IX Item "ASN_GENERAL_TIME"
.IP ASN_IA5_STR 4
.IX Item "ASN_IA5_STR"
.IP ASN_INTEGER 4
.IX Item "ASN_INTEGER"
.IP ASN_NULL 4
.IX Item "ASN_NULL"
.IP ASN_OBJECT_ID 4
.IX Item "ASN_OBJECT_ID"
.IP ASN_OCTET_STR 4
.IX Item "ASN_OCTET_STR"
.IP ASN_PRINT_STR 4
.IX Item "ASN_PRINT_STR"
.IP ASN_REAL 4
.IX Item "ASN_REAL"
.IP ASN_SEQUENCE 4
.IX Item "ASN_SEQUENCE"
.IP ASN_SET 4
.IX Item "ASN_SET"
.IP ASN_UTC_TIME 4
.IX Item "ASN_UTC_TIME"
.IP ASN_APPLICATION 4
.IX Item "ASN_APPLICATION"
.IP ASN_CONTEXT 4
.IX Item "ASN_CONTEXT"
.IP ASN_PRIVATE 4
.IX Item "ASN_PRIVATE"
.IP ASN_UNIVERSAL 4
.IX Item "ASN_UNIVERSAL"
.IP ASN_PRIMITIVE 4
.IX Item "ASN_PRIMITIVE"
.IP ASN_CONSTRUCTOR 4
.IX Item "ASN_CONSTRUCTOR"
.IP ASN_LONG_LEN 4
.IX Item "ASN_LONG_LEN"
.IP ASN_EXTENSION_ID 4
.IX Item "ASN_EXTENSION_ID"
.IP ASN_BIT 4
.IX Item "ASN_BIT"
.PD
.SS "Debug Functions"
.IX Subsection "Debug Functions"
.IP "asn_dump ( [FH,] BUFFER )" 4
.IX Item "asn_dump ( [FH,] BUFFER )"
Try to decode the given buffer as ASN.1 structure and dump it to the
given file handle, or \f(CW\*(C`STDERR\*(C'\fR if the handle is not given.
.IP "asn_hexdump ( FH, BUFFER )" 4
.IX Item "asn_hexdump ( FH, BUFFER )"
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
.PD 0
.IP :all 4
.IX Item ":all"
.PD
All exported functions
.IP :const 4
.IX Item ":const"
ASN_BOOLEAN,     ASN_INTEGER,      ASN_BIT_STR,      ASN_OCTET_STR,
ASN_NULL,        ASN_OBJECT_ID,    ASN_REAL,         ASN_ENUMERATED,
ASN_SEQUENCE,    ASN_SET,          ASN_PRINT_STR,    ASN_IA5_STR,
ASN_UTC_TIME,    ASN_GENERAL_TIME,
ASN_UNIVERSAL,   ASN_APPLICATION,  ASN_CONTEXT,      ASN_PRIVATE,
ASN_PRIMITIVE,   ASN_CONSTRUCTOR,  ASN_LONG_LEN,     ASN_EXTENSION_ID, ASN_BIT
.IP :debug 4
.IX Item ":debug"
asn_dump, asn_hexdump
.IP :io 4
.IX Item ":io"
asn_recv, asn_send, asn_read, asn_write, asn_get, asn_ready
.IP :tag 4
.IX Item ":tag"
asn_tag, asn_decode_tag, asn_encode_tag, asn_decode_length, asn_encode_length
.SH "MAPPING ASN.1 TO PERL"
.IX Header "MAPPING ASN.1 TO PERL"
Every element in the ASN.1 definition has a name, in perl a hash is used
with these names as an index and the element value as the hash value.
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => "text" }
.Ve
.PP
In the case of a SEQUENCE, SET or CHOICE then the value in the namespace will
be a hash reference which will be the namespace for the elements with
that element.
.PP
.Vb 6
\&  # ASN.1
\&  int INTEGER,
\&  seq SEQUENCE {
\&    str OCTET STRING,
\&    bool BOOLEAN
\&  }
\&
\&  # Perl
\&  { int => 5, seq => { str => "text", bool => 1}}
.Ve
.PP
If the element is a SEQUENCE OF, or SET OF, then the value in the namespace
will be an array reference. The elements in the array will be of
the type expected by the type following the OF. For example
with "SEQUENCE OF STRING" the array would contain strings. With
"SEQUENCE OF SEQUENCE { ... }" the array will contain hash references
which will be used as namespaces
.PP
.Vb 3
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF OCTET STRING
\&
\&  # Perl
\&  { int => 5, str => [ "text1", "text2"]}
\&
\&  # ASN.1
\&  int INTEGER,
\&  str SEQUENCE OF SEQUENCE {
\&    type OCTET STRING,
\&    value INTEGER
\&  }
\&
\&  # Perl
\&  { int => 5, str => [
\&    { type => "abc", value => 4 },
\&    { type => "def", value => \-1 },
\&  ]}
.Ve
.PP
Finally, if you wish to pre-parse ASN.1 and hold it to include
inline in your PDU, you can coerce it into the ASN.1 spec by
defining the value as ANY in the schema, and then pass the pre
encoded value inline.
.PP
.Vb 4
\&  # ASN.1
\&  int INTEGER,
\&  str OCTET STRING,
\&  pre ANY
\&
\&  # Perl
\&  { int => 5, str => "text", pre=>"\ex03\ex03\ex00\ex0a\ex05" }
.Ve
.PP
passes a pre-encoded BIT STRING instance as hex text. \-But
it could be a previous run of \f(CW$obj\fR\->\fBencode()\fR from another run
held in some variable.
.SS Exceptions
.IX Subsection "Exceptions"
There are some exceptions where Convert::ASN1 does not require an element to be named.
These are SEQUENCE {...}, SET {...} and CHOICE. In each case if the element is not
given a name then the elements inside the {...} will share the same namespace as
the elements outside of the {...}.
.SH TODO
.IX Header "TODO"
.IP \(bu 4
XS implementation.
.IP \(bu 4
More documentation.
.IP \(bu 4
More tests.
.SH AUTHOR
.IX Header "AUTHOR"
Graham Barr <gbarr@cpan.org>
.SH SUPPORT
.IX Header "SUPPORT"
Report issues via github at https://github.com/gbarr/perl\-Convert\-ASN1/issues
.PP
To contribute I encourage you to create a git fork of the repository at
https://github.com/gbarr/perl\-Convert\-ASN1 do you work on a fresh branch
created from master and submit a pull request
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2012 Graham Barr <gbarr@cpan.org>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
