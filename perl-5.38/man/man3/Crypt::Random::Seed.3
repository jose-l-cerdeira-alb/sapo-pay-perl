.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::Random::Seed 3"
.TH Crypt::Random::Seed 3 2013-02-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Crypt::Random::Seed \- Simple method to get strong randomness
.SH VERSION
.IX Header "VERSION"
Version 0.03
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use Crypt::Random::Seed;
\&
\&  my $source = new Crypt::Random::Seed;
\&  die "No strong sources exist" unless defined $source;
\&  my $seed_string = $source\->random_bytes(4);
\&  my @seed_values = $source\->random_values(4);
\&
\&  # Only non\-blocking sources
\&  my $nonblocking_source = Crypt::Random::Seed\->new( NonBlocking=>1 );
\&
\&  # Blacklist sources (never choose the listed sources)
\&  my $nowin32_source = Crypt::Random::Seed\->new( Never=>[\*(AqWin32\*(Aq] );
\&
\&  # Whitelist sources (only choose from these sources)
\&  my $devr_source = Crypt::Random::Seed\->new( Only=>[\*(AqTESHA2\*(Aq] );
\&
\&  # Supply a custom source.
\&  my $user_src = Crypt::Random::Seed\->new( Source=>sub { myfunc(shift) } );
\&  # Or supply a list of [name, sub, is_blocking, is_strong]
\&  $user_src = Crypt::Random::Seed\->new(
\&     Source=>[\*(AqMyRandomFunction\*(Aq,sub {myfunc(shift)},0,1] );
\&
\&  # Given a source there are a few things we can do:
\&  say "My randomness source is ", $source\->name();
\&  say "I am a blocking source" if $source\->is_blocking();
\&  say "I am a strong randomness source" if $source\->is_strong()
\&  say "Four 8\-bit numbers:",
\&      join(",", map { ord $source\->random_bytes(1) } 1..4);\*(Aq
\&  say "Four 32\-bit numbers:", join(",", $source\->random_values(4));
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
A simple mechanism to get strong randomness.  The main purpose of this
module is to provide a simple way to generate a seed for a PRNG such as
Math::Random::ISAAC, for use in cryptographic key generation, or as the
seed for an upstream module such as Bytes::Random::Secure.  Flags for
requiring non-blocking sources are allowed, as well as a very simple
method for plugging in a source.
.PP
The randomness sources used are, in order:
.IP "User supplied." 4
.IX Item "User supplied."
If the constructor is called with a Source defined, then it is used.  It
is not checked vs. other flags (NonBlocking, Never, Only).
.IP "Win32 Crypto API." 4
.IX Item "Win32 Crypto API."
This will use \f(CW\*(C`CryptGenRandom\*(C'\fR on Windows 2000 and \f(CW\*(C`RtlGenRand\*(C'\fR on
Windows XP and newer.  According to MSDN, these are well-seeded CSPRNGs
(FIPS 186\-2 or AES-CTR), so will be non-blocking.
.IP "EGD / PRNGD." 4
.IX Item "EGD / PRNGD."
This looks for sockets that speak the EGD <http://egd.sourceforge.net/>
protocol, including PRNGD <http://prngd.sourceforge.net/>.  These are
userspace entropy daemons that are commonly used by OpenSSL, OpenSSH, and
GnuGP.  The locations searched are \f(CW\*(C`/var/run/egd\-pool\*(C'\fR, \f(CW\*(C`/dev/egd\-pool\*(C'\fR,
\&\f(CW\*(C`/etc/egd\-pool\*(C'\fR, and \f(CW\*(C`/etc/entropy\*(C'\fR.  EGD is blocking, while PRNGD is
non-blocking (like the Win32 API, it is really a seeded CSPRNG).  However
there is no way to tell them apart, so we treat it as blocking.  If your
O/S supports /dev/random, consider HAVEGED <http://www.issihosts.com/haveged/>
as an alternative (a system daemon that refills /dev/random as needed).
.IP /dev/random. 4
.IX Item "/dev/random."
The strong source of randomness on most UNIX-like systems.  Cygwin uses
this, though it maps to the Win32 API.  On almost all systems this is a
blocking source of randomness \-\- if it runs out of estimated entropy, it
will hang until more has come into the system.  If this is an issue,
which it often is on embedded devices, running a tool such as
HAVEGED <http://www.issihosts.com/haveged/> will help immensely.
.IP /dev/urandom. 4
.IX Item "/dev/urandom."
A nonblocking source of randomness that we label as weak, since it will
continue providing output even if the actual entropy has been exhausted.
.IP TESHA2. 4
.IX Item "TESHA2."
Crypt::Random::TESHA2 is a Perl module that generates random bytes from
an entropy pool fed with timer/scheduler variations.  Measurements and
tests are performed on installation to determine whether the source is
considered strong or weak.  This is entirely in portable userspace,
which is good for ease of use, but really requires user verification
that it is working as expected if we expect it to be strong.  The
concept is similar to Math::TrulyRandom though updated to something
closer to what TrueRand 2.1 does vs. the obsolete version 1 that
Math::TrulyRandom implements.  It is very slow and has wide speed
variability across platforms : I've seen numbers ranging from 40 to
150,000 bits per second.
.PP
A source can also be supplied in the constructor.  Each of these sources will
have its debatable points about perceived strength.  E.g. Why is /dev/urandom
considered weak while Win32 is strong?  Can any userspace method such as
TrueRand or TESHA2 be considered strong?
.SS "SOURCE TABLE"
.IX Subsection "SOURCE TABLE"
This table summarizes the default sources:
.PP
.Vb 10
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  |      SOURCE      |  STRENGTH   |  BLOCKING  |       NOTE         |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | RtlGenRandom     |   Strong(1) |     No     | Default WinXP+     |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | CryptGenRandom   |   Strong(1) |     No     | Default Win2000    |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | EGD              |   Strong    |    Yes(2)  | also PRNGD, etc.   |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | /dev/random      |   Strong    |    Yes     | Typical UNIX       |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | /dev/urandom     |    Weak     |     No     | Typical UNIX NB    |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | TESHA2\-strong    |   Strong    |     No     |                    |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | TESHA2\-weak      |    Weak     |     No     |                    |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
The alias 'Win32' can be used in whitelist and blacklist and will match both
the Win32 sources \f(CW\*(C`RtlGenRandom\*(C'\fR and \f(CW\*(C`CryptGenRandom\*(C'\fR.  The alias 'TESHA2'
may be similarly used and matches both the weak and strong sources.
.PP
.Vb 4
\&  1) Both CryptGenRandom and RtlGenRandom are considered strong by this
\&     package, even though both are seeded CSPRNGs so should be the equal of
\&     /dev/urandom in this respect.  The CryptGenRandom function used in
\&     Windows 2000 has some known issues so should be considered weaker.
\&
\&  2) EGD is blocking, PRNGD is not.  We cannot tell the two apart.  There are
\&     other software products that use the same protocol, and each will act
\&     differently.  E.g. EGD mixes in system entropy on every request, while
\&     PRNGD mixes on a time schedule.
.Ve
.SS STRENGTH
.IX Subsection "STRENGTH"
In theory, a strong generator will provide true entropy.  Even if a third
party knew a previous result and the entire state of the generator at any
time up to when their value was returned, they could still not effectively
predict the result of the next returned value.  This implies the generator
must either be blocking to wait for entropy (e.g. /dev/random) or go through
some possibly time-consuming process to gather it (TESHA2, EGD, the HAVEGE
daemon refilling /dev/random).  Note: strong in this context means practically
strong, as most computers don't have a true hardware entropy generator.  The
goal is to make all the attackers ill-gotten knowledge give them no better
solution than if they did not have the information.
.PP
Creating a satisfactory strength measurement is problematic.  The Win32
Crypto API is considered "strong" by most customers and every other Perl
module, however it is a well seeded CSPRNG according to the MSDN docs,
so is not a strong source based on the definition in the previous paragraph.
Similarly, almost all sources consider /dev/urandom to be weak, as once it
runs out of entropy it returns a deterministic function based on its state
(albeit one that cannot be run either direction from a returned result if the
internal state is not known).
.PP
Because of this confusion, I have removed the \f(CW\*(C`Weak\*(C'\fR configuration option
that was present in version 0.01.  It will now be ignored.  You should be
able to use a combination of whitelist, blacklist, and the source's
\&\f(CW\*(C`is_strong\*(C'\fR return value to decide if this meets your needs.  On Win32, you
really only have a choice of Win32 and TESHA2.  The former is going to be
what most people want, and can be chosen even with non-blocking set.  On most
UNIX systems, \f(CW\*(C`/dev/random\*(C'\fR will be chosen for blocking and \f(CW\*(C`/dev/urandom\*(C'\fR
for non-blocking, which is what should be done in most cases.
.SS BLOCKING
.IX Subsection "BLOCKING"
EGD and /dev/random are blocking sources.  This means that if they run out of
estimated entropy, they will pause until they've collected more.  This means
your program also pauses.  On typical workstations this may be a few seconds
or even minutes.  On an isolated network server this may cause a delay of
hours or days.  EGD is proactive about gathering more entropy as fast as it
can.  Running a tool such as the HAVEGE daemon or timer_entropyd can make
/dev/random act like a non-blocking source, as the entropy daemon will wake
up and refill the pool almost instantly.
.PP
Win32, PRNGD, and /dev/urandom are fast nonblocking sources.  When they run
out of entropy, they use a CSPRNG to keep supplying data at high speed.
However this means that there is no additional entropy being supplied.
.PP
TESHA2 is nonblocking, but can be very slow.  /dev/random can be faster if run
on a machine with lots of activity.  On an isolated server, TESHA2 may be
much faster.  Also note that the blocking sources such as EGD and /dev/random
both try to maintain reasonably large entropy pools, so small requests can be
supplied without blocking.
.SS "IN PRACTICE"
.IX Subsection "IN PRACTICE"
Use the default to get the best source known.  If you know more about the
sources available, you can use a whitelist, blacklist, or a custom source.
In general, to get the best source (typically Win32 or /dev/random):
.PP
.Vb 1
\&  my $source = Crypt::Random::Seed\->new();
.Ve
.PP
To get a good non-blocking source (Win32 or /dev/urandom):
.PP
.Vb 1
\&  my $source = Crypt::Random::Seed\->new(NonBlocking => 1);
.Ve
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
The constructor with no arguments will find the first available source in its
fixed list and return an object that performs the defined methods.  If no
sources could be found (quite unusual) then the returned value will be undef.
.PP
Optional parameters are passed in as a hash and may be mixed.
.PP
\fINonBlocking => boolean\fR
.IX Subsection "NonBlocking => boolean"
.PP
Only non-blocking sources will be allowed.  In practice this means EGD
and /dev/random will not be chosen (except on FreeBSD where it is
non-blocking).
.PP
\fIOnly => [list of strings]\fR
.IX Subsection "Only => [list of strings]"
.PP
Takes an array reference containing one or more string source names.  No
source whose name does not match one of these strings will be chosen.  The
string 'Win32' will match either of the Win32 sources, and 'TESHA2' will match
both the strong and weak versions.
.PP
\fINever => [list of strings]\fR
.IX Subsection "Never => [list of strings]"
.PP
Takes an array reference containing one or more string source names.  No
source whose name matches one of these strings will be chosen.  The string
\&'Win32' will match either of the Win32 sources, and 'TESHA2' will match both
the strong and weak versions.
.PP
\fISource => sub { ... }\fR
.IX Subsection "Source => sub { ... }"
.PP
Uses the given anonymous subroutine as the generator.  The subroutine will
be given an integer (the argument to \f(CW\*(C`random_bytes\*(C'\fR) and should return
random data in a string of the given length.  For the purposes of the other
object methods, the returned object will have the name 'User', and be
considered non-blocking and non-strong.
.PP
\fISource => ['name', sub { ... }, is_blocking, is_strong]\fR
.IX Subsection "Source => ['name', sub { ... }, is_blocking, is_strong]"
.PP
Similar to the simpler source routine, but also allows the other source
parameters to be defined.  The name may not be one of the standard names
listed in the "name" section.
.SS random_bytes($n)
.IX Subsection "random_bytes($n)"
Takes an integer and returns a string of that size filled with random data.
Returns an empty string if the argument is not defined or is not more than
zero.
.SS random_values($n)
.IX Subsection "random_values($n)"
Takes an integer and returns an array of that many random 32\-bit values.
Returns an empty array if the argument is not defined or is not more than
zero.
.SS name
.IX Subsection "name"
Returns the text name of the random source.  This will be one of:
\&\f(CW\*(C`User\*(C'\fR for user defined,
\&\f(CW\*(C`CryptGenRandom\*(C'\fR for Windows 2000 Crypto API,
\&\f(CW\*(C`RtlGenRand\*(C'\fR for Windows XP and newer Crypto API,
\&\f(CW\*(C`EGD\*(C'\fR for a known socket speaking the EGD protocol,
\&\f(CW\*(C`/dev/random\*(C'\fR for the UNIX-like strong randomness source,
\&\f(CW\*(C`/dev/urandom\*(C'\fR for the UNIX-like non-blocking randomness source,
\&\f(CW\*(C`TESHA2\-strong\*(C'\fR for the userspace entropy method when considered strong,
\&\f(CW\*(C`TESHA2\-weak\*(C'\fR for the userspace entropy method when considered weak.
Other methods may be supported in the future.  User supplied sources may be
named anything other than one of the defined names.
.SS is_strong
.IX Subsection "is_strong"
Returns 1 or 0 indicating whether the source is considered a strong source
of randomness.  See the "STRENGTH" section for more discussion of what
this means, and the source table for what we think of each
source.
.SS is_blocking
.IX Subsection "is_blocking"
Returns 1 or 0 indicating whether the source can block on read.  Be aware
that even if a source doesn't block, it may be extremely slow.
.SH AUTHORS
.IX Header "AUTHORS"
Dana Jacobsen <dana@acm.org>
.SH ACKNOWLEDGEMENTS
.IX Header "ACKNOWLEDGEMENTS"
To the best of my knowledge, Max Kanat-Alexander was the original author of
the Perl code that uses the Win32 API.  I used his code as a reference.
.PP
David Oswald gave me a lot of help with API discussions and code reviews.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The first question one may ask is "Why yet another module of this type?"
None of the modules on CPAN quite fit my needs, hence this.  Some alternatives:
.SS Crypt::Random::Source
.IX Subsection "Crypt::Random::Source"
A comprehensive system using multiple plugins.  It has a nice API, but
uses Any::Moose which means you're loading up Moose or Mouse just to
read a few bytes from /dev/random.  It also has a very long dependency chain,
with on the order of 40 modules being installed as prerequisites (depending
of course on whether you use any of them on other projects).  Lastly, it
requires at least Perl 5.8, which may or may not matter to you.  But it
matters to some other module builders who end up with the restriction in
their modules.
.SS Crypt::URandom
.IX Subsection "Crypt::URandom"
A great little module that is almost what I was looking for.
Crypt::Random::Seed will act the same if given the constructor:
.PP
.Vb 5
\&  my $source = Crypt::Random::Seed\->new(
\&     NonBlocking => 1,
\&     Only => [qw(/dev/random /dev/urandom Win32)]
\&  );
\&  croak "No randomness source available" unless defined $source;
.Ve
.PP
Or you can leave out the \f(CW\*(C`Only\*(C'\fR and have TESHA2 as a backup.
.SS Crypt::Random
.IX Subsection "Crypt::Random"
Requires Math::Pari which makes it unacceptable in some environments.
Has more features (numbers in arbitrary bigint intervals or bit sizes).
Crypt::Random::Seed is taking a simpler approach, just handling returning
octets and letting upstream modules handle the rest.
.SS Data::Entropy
.IX Subsection "Data::Entropy"
An interesting module that contains a source encapsulation (defaults to system
rand, but has many plugins), a good CSPRNG (AES in counter mode), and the
Data::Entropy::Algorithms module with many ways to get bits, ints, bigints,
floats, bigfloats, shuffles, and so forth.  From my perspective, the
algorithms module is the highlight, with a lot of interesting code.
.SS "Upstream modules"
.IX Subsection "Upstream modules"
Some modules that could use this module to help them:
Bytes::Random::Secure,
Math::Random::ISAAC,
Math::Random::Secure,
and Math::Random::MT
to name a few.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2013 by Dana Jacobsen <dana@acm.org>
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
The software is provided "AS IS", without warranty of any kind, express or
implied, including but not limited to the warranties of merchantability,
fitness for a particular purpose and noninfringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other
liability, whether in an action of contract, tort or otherwise, arising from,
out of or in connection with the software or the use or other dealings in
the software.
