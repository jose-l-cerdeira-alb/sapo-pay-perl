.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mojo::DOM58 3"
.TH Mojo::DOM58 3 2021-06-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Mojo::DOM58 \- Minimalistic HTML/XML DOM parser with CSS selectors
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use Mojo::DOM58;
\&
\&  # Parse
\&  my $dom = Mojo::DOM58\->new(\*(Aq<div><p id="a">Test</p><p id="b">123</p></div>\*(Aq);
\&
\&  # Find
\&  say $dom\->at(\*(Aq#b\*(Aq)\->text;
\&  say $dom\->find(\*(Aqp\*(Aq)\->map(\*(Aqtext\*(Aq)\->join("\en");
\&  say $dom\->find(\*(Aq[id]\*(Aq)\->map(attr => \*(Aqid\*(Aq)\->join("\en");
\&
\&  # Iterate
\&  $dom\->find(\*(Aqp[id]\*(Aq)\->reverse\->each(sub { say $_\->{id} });
\&
\&  # Loop
\&  for my $e ($dom\->find(\*(Aqp[id]\*(Aq)\->each) {
\&    say $e\->{id}, \*(Aq:\*(Aq, $e\->text;
\&  }
\&
\&  # Modify
\&  $dom\->find(\*(Aqdiv p\*(Aq)\->last\->append(\*(Aq<p id="c">456</p>\*(Aq);
\&  $dom\->at(\*(Aq#c\*(Aq)\->prepend($dom\->new_tag(\*(Aqp\*(Aq, id => \*(Aqd\*(Aq, \*(Aq789\*(Aq));
\&  $dom\->find(\*(Aq:not(p)\*(Aq)\->map(\*(Aqstrip\*(Aq);
\&
\&  # Render
\&  say "$dom";
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Mojo::DOM58 is a minimalistic and relaxed pure-perl HTML/XML DOM parser based
on Mojo::DOM. It supports the HTML Living Standard <https://html.spec.whatwg.org/>
and Extensible Markup Language (XML) 1.0 <https://www.w3.org/TR/xml/>, and
matching based on CSS3 selectors <https://www.w3.org/TR/selectors/>. It will
even try to interpret broken HTML and XML, so you should not use it for
validation.
.SH "FORK INFO"
.IX Header "FORK INFO"
Mojo::DOM58 is a fork of Mojo::DOM and tracks features and fixes to stay
closely compatible with upstream. It differs only in the standalone format and
compatibility with Perl 5.8. Any bugs or patches not related to these changes
should be reported directly to the Mojolicious issue tracker.
.PP
This release of Mojo::DOM58 is up to date with version \f(CW9.0\fR of
Mojolicious.
.SH "NODES AND ELEMENTS"
.IX Header "NODES AND ELEMENTS"
When we parse an HTML/XML fragment, it gets turned into a tree of nodes.
.PP
.Vb 5
\&  <!DOCTYPE html>
\&  <html>
\&    <head><title>Hello</title></head>
\&    <body>World!</body>
\&  </html>
.Ve
.PP
There are currently eight different kinds of nodes, \f(CW\*(C`cdata\*(C'\fR, \f(CW\*(C`comment\*(C'\fR,
\&\f(CW\*(C`doctype\*(C'\fR, \f(CW\*(C`pi\*(C'\fR, \f(CW\*(C`raw\*(C'\fR, \f(CW\*(C`root\*(C'\fR, \f(CW\*(C`tag\*(C'\fR and \f(CW\*(C`text\*(C'\fR. Elements are nodes of
the type \f(CW\*(C`tag\*(C'\fR.
.PP
.Vb 8
\&  root
\&  |\- doctype (html)
\&  +\- tag (html)
\&     |\- tag (head)
\&     |  +\- tag (title)
\&     |     +\- raw (Hello)
\&     +\- tag (body)
\&        +\- text (World!)
.Ve
.PP
While all node types are represented as Mojo::DOM58 objects, some methods like
"attr" and "namespace" only apply to elements.
.SH CASE-SENSITIVITY
.IX Header "CASE-SENSITIVITY"
Mojo::DOM58 defaults to HTML semantics, that means all tags and attribute
names are lowercased and selectors need to be lowercase as well.
.PP
.Vb 3
\&  # HTML semantics
\&  my $dom = Mojo::DOM58\->new(\*(Aq<P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(Aqp[id]\*(Aq)\->text;
.Ve
.PP
If an XML declaration is found, the parser will automatically switch into XML
mode and everything becomes case-sensitive.
.PP
.Vb 3
\&  # XML semantics
\&  my $dom = Mojo::DOM58\->new(\*(Aq<?xml version="1.0"?><P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(AqP[ID]\*(Aq)\->text;
.Ve
.PP
HTML or XML semantics can also be forced with the "xml" method.
.PP
.Vb 3
\&  # Force HTML semantics
\&  my $dom = Mojo::DOM58\->new\->xml(0)\->parse(\*(Aq<P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(Aqp[id]\*(Aq)\->text;
\&
\&  # Force XML semantics
\&  my $dom = Mojo::DOM58\->new\->xml(1)\->parse(\*(Aq<P ID="greeting">Hi!</P>\*(Aq);
\&  say $dom\->at(\*(AqP[ID]\*(Aq)\->text;
.Ve
.SH SELECTORS
.IX Header "SELECTORS"
Mojo::DOM58 uses a CSS selector engine based on Mojo::DOM::CSS. All CSS
selectors that make sense for a standalone parser are supported.
.IP * 4
Any element.
.Sp
.Vb 1
\&  my $all = $dom\->find(\*(Aq*\*(Aq);
.Ve
.IP E 4
.IX Item "E"
An element of type \f(CW\*(C`E\*(C'\fR.
.Sp
.Vb 1
\&  my $title = $dom\->at(\*(Aqtitle\*(Aq);
.Ve
.IP E[foo] 4
.IX Item "E[foo]"
An \f(CW\*(C`E\*(C'\fR element with a \f(CW\*(C`foo\*(C'\fR attribute.
.Sp
.Vb 1
\&  my $links = $dom\->find(\*(Aqa[href]\*(Aq);
.Ve
.IP "E[foo=""bar""]" 4
.IX Item "E[foo=""bar""]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute value is exactly equal to \f(CW\*(C`bar\*(C'\fR.
.Sp
.Vb 2
\&  my $case_sensitive = $dom\->find(\*(Aqinput[type="hidden"]\*(Aq);
\&  my $case_sensitive = $dom\->find(\*(Aqinput[type=hidden]\*(Aq);
.Ve
.IP "E[foo=""bar"" i]" 4
.IX Item "E[foo=""bar"" i]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute value is exactly equal to any
(ASCII-range) case-permutation of \f(CW\*(C`bar\*(C'\fR. Note that this selector is
\&\fBEXPERIMENTAL\fR and might change without warning!
.Sp
.Vb 3
\&  my $case_insensitive = $dom\->find(\*(Aqinput[type="hidden" i]\*(Aq);
\&  my $case_insensitive = $dom\->find(\*(Aqinput[type=hidden i]\*(Aq);
\&  my $case_insensitive = $dom\->find(\*(Aqinput[class~="foo" i]\*(Aq);
.Ve
.Sp
This selector is part of
Selectors Level 4 <https://dev.w3.org/csswg/selectors-4>, which is still a work
in progress.
.IP "E[foo=""bar"" s]" 4
.IX Item "E[foo=""bar"" s]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute value is exactly and case-sensitively
equal to \f(CW\*(C`bar\*(C'\fR. Note that this selector is \fBEXPERIMENTAL\fR and might change
without warning!
.Sp
.Vb 1
\&  my $case_sensitive = $dom\->find(\*(Aqinput[type="hidden" s]\*(Aq);
.Ve
.Sp
This selector is part of
Selectors Level 4 <https://dev.w3.org/csswg/selectors-4>, which is still a work
in progress.
.IP "E[foo~=""bar""]" 4
.IX Item "E[foo~=""bar""]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute value is a list of whitespace-separated
values, one of which is exactly equal to \f(CW\*(C`bar\*(C'\fR.
.Sp
.Vb 2
\&  my $foo = $dom\->find(\*(Aqinput[class~="foo"]\*(Aq);
\&  my $foo = $dom\->find(\*(Aqinput[class~=foo]\*(Aq);
.Ve
.IP "E[foo^=""bar""]" 4
.IX Item "E[foo^=""bar""]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute value begins exactly with the string
\&\f(CW\*(C`bar\*(C'\fR.
.Sp
.Vb 2
\&  my $begins_with = $dom\->find(\*(Aqinput[name^="f"]\*(Aq);
\&  my $begins_with = $dom\->find(\*(Aqinput[name^=f]\*(Aq);
.Ve
.IP "E[foo$=""bar""]" 4
.IX Item "E[foo$=""bar""]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute value ends exactly with the string
\&\f(CW\*(C`bar\*(C'\fR.
.Sp
.Vb 2
\&  my $ends_with = $dom\->find(\*(Aqinput[name$="o"]\*(Aq);
\&  my $ends_with = $dom\->find(\*(Aqinput[name$=o]\*(Aq);
.Ve
.IP "E[foo*=""bar""]" 4
.IX Item "E[foo*=""bar""]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute value contains the substring \f(CW\*(C`bar\*(C'\fR.
.Sp
.Vb 2
\&  my $contains = $dom\->find(\*(Aqinput[name*="fo"]\*(Aq);
\&  my $contains = $dom\->find(\*(Aqinput[name*=fo]\*(Aq);
.Ve
.IP "E[foo|=""en""]" 4
.IX Item "E[foo|=""en""]"
An \f(CW\*(C`E\*(C'\fR element whose \f(CW\*(C`foo\*(C'\fR attribute has a hyphen-separated list of values
beginning (from the left) with \f(CW\*(C`en\*(C'\fR.
.Sp
.Vb 1
\&  my $english = $dom\->find(\*(Aqlink[hreflang|=en]\*(Aq);
.Ve
.IP E:root 4
.IX Item "E:root"
An \f(CW\*(C`E\*(C'\fR element, root of the document.
.Sp
.Vb 1
\&  my $root = $dom\->at(\*(Aq:root\*(Aq);
.Ve
.IP E:nth\-child(n) 4
.IX Item "E:nth-child(n)"
An \f(CW\*(C`E\*(C'\fR element, the \f(CW\*(C`n\-th\*(C'\fR child of its parent.
.Sp
.Vb 4
\&  my $third = $dom\->find(\*(Aqdiv:nth\-child(3)\*(Aq);
\&  my $odd   = $dom\->find(\*(Aqdiv:nth\-child(odd)\*(Aq);
\&  my $even  = $dom\->find(\*(Aqdiv:nth\-child(even)\*(Aq);
\&  my $top3  = $dom\->find(\*(Aqdiv:nth\-child(\-n+3)\*(Aq);
.Ve
.IP E:nth\-last\-child(n) 4
.IX Item "E:nth-last-child(n)"
An \f(CW\*(C`E\*(C'\fR element, the \f(CW\*(C`n\-th\*(C'\fR child of its parent, counting from the last one.
.Sp
.Vb 4
\&  my $third    = $dom\->find(\*(Aqdiv:nth\-last\-child(3)\*(Aq);
\&  my $odd      = $dom\->find(\*(Aqdiv:nth\-last\-child(odd)\*(Aq);
\&  my $even     = $dom\->find(\*(Aqdiv:nth\-last\-child(even)\*(Aq);
\&  my $bottom3  = $dom\->find(\*(Aqdiv:nth\-last\-child(\-n+3)\*(Aq);
.Ve
.IP E:nth\-of\-type(n) 4
.IX Item "E:nth-of-type(n)"
An \f(CW\*(C`E\*(C'\fR element, the \f(CW\*(C`n\-th\*(C'\fR sibling of its type.
.Sp
.Vb 4
\&  my $third = $dom\->find(\*(Aqdiv:nth\-of\-type(3)\*(Aq);
\&  my $odd   = $dom\->find(\*(Aqdiv:nth\-of\-type(odd)\*(Aq);
\&  my $even  = $dom\->find(\*(Aqdiv:nth\-of\-type(even)\*(Aq);
\&  my $top3  = $dom\->find(\*(Aqdiv:nth\-of\-type(\-n+3)\*(Aq);
.Ve
.IP E:nth\-last\-of\-type(n) 4
.IX Item "E:nth-last-of-type(n)"
An \f(CW\*(C`E\*(C'\fR element, the \f(CW\*(C`n\-th\*(C'\fR sibling of its type, counting from the last one.
.Sp
.Vb 4
\&  my $third    = $dom\->find(\*(Aqdiv:nth\-last\-of\-type(3)\*(Aq);
\&  my $odd      = $dom\->find(\*(Aqdiv:nth\-last\-of\-type(odd)\*(Aq);
\&  my $even     = $dom\->find(\*(Aqdiv:nth\-last\-of\-type(even)\*(Aq);
\&  my $bottom3  = $dom\->find(\*(Aqdiv:nth\-last\-of\-type(\-n+3)\*(Aq);
.Ve
.IP E:first\-child 4
.IX Item "E:first-child"
An \f(CW\*(C`E\*(C'\fR element, first child of its parent.
.Sp
.Vb 1
\&  my $first = $dom\->find(\*(Aqdiv p:first\-child\*(Aq);
.Ve
.IP E:last\-child 4
.IX Item "E:last-child"
An \f(CW\*(C`E\*(C'\fR element, last child of its parent.
.Sp
.Vb 1
\&  my $last = $dom\->find(\*(Aqdiv p:last\-child\*(Aq);
.Ve
.IP E:first\-of\-type 4
.IX Item "E:first-of-type"
An \f(CW\*(C`E\*(C'\fR element, first sibling of its type.
.Sp
.Vb 1
\&  my $first = $dom\->find(\*(Aqdiv p:first\-of\-type\*(Aq);
.Ve
.IP E:last\-of\-type 4
.IX Item "E:last-of-type"
An \f(CW\*(C`E\*(C'\fR element, last sibling of its type.
.Sp
.Vb 1
\&  my $last = $dom\->find(\*(Aqdiv p:last\-of\-type\*(Aq);
.Ve
.IP E:only\-child 4
.IX Item "E:only-child"
An \f(CW\*(C`E\*(C'\fR element, only child of its parent.
.Sp
.Vb 1
\&  my $lonely = $dom\->find(\*(Aqdiv p:only\-child\*(Aq);
.Ve
.IP E:only\-of\-type 4
.IX Item "E:only-of-type"
An \f(CW\*(C`E\*(C'\fR element, only sibling of its type.
.Sp
.Vb 1
\&  my $lonely = $dom\->find(\*(Aqdiv p:only\-of\-type\*(Aq);
.Ve
.IP E:empty 4
.IX Item "E:empty"
An \f(CW\*(C`E\*(C'\fR element that has no children (including text nodes).
.Sp
.Vb 1
\&  my $empty = $dom\->find(\*(Aq:empty\*(Aq);
.Ve
.IP E:any\-link 4
.IX Item "E:any-link"
Alias for "E:link". Note that this selector is \fBEXPERIMENTAL\fR and might
change without warning! This selector is part of
Selectors Level 4 <https://dev.w3.org/csswg/selectors-4>, which is still a
work in progress.
.IP E:link 4
.IX Item "E:link"
An \f(CW\*(C`E\*(C'\fR element being the source anchor of a hyperlink of which the target is
not yet visited (\f(CW\*(C`:link\*(C'\fR) or already visited (\f(CW\*(C`:visited\*(C'\fR). Note that
Mojo::DOM58 is not stateful, therefore \f(CW\*(C`:any\-link\*(C'\fR, \f(CW\*(C`:link\*(C'\fR and
\&\f(CW\*(C`:visited\*(C'\fR yield exactly the same results.
.Sp
.Vb 3
\&  my $links = $dom\->find(\*(Aq:any\-link\*(Aq);
\&  my $links = $dom\->find(\*(Aq:link\*(Aq);
\&  my $links = $dom\->find(\*(Aq:visited\*(Aq);
.Ve
.IP E:visited 4
.IX Item "E:visited"
Alias for "E:link".
.IP E:scope 4
.IX Item "E:scope"
An \f(CW\*(C`E\*(C'\fR element being a designated reference element. Note that this selector is \fBEXPERIMENTAL\fR and might change
without warning!
.Sp
.Vb 3
\&  my $scoped = $dom\->find(\*(Aqa:not(:scope > a)\*(Aq);
\&  my $scoped = $dom\->find(\*(Aqdiv :scope p\*(Aq);
\&  my $scoped = $dom\->find(\*(Aq~ p\*(Aq);
.Ve
.Sp
This selector is part of Selectors Level 4 <https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.
.IP E:checked 4
.IX Item "E:checked"
A user interface element \f(CW\*(C`E\*(C'\fR which is checked (for instance a radio-button or
checkbox).
.Sp
.Vb 1
\&  my $input = $dom\->find(\*(Aq:checked\*(Aq);
.Ve
.IP E.warning 4
.IX Item "E.warning"
An \f(CW\*(C`E\*(C'\fR element whose class is "warning".
.Sp
.Vb 1
\&  my $warning = $dom\->find(\*(Aqdiv.warning\*(Aq);
.Ve
.IP E#myid 4
.IX Item "E#myid"
An \f(CW\*(C`E\*(C'\fR element with \f(CW\*(C`ID\*(C'\fR equal to "myid".
.Sp
.Vb 1
\&  my $foo = $dom\->at(\*(Aqdiv#foo\*(Aq);
.Ve
.IP "E:not(s1, s2)" 4
.IX Item "E:not(s1, s2)"
An \f(CW\*(C`E\*(C'\fR element that does not match either compound selector \f(CW\*(C`s1\*(C'\fR or compound
selector \f(CW\*(C`s2\*(C'\fR. Note that support for compound selectors is \fBEXPERIMENTAL\fR and
might change without warning!
.Sp
.Vb 1
\&  my $others = $dom\->find(\*(Aqdiv p:not(:first\-child, :last\-child)\*(Aq);
.Ve
.Sp
Support for compound selectors was added as part of
Selectors Level 4 <https://dev.w3.org/csswg/selectors-4>, which is still a work
in progress.
.IP "E:is(s1, s2)" 4
.IX Item "E:is(s1, s2)"
An \f(CW\*(C`E\*(C'\fR element that matches compound selector \f(CW\*(C`s1\*(C'\fR and/or compound selector
\&\f(CW\*(C`s2\*(C'\fR. Note that this selector is \fBEXPERIMENTAL\fR and might change without warning!
.Sp
.Vb 1
\&  my $headers = $dom\->find(\*(Aq:is(section, article, aside, nav) h1\*(Aq);
.Ve
.Sp
This selector is part of
Selectors Level 4 <https://dev.w3.org/csswg/selectors-4>, which is still a work
in progress.
.IP "E:has(rs1, rs2)" 4
.IX Item "E:has(rs1, rs2)"
An \f(CW\*(C`E\*(C'\fR element, if either of the relative selectors \f(CW\*(C`rs1\*(C'\fR or \f(CW\*(C`rs2\*(C'\fR, when evaluated with \f(CW\*(C`E\*(C'\fR as the :scope elements,
match an element. Note that this selector is \fBEXPERIMENTAL\fR and might change without warning!
.Sp
.Vb 1
\&  my $link = $dom\->find(\*(Aqa:has(> img)\*(Aq);
.Ve
.Sp
This selector is part of Selectors Level 4 <https://dev.w3.org/csswg/selectors-4>, which is still a work in progress.
Also be aware that this feature is currently marked \f(CW\*(C`at\-risk\*(C'\fR, so there is a high chance that it will get removed
completely.
.IP A|E 4
.IX Item "A|E"
An \f(CW\*(C`E\*(C'\fR element that belongs to the namespace alias \f(CW\*(C`A\*(C'\fR from
CSS Namespaces Module Level 3 <https://www.w3.org/TR/css-namespaces-3/>.
Key/value pairs passed to selector methods are used to declare namespace
aliases.
.Sp
.Vb 1
\&  my $elem = $dom\->find(\*(Aqlq|elem\*(Aq, lq => \*(Aqhttp://example.com/q\-markup\*(Aq);
.Ve
.Sp
Using an empty alias searches for an element that belongs to no namespace.
.Sp
.Vb 1
\&  my $div = $dom\->find(\*(Aq|div\*(Aq);
.Ve
.IP "E F" 4
.IX Item "E F"
An \f(CW\*(C`F\*(C'\fR element descendant of an \f(CW\*(C`E\*(C'\fR element.
.Sp
.Vb 1
\&  my $headlines = $dom\->find(\*(Aqdiv h1\*(Aq);
.Ve
.IP "E > F" 4
.IX Item "E > F"
An \f(CW\*(C`F\*(C'\fR element child of an \f(CW\*(C`E\*(C'\fR element.
.Sp
.Vb 1
\&  my $headlines = $dom\->find(\*(Aqhtml > body > div > h1\*(Aq);
.Ve
.IP "E + F" 4
.IX Item "E + F"
An \f(CW\*(C`F\*(C'\fR element immediately preceded by an \f(CW\*(C`E\*(C'\fR element.
.Sp
.Vb 1
\&  my $second = $dom\->find(\*(Aqh1 + h2\*(Aq);
.Ve
.IP "E ~ F" 4
.IX Item "E ~ F"
An \f(CW\*(C`F\*(C'\fR element preceded by an \f(CW\*(C`E\*(C'\fR element.
.Sp
.Vb 1
\&  my $second = $dom\->find(\*(Aqh1 ~ h2\*(Aq);
.Ve
.IP "E, F, G" 4
.IX Item "E, F, G"
Elements of type \f(CW\*(C`E\*(C'\fR, \f(CW\*(C`F\*(C'\fR and \f(CW\*(C`G\*(C'\fR.
.Sp
.Vb 1
\&  my $headlines = $dom\->find(\*(Aqh1, h2, h3\*(Aq);
.Ve
.IP E[foo=bar][bar=baz] 4
.IX Item "E[foo=bar][bar=baz]"
An \f(CW\*(C`E\*(C'\fR element whose attributes match all following attribute selectors.
.Sp
.Vb 1
\&  my $links = $dom\->find(\*(Aqa[foo^=b][foo$=ar]\*(Aq);
.Ve
.SH OPERATORS
.IX Header "OPERATORS"
Mojo::DOM58 overloads the following operators.
.SS array
.IX Subsection "array"
.Vb 1
\&  my @nodes = @$dom;
.Ve
.PP
Alias for "child_nodes".
.PP
.Vb 2
\&  # "<!\-\- Test \-\->"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><b>123</b>\*(Aq)\->[0];
.Ve
.SS bool
.IX Subsection "bool"
.Vb 1
\&  my $bool = !!$dom;
.Ve
.PP
Always true.
.SS hash
.IX Subsection "hash"
.Vb 1
\&  my %attrs = %$dom;
.Ve
.PP
Alias for "attr".
.PP
.Vb 2
\&  # "test"
\&  $dom\->parse(\*(Aq<div id="test">Test</div>\*(Aq)\->at(\*(Aqdiv\*(Aq)\->{id};
.Ve
.SS stringify
.IX Subsection "stringify"
.Vb 1
\&  my $str = "$dom";
.Ve
.PP
Alias for "to_string".
.SH FUNCTIONS
.IX Header "FUNCTIONS"
Mojo::DOM58 implements the following functions, which can be imported
individually.
.SS tag_to_html
.IX Subsection "tag_to_html"
.Vb 1
\&  my $str = tag_to_html \*(Aqdiv\*(Aq, id => \*(Aqfoo\*(Aq, \*(Aqsafe content\*(Aq;
.Ve
.PP
Generate HTML/XML tag and render it right away. This is a significantly faster
alternative to "new_tag" for template systems that have to generate a lot
of tags.
.SH METHODS
.IX Header "METHODS"
Mojo::DOM58 implements the following methods.
.SS new
.IX Subsection "new"
.Vb 2
\&  my $dom = Mojo::DOM58\->new;
\&  my $dom = Mojo::DOM58\->new(\*(Aq<foo bar="baz">I ♥ Mojo::DOM58!</foo>\*(Aq);
.Ve
.PP
Construct a new scalar-based Mojo::DOM58 object and "parse" HTML/XML
fragment if necessary.
.SS new_tag
.IX Subsection "new_tag"
.Vb 7
\&  my $tag = Mojo::DOM58\->new_tag(\*(Aqdiv\*(Aq);
\&  my $tag = $dom\->new_tag(\*(Aqdiv\*(Aq);
\&  my $tag = $dom\->new_tag(\*(Aqdiv\*(Aq, id => \*(Aqfoo\*(Aq, hidden => undef);
\&  my $tag = $dom\->new_tag(\*(Aqdiv\*(Aq, \*(Aqsafe content\*(Aq);
\&  my $tag = $dom\->new_tag(\*(Aqdiv\*(Aq, id => \*(Aqfoo\*(Aq, \*(Aqsafe content\*(Aq);
\&  my $tag = $dom\->new_tag(\*(Aqdiv\*(Aq, data => {mojo => \*(Aqrocks\*(Aq}, \*(Aqsafe content\*(Aq);
\&  my $tag = $dom\->new_tag(\*(Aqdiv\*(Aq, id => \*(Aqfoo\*(Aq, sub { \*(Aqunsafe content\*(Aq });
.Ve
.PP
Construct a new Mojo::DOM58 object for an HTML/XML tag with or without
attributes and content. The \f(CW\*(C`data\*(C'\fR attribute may contain a hash reference with
key/value pairs to generate attributes from.
.PP
.Vb 2
\&  # "<br>"
\&  $dom\->new_tag(\*(Aqbr\*(Aq);
\&
\&  # "<div></div>"
\&  $dom\->new_tag(\*(Aqdiv\*(Aq);
\&
\&  # "<div id="foo" hidden></div>"
\&  $dom\->new_tag(\*(Aqdiv\*(Aq, id => \*(Aqfoo\*(Aq, hidden => undef);
\&
\&  # "<div>test &amp; 123</div>"
\&  $dom\->new_tag(\*(Aqdiv\*(Aq, \*(Aqtest & 123\*(Aq);
\&
\&  # "<div id="foo">test &amp; 123</div>"
\&  $dom\->new_tag(\*(Aqdiv\*(Aq, id => \*(Aqfoo\*(Aq, \*(Aqtest & 123\*(Aq);
\&
\&  # "<div data\-foo="1" data\-bar="test">test &amp; 123</div>""
\&  $dom\->new_tag(\*(Aqdiv\*(Aq, data => {foo => 1, Bar => \*(Aqtest\*(Aq}, \*(Aqtest & 123\*(Aq);
\&
\&  # "<div id="foo">test & 123</div>"
\&  $dom\->new_tag(\*(Aqdiv\*(Aq, id => \*(Aqfoo\*(Aq, sub { \*(Aqtest & 123\*(Aq });
\&
\&  # "<div>Hello<b>Mojo!</b></div>"
\&  $dom\->parse(\*(Aq<div>Hello</div>\*(Aq)\->at(\*(Aqdiv\*(Aq)
\&    \->append_content($dom\->new_tag(\*(Aqb\*(Aq, \*(AqMojo!\*(Aq))\->root;
.Ve
.SS all_text
.IX Subsection "all_text"
.Vb 1
\&  my $text = $dom\->all_text;
.Ve
.PP
Extract text content from all descendant nodes of this element. For HTML documents \f(CW\*(C`script\*(C'\fR and \f(CW\*(C`style\*(C'\fR elements are
excluded.
.PP
.Vb 2
\&  # "foo\enbarbaz\en"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->at(\*(Aqdiv\*(Aq)\->all_text;
.Ve
.SS ancestors
.IX Subsection "ancestors"
.Vb 2
\&  my $collection = $dom\->ancestors;
\&  my $collection = $dom\->ancestors(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all ancestor elements of this node matching the CSS selector and return a
collection containing these elements as Mojo::DOM58
objects. All selectors listed in "SELECTORS" are supported.
.PP
.Vb 2
\&  # List tag names of ancestor elements
\&  say $dom\->ancestors\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS append
.IX Subsection "append"
.Vb 2
\&  $dom = $dom\->append(\*(Aq<p>I ♥ Mojo::DOM58!</p>\*(Aq);
\&  $dom = $dom\->append(Mojo::DOM58\->new);
.Ve
.PP
Append HTML/XML fragment to this node (for all node types other than \f(CW\*(C`root\*(C'\fR).
.PP
.Vb 3
\&  # "<div><h1>Test</h1><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)
\&    \->at(\*(Aqh1\*(Aq)\->append(\*(Aq<h2>123</h2>\*(Aq)\->root;
\&
\&  # "<p>Test 123</p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)
\&    \->child_nodes\->first\->append(\*(Aq 123\*(Aq)\->root;
.Ve
.SS append_content
.IX Subsection "append_content"
.Vb 2
\&  $dom = $dom\->append_content(\*(Aq<p>I ♥ Mojo::DOM58!</p>\*(Aq);
\&  $dom = $dom\->append_content(Mojo::DOM58\->new);
.Ve
.PP
Append HTML/XML fragment (for \f(CW\*(C`root\*(C'\fR and \f(CW\*(C`tag\*(C'\fR nodes) or raw content to this
node's content.
.PP
.Vb 3
\&  # "<div><h1>Test123</h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)
\&    \->at(\*(Aqh1\*(Aq)\->append_content(\*(Aq123\*(Aq)\->root;
\&
\&  # "<!\-\- Test 123 \-\-><br>"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><br>\*(Aq)
\&    \->child_nodes\->first\->append_content(\*(Aq123 \*(Aq)\->root;
\&
\&  # "<p>Test<i>123</i></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->append_content(\*(Aq<i>123</i>\*(Aq)\->root;
.Ve
.SS at
.IX Subsection "at"
.Vb 2
\&  my $result = $dom\->at(\*(Aqdiv ~ p\*(Aq);
\&  my $result = $dom\->at(\*(Aqsvg|line\*(Aq, svg => \*(Aqhttp://www.w3.org/2000/svg\*(Aq);
.Ve
.PP
Find first descendant element of this element matching the CSS selector and
return it as a Mojo::DOM58 object, or \f(CW\*(C`undef\*(C'\fR if none could be found. All
selectors listed in "SELECTORS" are supported.
.PP
.Vb 2
\&  # Find first element with "svg" namespace definition
\&  my $namespace = $dom\->at(\*(Aq[xmlns\e:svg]\*(Aq)\->{\*(Aqxmlns:svg\*(Aq};
.Ve
.PP
Trailing key/value pairs can be used to declare xml namespace aliases.
.PP
.Vb 3
\&  # "<rect />"
\&  $dom\->parse(\*(Aq<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>\*(Aq)
\&    \->at(\*(Aqsvg|rect\*(Aq, svg => \*(Aqhttp://www.w3.org/2000/svg\*(Aq);
.Ve
.SS attr
.IX Subsection "attr"
.Vb 4
\&  my $hash = $dom\->attr;
\&  my $foo  = $dom\->attr(\*(Aqfoo\*(Aq);
\&  $dom     = $dom\->attr({foo => \*(Aqbar\*(Aq});
\&  $dom     = $dom\->attr(foo => \*(Aqbar\*(Aq);
.Ve
.PP
This element's attributes.
.PP
.Vb 2
\&  # Remove an attribute
\&  delete $dom\->attr\->{id};
\&
\&  # Attribute without value
\&  $dom\->attr(selected => undef);
\&
\&  # List id attributes
\&  say $dom\->find(\*(Aq*\*(Aq)\->map(attr => \*(Aqid\*(Aq)\->compact\->join("\en");
.Ve
.SS child_nodes
.IX Subsection "child_nodes"
.Vb 1
\&  my $collection = $dom\->child_nodes;
.Ve
.PP
Return a collection containing all child nodes of this
element as Mojo::DOM58 objects.
.PP
.Vb 2
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p>Test<b>123</b></p>\*(Aq)\->at(\*(Aqp\*(Aq)\->child_nodes\->first\->remove;
\&
\&  # "<!DOCTYPE html>"
\&  $dom\->parse(\*(Aq<!DOCTYPE html><b>123</b>\*(Aq)\->child_nodes\->first;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<b>123</b><!\-\- Test \-\->\*(Aq)\->child_nodes\->last\->content;
.Ve
.SS children
.IX Subsection "children"
.Vb 2
\&  my $collection = $dom\->children;
\&  my $collection = $dom\->children(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all child elements of this element matching the CSS selector and return a
collection containing these elements as Mojo::DOM58
objects. All selectors listed in "SELECTORS" are supported.
.PP
.Vb 2
\&  # Show tag name of random child element
\&  say $dom\->children\->shuffle\->first\->tag;
.Ve
.SS content
.IX Subsection "content"
.Vb 3
\&  my $str = $dom\->content;
\&  $dom    = $dom\->content(\*(Aq<p>I ♥ Mojo::DOM58!</p>\*(Aq);
\&  $dom    = $dom\->content(Mojo::DOM58\->new);
.Ve
.PP
Return this node's content or replace it with HTML/XML fragment (for \f(CW\*(C`root\*(C'\fR
and \f(CW\*(C`tag\*(C'\fR nodes) or raw content.
.PP
.Vb 2
\&  # "<b>Test</b>"
\&  $dom\->parse(\*(Aq<div><b>Test</b></div>\*(Aq)\->at(\*(Aqdiv\*(Aq)\->content;
\&
\&  # "<div><h1>123</h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->content(\*(Aq123\*(Aq)\->root;
\&
\&  # "<p><i>123</i></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->content(\*(Aq<i>123</i>\*(Aq)\->root;
\&
\&  # "<div><h1></h1></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->content(\*(Aq\*(Aq)\->root;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<!\-\- Test \-\-><br>\*(Aq)\->child_nodes\->first\->content;
\&
\&  # "<div><!\-\- 123 \-\->456</div>"
\&  $dom\->parse(\*(Aq<div><!\-\- Test \-\->456</div>\*(Aq)
\&    \->at(\*(Aqdiv\*(Aq)\->child_nodes\->first\->content(\*(Aq 123 \*(Aq)\->root;
.Ve
.SS descendant_nodes
.IX Subsection "descendant_nodes"
.Vb 1
\&  my $collection = $dom\->descendant_nodes;
.Ve
.PP
Return a collection containing all descendant nodes of
this element as Mojo::DOM58 objects.
.PP
.Vb 4
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p><!\-\- Test \-\-><b>123<!\-\- 456 \-\-></b></p>\*(Aq)
\&    \->descendant_nodes\->grep(sub { $_\->type eq \*(Aqcomment\*(Aq })
\&    \->map(\*(Aqremove\*(Aq)\->first;
\&
\&  # "<p><b>test</b>test</p>"
\&  $dom\->parse(\*(Aq<p><b>123</b>456</p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->descendant_nodes\->grep(sub { $_\->type eq \*(Aqtext\*(Aq })
\&    \->map(content => \*(Aqtest\*(Aq)\->first\->root;
.Ve
.SS find
.IX Subsection "find"
.Vb 2
\&  my $collection = $dom\->find(\*(Aqdiv ~ p\*(Aq);
\&  my $collection = $dom\->find(\*(Aqsvg|line\*(Aq, svg => \*(Aqhttp://www.w3.org/2000/svg\*(Aq);
.Ve
.PP
Find all descendant elements of this element matching the CSS selector and
return a collection containing these elements as
Mojo::DOM58 objects. All selectors listed in "SELECTORS" are supported.
.PP
.Vb 2
\&  # Find a specific element and extract information
\&  my $id = $dom\->find(\*(Aqdiv\*(Aq)\->[23]{id};
\&
\&  # Extract information from multiple elements
\&  my @headers = $dom\->find(\*(Aqh1, h2, h3\*(Aq)\->map(\*(Aqtext\*(Aq)\->each;
\&
\&  # Count all the different tags
\&  my $hash = $dom\->find(\*(Aq*\*(Aq)\->reduce(sub { $a\->{$b\->tag}++; $a }, {});
\&
\&  # Find elements with a class that contains dots
\&  my @divs = $dom\->find(\*(Aqdiv.foo\e.bar\*(Aq)\->each;
.Ve
.PP
Trailing key/value pairs can be used to declare xml namespace aliases.
.PP
.Vb 3
\&  # "<rect />"
\&  $dom\->parse(\*(Aq<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>\*(Aq)
\&    \->find(\*(Aqsvg|rect\*(Aq, svg => \*(Aqhttp://www.w3.org/2000/svg\*(Aq)\->first;
.Ve
.SS following
.IX Subsection "following"
.Vb 2
\&  my $collection = $dom\->following;
\&  my $collection = $dom\->following(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all sibling elements after this node matching the CSS selector and return
a collection containing these elements as
Mojo::DOM58 objects. All selectors listed in "SELECTORS" are supported.
.PP
.Vb 2
\&  # List tags of sibling elements after this node
\&  say $dom\->following\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS following_nodes
.IX Subsection "following_nodes"
.Vb 1
\&  my $collection = $dom\->following_nodes;
.Ve
.PP
Return a collection containing all sibling nodes after
this node as Mojo::DOM58 objects.
.PP
.Vb 2
\&  # "C"
\&  $dom\->parse(\*(Aq<p>A</p><!\-\- B \-\->C\*(Aq)\->at(\*(Aqp\*(Aq)\->following_nodes\->last\->content;
.Ve
.SS matches
.IX Subsection "matches"
.Vb 2
\&  my $bool = $dom\->matches(\*(Aqdiv ~ p\*(Aq);
\&  my $bool = $dom\->matches(\*(Aqsvg|line\*(Aq, svg => \*(Aqhttp://www.w3.org/2000/svg\*(Aq);
.Ve
.PP
Check if this element matches the CSS selector. All selectors listed in
"SELECTORS" are supported.
.PP
.Vb 3
\&  # True
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aq.a\*(Aq);
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aqp[class]\*(Aq);
\&
\&  # False
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aq.b\*(Aq);
\&  $dom\->parse(\*(Aq<p class="a">A</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->matches(\*(Aqp[id]\*(Aq);
.Ve
.PP
Trailing key/value pairs can be used to declare xml namespace aliases.
.PP
.Vb 3
\&  # True
\&  $dom\->parse(\*(Aq<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>\*(Aq)
\&    \->matches(\*(Aqsvg|rect\*(Aq, svg => \*(Aqhttp://www.w3.org/2000/svg\*(Aq);
.Ve
.SS namespace
.IX Subsection "namespace"
.Vb 1
\&  my $namespace = $dom\->namespace;
.Ve
.PP
Find this element's namespace, or return \f(CW\*(C`undef\*(C'\fR if none could be found.
.PP
.Vb 2
\&  # "http://www.w3.org/2000/svg"
\&  Mojo::DOM58\->new(\*(Aq<svg xmlns:svg="http://www.w3.org/2000/svg"><svg:circle>3.14</svg:circle></svg>\*(Aq)\->at(\*(Aqsvg\e:circle\*(Aq)\->namespace;
\&
\&  # Find namespace for an element with namespace prefix
\&  my $namespace = $dom\->at(\*(Aqsvg > svg\e:circle\*(Aq)\->namespace;
\&
\&  # Find namespace for an element that may or may not have a namespace prefix
\&  my $namespace = $dom\->at(\*(Aqsvg > circle\*(Aq)\->namespace;
.Ve
.SS next
.IX Subsection "next"
.Vb 1
\&  my $sibling = $dom\->next;
.Ve
.PP
Return Mojo::DOM58 object for next sibling element, or \f(CW\*(C`undef\*(C'\fR if there are
no more siblings.
.PP
.Vb 2
\&  # "<h2>123</h2>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1><h2>123</h2></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->next;
.Ve
.SS next_node
.IX Subsection "next_node"
.Vb 1
\&  my $sibling = $dom\->next_node;
.Ve
.PP
Return Mojo::DOM58 object for next sibling node, or \f(CW\*(C`undef\*(C'\fR if there are no
more siblings.
.PP
.Vb 3
\&  # "456"
\&  $dom\->parse(\*(Aq<p><b>123</b><!\-\- Test \-\->456</p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->next_node\->next_node;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<p><b>123</b><!\-\- Test \-\->456</p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->next_node\->content;
.Ve
.SS parent
.IX Subsection "parent"
.Vb 1
\&  my $parent = $dom\->parent;
.Ve
.PP
Return Mojo::DOM58 object for parent of this node, or \f(CW\*(C`undef\*(C'\fR if this node
has no parent.
.PP
.Vb 2
\&  # "<b><i>Test</i></b>"
\&  $dom\->parse(\*(Aq<p><b><i>Test</i></b></p>\*(Aq)\->at(\*(Aqi\*(Aq)\->parent;
.Ve
.SS parse
.IX Subsection "parse"
.Vb 1
\&  $dom = $dom\->parse(\*(Aq<foo bar="baz">I ♥ Mojo::DOM58!</foo>\*(Aq);
.Ve
.PP
Parse HTML/XML fragment.
.PP
.Vb 2
\&  # Parse XML
\&  my $dom = Mojo::DOM58\->new\->xml(1)\->parse(\*(Aq<foo>I ♥ Mojo::DOM58!</foo>\*(Aq);
.Ve
.SS preceding
.IX Subsection "preceding"
.Vb 2
\&  my $collection = $dom\->preceding;
\&  my $collection = $dom\->preceding(\*(Aqdiv ~ p\*(Aq);
.Ve
.PP
Find all sibling elements before this node matching the CSS selector and return
a collection containing these elements as
Mojo::DOM58 objects. All selectors listed in "SELECTORS" are supported.
.PP
.Vb 2
\&  # List tags of sibling elements before this node
\&  say $dom\->preceding\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS preceding_nodes
.IX Subsection "preceding_nodes"
.Vb 1
\&  my $collection = $dom\->preceding_nodes;
.Ve
.PP
Return a collection containing all sibling nodes
before this node as Mojo::DOM58 objects.
.PP
.Vb 2
\&  # "A"
\&  $dom\->parse(\*(AqA<!\-\- B \-\-><p>C</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->preceding_nodes\->first\->content;
.Ve
.SS prepend
.IX Subsection "prepend"
.Vb 2
\&  $dom = $dom\->prepend(\*(Aq<p>I ♥ Mojo::DOM58!</p>\*(Aq);
\&  $dom = $dom\->prepend(Mojo::DOM58\->new);
.Ve
.PP
Prepend HTML/XML fragment to this node (for all node types other than \f(CW\*(C`root\*(C'\fR).
.PP
.Vb 3
\&  # "<div><h1>Test</h1><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h2>123</h2></div>\*(Aq)
\&    \->at(\*(Aqh2\*(Aq)\->prepend(\*(Aq<h1>Test</h1>\*(Aq)\->root;
\&
\&  # "<p>Test 123</p>"
\&  $dom\->parse(\*(Aq<p>123</p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->child_nodes\->first\->prepend(\*(AqTest \*(Aq)\->root;
.Ve
.SS prepend_content
.IX Subsection "prepend_content"
.Vb 2
\&  $dom = $dom\->prepend_content(\*(Aq<p>I ♥ Mojo::DOM58!</p>\*(Aq);
\&  $dom = $dom\->prepend_content(Mojo::DOM58\->new);
.Ve
.PP
Prepend HTML/XML fragment (for \f(CW\*(C`root\*(C'\fR and \f(CW\*(C`tag\*(C'\fR nodes) or raw content to this
node's content.
.PP
.Vb 3
\&  # "<div><h2>Test123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h2>123</h2></div>\*(Aq)
\&    \->at(\*(Aqh2\*(Aq)\->prepend_content(\*(AqTest\*(Aq)\->root;
\&
\&  # "<!\-\- Test 123 \-\-><br>"
\&  $dom\->parse(\*(Aq<!\-\- 123 \-\-><br>\*(Aq)
\&    \->child_nodes\->first\->prepend_content(\*(Aq Test\*(Aq)\->root;
\&
\&  # "<p><i>123</i>Test</p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->prepend_content(\*(Aq<i>123</i>\*(Aq)\->root;
.Ve
.SS previous
.IX Subsection "previous"
.Vb 1
\&  my $sibling = $dom\->previous;
.Ve
.PP
Return Mojo::DOM58 object for previous sibling element, or \f(CW\*(C`undef\*(C'\fR if there
are no more siblings.
.PP
.Vb 2
\&  # "<h1>Test</h1>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1><h2>123</h2></div>\*(Aq)\->at(\*(Aqh2\*(Aq)\->previous;
.Ve
.SS previous_node
.IX Subsection "previous_node"
.Vb 1
\&  my $sibling = $dom\->previous_node;
.Ve
.PP
Return Mojo::DOM58 object for previous sibling node, or \f(CW\*(C`undef\*(C'\fR if there are
no more siblings.
.PP
.Vb 3
\&  # "123"
\&  $dom\->parse(\*(Aq<p>123<!\-\- Test \-\-><b>456</b></p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->previous_node\->previous_node;
\&
\&  # " Test "
\&  $dom\->parse(\*(Aq<p>123<!\-\- Test \-\-><b>456</b></p>\*(Aq)
\&    \->at(\*(Aqb\*(Aq)\->previous_node\->content;
.Ve
.SS remove
.IX Subsection "remove"
.Vb 1
\&  my $parent = $dom\->remove;
.Ve
.PP
Remove this node and return "root" (for \f(CW\*(C`root\*(C'\fR nodes) or "parent".
.PP
.Vb 2
\&  # "<div></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->remove;
\&
\&  # "<p><b>456</b></p>"
\&  $dom\->parse(\*(Aq<p>123<b>456</b></p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->child_nodes\->first\->remove\->root;
.Ve
.SS replace
.IX Subsection "replace"
.Vb 2
\&  my $parent = $dom\->replace(\*(Aq<div>I ♥ Mojo::DOM58!</div>\*(Aq);
\&  my $parent = $dom\->replace(Mojo::DOM58\->new);
.Ve
.PP
Replace this node with HTML/XML fragment and return "root" (for \f(CW\*(C`root\*(C'\fR
nodes) or "parent".
.PP
.Vb 2
\&  # "<div><h2>123</h2></div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->replace(\*(Aq<h2>123</h2>\*(Aq);
\&
\&  # "<p><b>123</b></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)
\&    \->at(\*(Aqp\*(Aq)\->child_nodes\->[0]\->replace(\*(Aq<b>123</b>\*(Aq)\->root;
.Ve
.SS root
.IX Subsection "root"
.Vb 1
\&  my $root = $dom\->root;
.Ve
.PP
Return Mojo::DOM58 object for \f(CW\*(C`root\*(C'\fR node.
.SS selector
.IX Subsection "selector"
.Vb 1
\&  my $selector = $dom\->selector;
.Ve
.PP
Get a unique CSS selector for this element.
.PP
.Vb 2
\&  # "ul:nth\-child(1) > li:nth\-child(2)"
\&  $dom\->parse(\*(Aq<ul><li>Test</li><li>123</li></ul>\*(Aq)\->find(\*(Aqli\*(Aq)\->last\->selector;
\&
\&  # "p:nth\-child(1) > b:nth\-child(1) > i:nth\-child(1)"
\&  $dom\->parse(\*(Aq<p><b><i>Test</i></b></p>\*(Aq)\->at(\*(Aqi\*(Aq)\->selector;
.Ve
.SS strip
.IX Subsection "strip"
.Vb 1
\&  my $parent = $dom\->strip;
.Ve
.PP
Remove this element while preserving its content and return "parent".
.PP
.Vb 2
\&  # "<div>Test</div>"
\&  $dom\->parse(\*(Aq<div><h1>Test</h1></div>\*(Aq)\->at(\*(Aqh1\*(Aq)\->strip;
.Ve
.SS tag
.IX Subsection "tag"
.Vb 2
\&  my $tag = $dom\->tag;
\&  $dom    = $dom\->tag(\*(Aqdiv\*(Aq);
.Ve
.PP
This element's tag name.
.PP
.Vb 2
\&  # List tag names of child elements
\&  say $dom\->children\->map(\*(Aqtag\*(Aq)\->join("\en");
.Ve
.SS tap
.IX Subsection "tap"
.Vb 1
\&  $dom = $dom\->tap(sub {...});
.Ve
.PP
Equivalent to "tap" in Mojo::Base.
.SS text
.IX Subsection "text"
.Vb 1
\&  my $text = $dom\->text;
.Ve
.PP
Extract text content from this element only (not including child elements).
.PP
.Vb 2
\&  # "bar"
\&  $dom\->parse("<div>foo<p>bar</p>baz</div>")\->at(\*(Aqp\*(Aq)\->text;
\&
\&  # "foo\enbaz\en"
\&  $dom\->parse("<div>foo\en<p>bar</p>baz\en</div>")\->at(\*(Aqdiv\*(Aq)\->text;
.Ve
.SS to_string
.IX Subsection "to_string"
.Vb 1
\&  my $str = $dom\->to_string;
.Ve
.PP
Render this node and its content to HTML/XML.
.PP
.Vb 2
\&  # "<b>Test</b>"
\&  $dom\->parse(\*(Aq<div><b>Test</b></div>\*(Aq)\->at(\*(Aqdiv b\*(Aq)\->to_string;
.Ve
.PP
To extract text content from all descendant nodes, see "all_text".
.SS tree
.IX Subsection "tree"
.Vb 2
\&  my $tree = $dom\->tree;
\&  $dom     = $dom\->tree([\*(Aqroot\*(Aq]);
.Ve
.PP
Document Object Model. Note that this structure should only be used very
carefully since it is very dynamic.
.SS type
.IX Subsection "type"
.Vb 1
\&  my $type = $dom\->type;
.Ve
.PP
This node's type, usually \f(CW\*(C`cdata\*(C'\fR, \f(CW\*(C`comment\*(C'\fR, \f(CW\*(C`doctype\*(C'\fR, \f(CW\*(C`pi\*(C'\fR, \f(CW\*(C`raw\*(C'\fR,
\&\f(CW\*(C`root\*(C'\fR, \f(CW\*(C`tag\*(C'\fR or \f(CW\*(C`text\*(C'\fR.
.PP
.Vb 2
\&  # "cdata"
\&  $dom\->parse(\*(Aq<![CDATA[Test]]>\*(Aq)\->child_nodes\->first\->type;
\&
\&  # "comment"
\&  $dom\->parse(\*(Aq<!\-\- Test \-\->\*(Aq)\->child_nodes\->first\->type;
\&
\&  # "doctype"
\&  $dom\->parse(\*(Aq<!DOCTYPE html>\*(Aq)\->child_nodes\->first\->type;
\&
\&  # "pi"
\&  $dom\->parse(\*(Aq<?xml version="1.0"?>\*(Aq)\->child_nodes\->first\->type;
\&
\&  # "raw"
\&  $dom\->parse(\*(Aq<title>Test</title>\*(Aq)\->at(\*(Aqtitle\*(Aq)\->child_nodes\->first\->type;
\&
\&  # "root"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->type;
\&
\&  # "tag"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->type;
\&
\&  # "text"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->child_nodes\->first\->type;
.Ve
.SS val
.IX Subsection "val"
.Vb 1
\&  my $value = $dom\->val;
.Ve
.PP
Extract value from form element (such as \f(CW\*(C`button\*(C'\fR, \f(CW\*(C`input\*(C'\fR, \f(CW\*(C`option\*(C'\fR,
\&\f(CW\*(C`select\*(C'\fR and \f(CW\*(C`textarea\*(C'\fR), or return \f(CW\*(C`undef\*(C'\fR if this element has no value. In
the case of \f(CW\*(C`select\*(C'\fR with \f(CW\*(C`multiple\*(C'\fR attribute, find \f(CW\*(C`option\*(C'\fR elements with
\&\f(CW\*(C`selected\*(C'\fR attribute and return an array reference with all values, or
\&\f(CW\*(C`undef\*(C'\fR if none could be found.
.PP
.Vb 2
\&  # "a"
\&  $dom\->parse(\*(Aq<input name=test value=a>\*(Aq)\->at(\*(Aqinput\*(Aq)\->val;
\&
\&  # "b"
\&  $dom\->parse(\*(Aq<textarea>b</textarea>\*(Aq)\->at(\*(Aqtextarea\*(Aq)\->val;
\&
\&  # "c"
\&  $dom\->parse(\*(Aq<option value="c">Test</option>\*(Aq)\->at(\*(Aqoption\*(Aq)\->val;
\&
\&  # "d"
\&  $dom\->parse(\*(Aq<select><option selected>d</option></select>\*(Aq)
\&    \->at(\*(Aqselect\*(Aq)\->val;
\&
\&  # "e"
\&  $dom\->parse(\*(Aq<select multiple><option selected>e</option></select>\*(Aq)
\&    \->at(\*(Aqselect\*(Aq)\->val\->[0];
\&
\&  # "on"
\&  $dom\->parse(\*(Aq<input name=test type=checkbox>\*(Aq)\->at(\*(Aqinput\*(Aq)\->val;
.Ve
.SS with_roles
.IX Subsection "with_roles"
.Vb 3
\&  my $new_class = Mojo::DOM58\->with_roles(\*(AqMojo::DOM58::Role::One\*(Aq);
\&  my $new_class = Mojo::DOM58\->with_roles(\*(Aq+One\*(Aq, \*(Aq+Two\*(Aq);
\&  $dom          = $dom\->with_roles(\*(Aq+One\*(Aq, \*(Aq+Two\*(Aq);
.Ve
.PP
Equivalent to "with_roles" in Mojo::Base. Note that role support depends on
Role::Tiny (2.000001+).
.SS wrap
.IX Subsection "wrap"
.Vb 2
\&  $dom = $dom\->wrap(\*(Aq<div></div>\*(Aq);
\&  $dom = $dom\->wrap(Mojo::DOM58\->new);
.Ve
.PP
Wrap HTML/XML fragment around this node (for all node types other than \f(CW\*(C`root\*(C'\fR),
placing it as the last child of the first innermost element.
.PP
.Vb 2
\&  # "<p>123<b>Test</b></p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<p>123</p>\*(Aq)\->root;
\&
\&  # "<div><p><b>Test</b></p>123</div>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<div><p></p>123</div>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p><p>123</p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->at(\*(Aqb\*(Aq)\->wrap(\*(Aq<p></p><p>123</p>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p>"
\&  $dom\->parse(\*(Aq<p>Test</p>\*(Aq)\->at(\*(Aqp\*(Aq)\->child_nodes\->first\->wrap(\*(Aq<b>\*(Aq)\->root;
.Ve
.SS wrap_content
.IX Subsection "wrap_content"
.Vb 2
\&  $dom = $dom\->wrap_content(\*(Aq<div></div>\*(Aq);
\&  $dom = $dom\->wrap_content(Mojo::DOM58\->new);
.Ve
.PP
Wrap HTML/XML fragment around this node's content (for \f(CW\*(C`root\*(C'\fR and \f(CW\*(C`tag\*(C'\fR
nodes), placing it as the last children of the first innermost element.
.PP
.Vb 2
\&  # "<p><b>123Test</b></p>"
\&  $dom\->parse(\*(Aq<p>Test<p>\*(Aq)\->at(\*(Aqp\*(Aq)\->wrap_content(\*(Aq<b>123</b>\*(Aq)\->root;
\&
\&  # "<p><b>Test</b></p><p>123</p>"
\&  $dom\->parse(\*(Aq<b>Test</b>\*(Aq)\->wrap_content(\*(Aq<p></p><p>123</p>\*(Aq);
.Ve
.SS xml
.IX Subsection "xml"
.Vb 2
\&  my $bool = $dom\->xml;
\&  $dom     = $dom\->xml($bool);
.Ve
.PP
Disable HTML semantics in parser and activate case-sensitivity, defaults to
auto detection based on XML declarations.
.SH "COLLECTION METHODS"
.IX Header "COLLECTION METHODS"
Some Mojo::DOM58 methods return an array-based collection object based on
Mojo::Collection, which can either be accessed directly as an array
reference, or with the following methods.
.PP
.Vb 5
\&  # Chain methods
\&  $collection\->map(sub { ucfirst })\->shuffle\->each(sub {
\&    my ($word, $num) = @_;
\&    say "$num: $word";
\&  });
\&
\&  # Access array directly to manipulate collection
\&  $collection\->[23] += 100;
\&  say for @$collection;
.Ve
.SS compact
.IX Subsection "compact"
.Vb 1
\&  my $new = $collection\->compact;
.Ve
.PP
Create a new collection with all elements that are
defined and not an empty string.
.PP
.Vb 2
\&  # $collection contains (0, 1, undef, 2, \*(Aq\*(Aq, 3)
\&  $collection\->compact\->join(\*(Aq, \*(Aq); # "0, 1, 2, 3"
.Ve
.SS each
.IX Subsection "each"
.Vb 2
\&  my @elements = $collection\->each;
\&  $collection  = $collection\->each(sub {...});
.Ve
.PP
Evaluate callback for each element in collection or return all elements as a
list if none has been provided. The element will be the first argument passed
to the callback and is also available as \f(CW$_\fR.
.PP
.Vb 5
\&  # Make a numbered list
\&  $collection\->each(sub {
\&    my ($e, $num) = @_;
\&    say "$num: $e";
\&  });
.Ve
.SS first
.IX Subsection "first"
.Vb 5
\&  my $first = $collection\->first;
\&  my $first = $collection\->first(qr/foo/);
\&  my $first = $collection\->first(sub {...});
\&  my $first = $collection\->first($method);
\&  my $first = $collection\->first($method, @args);
.Ve
.PP
Evaluate regular expression/callback for, or call method on, each element in
collection and return the first one that matched the regular expression, or for
which the callback/method returned true. The element will be the first argument
passed to the callback and is also available as \f(CW$_\fR.
.PP
.Vb 2
\&  # Longer version
\&  my $first = $collection\->first(sub { $_\->$method(@args) });
\&
\&  # Find first value that contains the word "mojo"
\&  my $interesting = $collection\->first(qr/mojo/i);
\&
\&  # Find first value that is greater than 5
\&  my $greater = $collection\->first(sub { $_ > 5 });
.Ve
.SS flatten
.IX Subsection "flatten"
.Vb 1
\&  my $new = $collection\->flatten;
.Ve
.PP
Flatten nested collections/arrays recursively and create a new
collection with all elements.
.PP
.Vb 2
\&  # $collection contains (1, [2, [3, 4], 5, [6]], 7)
\&  $collection\->flatten\->join(\*(Aq, \*(Aq); # "1, 2, 3, 4, 5, 6, 7"
.Ve
.SS grep
.IX Subsection "grep"
.Vb 4
\&  my $new = $collection\->grep(qr/foo/);
\&  my $new = $collection\->grep(sub {...});
\&  my $new = $collection\->grep($method);
\&  my $new = $collection\->grep($method, @args);
.Ve
.PP
Evaluate regular expression/callback for, or call method on, each element in
collection and create a new collection with all
elements that matched the regular expression, or for which the callback/method
returned true. The element will be the first argument passed to the callback
and is also available as \f(CW$_\fR.
.PP
.Vb 2
\&  # Longer version
\&  my $new = $collection\->grep(sub { $_\->$method(@args) });
\&
\&  # Find all values that contain the word "mojo"
\&  my $interesting = $collection\->grep(qr/mojo/i);
\&
\&  # Find all values that are greater than 5
\&  my $greater = $collection\->grep(sub { $_ > 5 });
.Ve
.SS head
.IX Subsection "head"
.Vb 2
\&  my $new = $collection\->head(4);
\&  my $new = $collection\->head(\-2);
.Ve
.PP
Create a new collection with up to the specified
number of elements from the beginning of the collection. A negative number will
count from the end.
.PP
.Vb 3
\&  # $collection contains (\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq, \*(AqD\*(Aq, \*(AqE\*(Aq)
\&  $collection\->head(3)\->join(\*(Aq \*(Aq); # "A B C"
\&  $collection\->head(\-3)\->join(\*(Aq \*(Aq); # "A B"
.Ve
.SS join
.IX Subsection "join"
.Vb 2
\&  my $stream = $collection\->join;
\&  my $stream = $collection\->join("\en");
.Ve
.PP
Turn collection into string.
.PP
.Vb 2
\&  # Join all values with commas
\&  $collection\->join(\*(Aq, \*(Aq);
.Ve
.SS last
.IX Subsection "last"
.Vb 1
\&  my $last = $collection\->last;
.Ve
.PP
Return the last element in collection.
.SS map
.IX Subsection "map"
.Vb 3
\&  my $new = $collection\->map(sub {...});
\&  my $new = $collection\->map($method);
\&  my $new = $collection\->map($method, @args);
.Ve
.PP
Evaluate callback for, or call method on, each element in collection and create
a new collection from the results. The element will be
the first argument passed to the callback and is also available as \f(CW$_\fR.
.PP
.Vb 2
\&  # Longer version
\&  my $new = $collection\->map(sub { $_\->$method(@args) });
\&
\&  # Append the word "mojo" to all values
\&  my $domified = $collection\->map(sub { $_ . \*(Aqmojo\*(Aq });
.Ve
.SS reduce
.IX Subsection "reduce"
.Vb 2
\&  my $result = $collection\->reduce(sub {...});
\&  my $result = $collection\->reduce(sub {...}, $initial);
.Ve
.PP
Reduce elements in collection with callback, the first element will be used as
initial value if none has been provided.
.PP
.Vb 2
\&  # Calculate the sum of all values
\&  my $sum = $collection\->reduce(sub { $a + $b });
\&
\&  # Count how often each value occurs in collection
\&  my $hash = $collection\->reduce(sub { $a\->{$b}++; $a }, {});
.Ve
.SS reverse
.IX Subsection "reverse"
.Vb 1
\&  my $new = $collection\->reverse;
.Ve
.PP
Create a new collection with all elements in reverse
order.
.SS slice
.IX Subsection "slice"
.Vb 1
\&  my $new = $collection\->slice(4 .. 7);
.Ve
.PP
Create a new collection with all selected elements.
.PP
.Vb 2
\&  # $collection contains (\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq, \*(AqD\*(Aq, \*(AqE\*(Aq)
\&  $collection\->slice(1, 2, 4)\->join(\*(Aq \*(Aq); # "B C E"
.Ve
.SS shuffle
.IX Subsection "shuffle"
.Vb 1
\&  my $new = $collection\->shuffle;
.Ve
.PP
Create a new collection with all elements in random
order.
.SS size
.IX Subsection "size"
.Vb 1
\&  my $size = $collection\->size;
.Ve
.PP
Number of elements in collection.
.SS sort
.IX Subsection "sort"
.Vb 2
\&  my $new = $collection\->sort;
\&  my $new = $collection\->sort(sub {...});
.Ve
.PP
Sort elements based on return value of callback and create a new
collection from the results.
.PP
.Vb 2
\&  # Sort values case\-insensitive
\&  my $case_insensitive = $collection\->sort(sub { uc($a) cmp uc($b) });
.Ve
.SS tail
.IX Subsection "tail"
.Vb 2
\&  my $new = $collection\->tail(4);
\&  my $new = $collection\->tail(\-2);
.Ve
.PP
Create a new collection with up to the specified
number of elements from the end of the collection. A negative number will count
from the beginning.
.PP
.Vb 3
\&  # $collection contains (\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq, \*(AqD\*(Aq, \*(AqE\*(Aq)
\&  $collection\->tail(3)\->join(\*(Aq \*(Aq); # "C D E"
\&  $collection\->tail(\-3)\->join(\*(Aq \*(Aq); # "D E"
.Ve
.SS tap
.IX Subsection "tap"
.Vb 1
\&  $collection = $collection\->tap(sub {...});
.Ve
.PP
Equivalent to "tap" in Mojo::Base.
.SS to_array
.IX Subsection "to_array"
.Vb 1
\&  my $array = $collection\->to_array;
.Ve
.PP
Turn collection into array reference.
.SS uniq
.IX Subsection "uniq"
.Vb 4
\&  my $new = $collection\->uniq;
\&  my $new = $collection\->uniq(sub {...});
\&  my $new = $collection\->uniq($method);
\&  my $new = $collection\->uniq($method, @args);
.Ve
.PP
Create a new collection without duplicate elements,
using the string representation of either the elements or the return value of
the callback/method to decide uniqueness. Note that \f(CW\*(C`undef\*(C'\fR and empty string
are treated the same.
.PP
.Vb 2
\&  # Longer version
\&  my $new = $collection\->uniq(sub { $_\->$method(@args) });
\&
\&  # $collection contains (\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq)
\&  $collection\->uniq\->join(\*(Aq \*(Aq); # "foo bar baz"
\&
\&  # $collection contains ([1, 2], [2, 1], [3, 2])
\&  $collection\->uniq(sub{ $_\->[1] })\->to_array; # "[[1, 2], [2, 1]]"
.Ve
.SS with_roles
.IX Subsection "with_roles"
.Vb 1
\&  $collection = $collection\->with_roles(\*(AqMojo::Collection::Role::One\*(Aq);
.Ve
.PP
Equivalent to "with_roles" in Mojo::Base. Note that role support depends on
Role::Tiny (2.000001+).
.SH DEBUGGING
.IX Header "DEBUGGING"
You can set the \f(CW\*(C`MOJO_DOM58_CSS_DEBUG\*(C'\fR environment variable to get some advanced diagnostics information printed to
\&\f(CW\*(C`STDERR\*(C'\fR.
.PP
.Vb 1
\&  MOJO_DOM58_CSS_DEBUG=1
.Ve
.SH BUGS
.IX Header "BUGS"
Report issues related to the format of this distribution or Perl 5.8 support to
the public bugtracker. Any other issues should be reported directly to the
upstream Mojolicious issue tracker.
.SH AUTHOR
.IX Header "AUTHOR"
Dan Book <dbook@cpan.org>
.PP
Code and tests adapted from Mojo::DOM, a lightweight DOM parser by the Mojolicious team.
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
.IP "Matt S Trout (mst)" 4
.IX Item "Matt S Trout (mst)"
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2008\-2016 Sebastian Riedel and others.
.PP
Copyright (c) 2016 "AUTHOR" and "CONTRIBUTORS" for adaptation to standalone format.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mojo::DOM, HTML::TreeBuilder, XML::LibXML, XML::Twig, XML::Smart
