.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Util 3"
.TH IO::Util 3 2005-12-31 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
IO::Util \- A selection of general\-utility IO function
.SH "VERSION 1.5"
.IX Header "VERSION 1.5"
The latest versions changes are reported in the \fIChanges\fR file in this distribution.
.SH INSTALLATION
.IX Header "INSTALLATION"
.IP Prerequisites 4
.IX Item "Prerequisites"
.Vb 2
\&    Time::HiRes   = 0
\&    Sys::Hostname = 0
.Ve
.IP CPAN 4
.IX Item "CPAN"
.Vb 1
\&    perl \-MCPAN \-e \*(Aqinstall IO::Util\*(Aq
.Ve
.IP "Standard installation" 4
.IX Item "Standard installation"
From the directory where this file is located, type:
.Sp
.Vb 4
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use IO::Util qw(capture slurp Tid Lid Uid load_mml);
.Ve
.PP
\&\fBcapture()\fR
.PP
.Vb 3
\&  # captures the selected filehandle
\&  $output_ref = capture { any_printing_code() } ;
\&  # now $$output_ref eq \*(Aqsomething\*(Aq
\&  
\&  # captures FILEHANDLE
\&  $output_ref = capture { any_special_printing_code() } \e*FILEHEANDLER ;
\&  
\&  # append the output to $captured
\&  capture { any_printing_code() } \e*FILEHEANDLER , \e$captured
\&  # now $captured eq \*(Aqsomething\*(Aq
\&  
\&  # use another class to tie the handler
\&  use IO::Scalar ;
\&  $IO::Util::TIE_HANDLE_CLASS = \*(AqIO::Scalar\*(Aq
.Ve
.PP
\&\fBslurp()\fR
.PP
.Vb 4
\&  $_ = \*(Aq/path/to/file\*(Aq ;
\&  $content_ref = slurp ;
\&  $content_ref = slurp \*(Aq/path/to/file\*(Aq ;
\&  $content_ref = slurp \e*FILEHANDLE ;
\&  
\&  # append the file content to $content
\&  $_ = \*(Aq/path/to/file\*(Aq ;
\&  slurp \e$content;
\&  slurp \*(Aq/path/to/file\*(Aq, \e$content ;
\&  slurp \e*FILEHANDLE, \e$content ;
.Ve
.PP
\&\fBTid()\fR, \fBLid()\fR, \fBUid()\fR
.PP
.Vb 3
\&  $temporarily_unique_id = Tid ; # \*(AqQ9MU1N_NVRM\*(Aq
\&  $locally_unique_id     = Lid ; # \*(Aq2MS_Q9MU1N_P5F6\*(Aq
\&  $universally_unique_id = Uid ; # \*(AqMGJFSBTK_2MS_Q9MU1N_PWES\*(Aq
.Ve
.PP
A MML file (Minimal Markup Language)
.PP
.Vb 10
\&   <opt>
\&    <!\-\- a multi line
\&     comment\-\->
\&       <parA>
\&           <optA>01</optA>
\&           <optA>02</optA>
\&           <optA>03</optA>
\&       </parA>
\&       <parB>
\&           <optA>04</optA>
\&           <optA>05</optA>
\&           <optA>06</optA>
\&           <optB>
\&              <key>any key</key>
\&           </optB>
\&       </parB>
\&   </opt>
.Ve
.PP
\&\fBload_mml()\fR
.PP
.Vb 4
\&  $struct = load_mml \*(Aqpath/to/mml_file\*(Aq ;
\&  $struct = load_mml \e $mml_string ;
\&  $struct = load_mml \e *MMLFILE ;
\&  $struct = load_mml ..., %options ;
\&
\&  # $struct = {
\&  #             \*(AqparA\*(Aq => {
\&  #                         \*(AqoptA\*(Aq => [
\&  #                                     \*(Aq01\*(Aq,
\&  #                                     \*(Aq02\*(Aq,
\&  #                                     \*(Aq03\*(Aq
\&  #                                   ]
\&  #                       },
\&  #             \*(AqparB\*(Aq => {
\&  #                         \*(AqoptA\*(Aq => [
\&  #                                     \*(Aq04\*(Aq,
\&  #                                     \*(Aq05\*(Aq,
\&  #                                     \*(Aq06\*(Aq
\&  #                                   ],
\&  #                         \*(AqoptB\*(Aq => {
\&  #                                     \*(Aqkey\*(Aq => \*(Aqany key\*(Aq
\&  #                                   }
\&  #                      }
\&  #           }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is a micro-weight module that exports a few functions of general utility in IO operations.
.SH "CAPTURING OUTPUT"
.IX Header "CAPTURING OUTPUT"
.SS "capture { code } [ arguments ]"
.IX Subsection "capture { code } [ arguments ]"
Use this function in order to capture the output that a \fIcode\fR write to any \fIFILEHANDLE\fR (usually STDOUT) by using \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR and \f(CW\*(C`syswrite\*(C'\fR statements. The function works also with already tied handles, and older perl versions.
.PP
This function expects a mandatory code reference (usually a code block) passed as the first argument and two optional arguments: \fIhandle_ref\fR and \fIscalar_ref\fR. The function executes the referenced code and returns a reference to the captured output.
.PP
If \fIhandle_ref\fR is omitted the selected filehandle will be used by default (usually \f(CW\*(C`STDOUT\*(C'\fR). If you pass \fIscalar_ref\fR, the output will be appended to the referenced scalar. In this case the result of the function will be the same SCALAR reference passed as the argument.
.PP
You can pass the optional arguments in mixed order. All the following statement work:
.PP
.Vb 6
\&   $output_ref = capture {...}
\&   $output_ref = capture {...} \e*FH
\&   capture {...} \e*FH, \e$output ; # capure FH and append to $output
\&   capture {...} \e$output, \e*FH ; # capure FH and append to $output
\&   capture {...} \e$output ;       # append to $output
\&   capture \e&code, ...            # a classical code ref works too
.Ve
.PP
\&\fBNote\fR: This function ties the \fIFILEHANDLE\fR to IO::Util::WriteHandle class and unties it after the execution of the \fIcode\fR. If \fIFILEHANDLE\fR is already tied to any other class, it just temporary re-bless the tied object to IO::Util::Handle class, re-blessing it again to its original class after the execution of the \fIcode\fR, thus preserving the original \fIFILEHANDLE\fR configuration.
.SH "SLURPING FILES"
.IX Header "SLURPING FILES"
.SS "slurp [ arguments ]"
.IX Subsection "slurp [ arguments ]"
The \f(CW\*(C`slurp\*(C'\fR function expects a path to a \fIfile\fR or an open \fIhandle_ref\fR, and returns the reference to the whole \fIfile|handle_ref\fR content. If no argument is passed it will use \f(CW$_\fR as the argument.
.PP
As an alternative you can pass also a SCALAR reference as an argument, so the content will be appended to the referenced scalar. In this case the result of the function will be the same SCALAR reference passed as the argument.
.PP
\&\fBNote\fR: You can pass the optional arguments in mixed order. All the following statement work:
.PP
.Vb 5
\&   $content_ref = slurp ;   # open file in $_
\&   $content_ref = slurp \*(Aq/path/to/file\*(Aq;
\&   slurp \*(Aq/path/to/file\*(Aq, \e$content ;
\&   slurp \e$content, \*(Aq/path/to/file\*(Aq ;
\&   slurp \e$content ;
.Ve
.SH "GENERATING UNIQUE IDs"
.IX Header "GENERATING UNIQUE IDs"
The \f(CW\*(C`Tid\*(C'\fR, \f(CW\*(C`Lid\*(C'\fR and \f(CW\*(C`Uid\*(C'\fR functions return an unique ID string useful to name temporary files, or use for other purposes.
.SS "Tid ( [options] )"
.IX Subsection "Tid ( [options] )"
This function returns a temporary ID valid for the current process only. Different temporarily-unique strings are granted to be unique for the current process only ($$)
.SS "Lid ( [options] )"
.IX Subsection "Lid ( [options] )"
This function returns a local ID valid for the local host only. Different locally-unique strings are granted to be unique when generated by the same local host
.SS "Uid ( [options] )"
.IX Subsection "Uid ( [options] )"
This function returns an universal ID. Different universally-unique strings are granted to be unique also when generated by different hosts. Use this function if you have more than one machine generating the IDs for the same context. This function includes the host IP number in the id algorithm.
.SS "*id options"
.IX Subsection "*id options"
The above functions accept an optional hash of named arguments:
.IP chars 4
.IX Item "chars"
You can specify the set of characters used to generate the uniquid string. You have the following options:
.RS 4
.IP "chars => 'base34'" 4
.IX Item "chars => 'base34'"
uses [1..9, 'A'..'N', 'P'..'Z']. No lowercase chars, no number 0 no capital 'o'. Useful to avoid human mistakes when the id may be represented by non-electronical means (e.g. communicated by voice or read from paper). This is the default (used if you don't specify any chars option).
.IP "chars => 'base62'" 4
.IX Item "chars => 'base62'"
Uses \f(CW\*(C`[0..9, \*(Aqa\*(Aq..\*(Aqz\*(Aq, \*(AqA\*(Aq..\*(AqZ\*(Aq]\*(C'\fR. This option tries to generate shorter ids.
.IP "chars => \e@chars" 4
.IX Item "chars => @chars"
Any reference to an array of arbitrary characters.
.RE
.RS 4
.RE
.IP separator 4
.IX Item "separator"
The character used to separate group of characters in the id. Default '_'.
.IP IP 4
.IX Item "IP"
Applies to \f(CW\*(C`Uid\*(C'\fR only. This option allows to pass the IP number used generating the universally-unique id. Use this option if you know what you are doing.
.PP
.Vb 8
\&   $ui = Tid                           # Q9MU1N_NVRM
\&   $ui = Lid                           # 2MS_Q9MU1N_P5F6
\&   $ui = Uid                           # MGJFSBTK_2MS_Q9MU1N_PWES
\&   $ui = Uid separator=>\*(Aq\-\*(Aq            # MGJFSBTK\-2DH\-Q9MU6H\-7Z1Y
\&   $ui = Tid chars=>\*(Aqbase62\*(Aq           # 1czScD_2h0v
\&   $ui = Lid chars=>\*(Aqbase62\*(Aq           # rq_1czScD_2jC1
\&   $ui = Uid chars=>\*(Aqbase62\*(Aq           # jQaB98R_rq_1czScD_2rqA
\&   $ui = Lid chars=>[ 0..9, \*(AqA\*(Aq..\*(AqF\*(Aq]  # 9F4_41AF2B34_62E76
.Ve
.SH "Minimal Markup Language (MML)"
.IX Header "Minimal Markup Language (MML)"
A lot of programmers use (\fIde facto\fR) a subset of canonical XML which is characterized by:
.PP
.Vb 8
\& No Attributes
\& No mixed Data and Element content
\& No Processing Instructions (PI)
\& No Document Type Declaration (DTD)
\& No non\-character entity\-references
\& No CDATA marked sections
\& Support for only UTF\-8 character encoding
\& No optional features
.Ve
.PP
That subset has no official standard, so in this description we will generically refer to it as 'Minimal Markup Language' or MML. Please, note that MML is just an unofficial and generic way to name that minimal XML subset, avoiding any possible MXML, SML, MinML, /.+ML$/ specificity.
.SS "MML advantages"
.IX Subsection "MML advantages"
If you need just to store configuration parameters and construct any perl data structure, MLM is all what you need. Using it instead full featured XML gives you a few very interesting advantages:
.IP \(bu 4
it is really simple to use/edit and understand also by any unskilled people
.IP \(bu 4
you can parse it with very lite, fast and simple RE, thus avoiding to load and execute several thousands of perl code needed to parse full featured XML
.IP \(bu 4
anyway any canonical XML parser will be able to parse it as well
.SS "About XML parsing and structure reduction"
.IX Subsection "About XML parsing and structure reduction"
The \f(CW\*(C`load_mml\*(C'\fR function produces perl structures exactly like other CPAN modules (e.g. XML::Simple, XML::Smart) but use the opposite approach. That modules usually require a canonical XML parser to achieve a full XML tree, then prune all the unwanted branches. That means thousands of line of code loaded and executed, and a potentially big structure to reduce, which probably is a waste of resources when you have just to deal with simple MML.
.PP
The \f(CW\*(C`load_mml\*(C'\fR uses just a few lines of recursive code, parsing MML with a simple RE. It builds up only the branches it needs, optionally ignoring all the unwanted nodes. That is exactly what you need for MML, but it is obviously completely inappropriate for full XML files (e.g. HTML) which use attributes and other features unsupported by MML.
.SS "load_mml ( MML [, options] )"
.IX Subsection "load_mml ( MML [, options] )"
This function parses the \fIMML\fR eventually using the \fIoptions\fR, and returns a perl structure reflecting the MML structure and any custom logic you may need (see "options"). It accepts one \fIMML\fR parameter that can be a reference to a SCALAR content, a path to a file or a reference to a filehandle.
.PP
This function accepts also a few \fIoptions\fR which could be passed as plain name=>value pairs or as a HASH reference.
.PP
\fIoptions\fR
.IX Subsection "options"
.PP
You can customize the process by setting a few option, which will allow you to gain \fBfull control\fR over the process and the resulting structure (see also the \fIt/05_load_mml.t\fR test file for a few examples):
.IP "optional => 0|1" 4
.IX Item "optional => 0|1"
Boolean. This option applies when the MML argument is a path to a file: a true value will not try to load a file that doesn't exists; a false value will croak on error. False by default.
.IP "strict => 1|0" 4
.IX Item "strict => 1|0"
Boolean. A true value will croak when any unsupported syntax is found, while a false value will quitely ignore unsupported syntax. Default true (strict).
.Sp
.Vb 7
\&   $strict_mml = \*(Aq<opt><a>01</a></opt>\*(Aq;
\&   $non_strict_mml = << \*(AqEOS\*(Aq;
\&   <opt>
\&       mixed content ignored
\&       <elem attr="ignored">01</elem>
\&   </opt>\*(Aq
\&   EOS
\&   
\&   $structA = load_mml \e$non_strict_mml ; # would croak
\&   $structB = load_mml \e$non_strict_mml, strict=>0 ;  # ok
.Ve
.IP "cache => 1|0" 4
.IX Item "cache => 1|0"
Boolean. if \fIMML\fR is a path, a true value will cache the mml structure in a global (persistent under mod_perl). \f(CW\*(C`load_mml\*(C'\fR will open and parse the file only the first time or if the file has been modified. If for any reason you don't want to cache the structure or  set this option to a false value. Default true (cached).
.Sp
\&\fBNote\fR: If you need to parse the same file with different options, (thus producing different structures) you must disable the \fIchache\fR. Also, when you have a lot of mml files with very simple structure the cache could slow down the parsing. Caching is convenient when you have complex or large structure and a few files.
.IP "markers => '<>'|'[]'|'{}'" 4
.IX Item "markers => '<>'|'[]'|'{}'"
Instead of using the canonical '<>' markers, you can use the \f(CW\*(C`[]\*(C'\fR or the \f(CW\*(C`{}\*(C'\fRnon standard markers. Your file will not be XML compliant anymore, anyway it may be very useful when the file content is composed by XML or HTML chunks, since you can avoid the escaping of '<' and '>'. Default standard XML markers '<>'.
.Sp
.Vb 5
\&   $mml = \*(Aq[opt][a]<a href="something">something</a>[/a][/opt]\*(Aq;
\&   $structA = load_mml \e$mml, markers => \*(Aq[]\*(Aq ;
\&   # $structA = {
\&   #              \*(Aqa\*(Aq => \*(Aq<a href="something">something</a>\*(Aq
\&   #            };
.Ve
.IP "keep_root => 0|1" 4
.IX Item "keep_root => 0|1"
Boolean. A true value will keep the root element, while a false value will strip the root. Default false (root stripped)
.Sp
.Vb 2
\&   $mml = \*(Aq<opt><a>01</a></opt>\*(Aq;
\&   $structA = load_mml \e$mml ;
\&   
\&   $$struct{a} eq \*(Aq01\*(Aq; # true
\&   
\&   # $structA = {
\&   #              \*(Aqa\*(Aq => \*(Aq01\*(Aq
\&   #            };
\&   
\&   $structB = load_mml \e$mml, keep_root=>1 ;
\&   
\&   $$struct{opt}{a} eq \*(Aq01\*(Aq; # true
\&   
\&   # $structB = {
\&   #              \*(Aqopt\*(Aq => {
\&   #                         \*(Aqa\*(Aq => \*(Aq01\*(Aq
\&   #                       }
\&   #            };
.Ve
.IP "filter => { id|re => CODE|'TRIM_BLANKS'|'ONE_LINE' }" 4
.IX Item "filter => { id|re => CODE|'TRIM_BLANKS'|'ONE_LINE' }"
This option allows to filter data from the MML to the structure. You must set it to an hash of id/filter. The key id can be the literal element id which content you want to filter, or any compiled RE you want to match against the id elements; the filter can be a CODE reference or the name of a couple of literal built-in filters: 'TRIM_BLANKS', 'ONE_LINE'.
.Sp
The referenced code will receive \fIid\fR, \fIdata_reference\fR and \fIactive_options_referece\fR as the arguments; besides for regexing convenience the data is aliased in \f(CW$_\fR.
.Sp
.Vb 10
\&   $mml = << \*(AqEOS\*(Aq;
\&   <opt>
\&      <foo>aaa</foo>
\&      <bar>bBB</bar>
\&      <baz>ZZz</baz>
\&      <multi_line>
\&        other
\&        data
\&      </multi_line>
\&      <other_stuff>something</other_stuff>
\&      <anything_else>not filtered</anything_else>
\&   </opt>
\&   EOS
\&   
\&   $struct = load_mml \e$mml, filter=>{ foo         => sub{uc},
\&                                       qr/^b/      => sub{lc},
\&                                       multi_line  => \*(AqTRIM_BLANKS\*(Aq,
\&                                       other_stuff => \e&my_filter
\&                                     };
\&   
\&   sub my_filter {
\&       my ($id, $data_ref, $opt) = @_ ;
\&       # $_ contains the actual data
\&       # so you could use it instead of $$data_ref
\&       ....
\&       # return $_ (if modified it with any s///)
\&       # or any arbitrarily modified data
\&       return \*(Aqsomething else\*(Aq;
\&   }
\&       
\&   # $struct = {
\&   #             \*(Aqfoo\*(Aq => \*(AqAAA\*(Aq, # it was \*(Aqaaa\*(Aq
\&   #             \*(Aqbar\*(Aq => \*(Aqbbb\*(Aq, # it was \*(AqbBB\*(Aq
\&   #             \*(Aqbaz\*(Aq => \*(Aqzzz\*(Aq, # it was \*(AqZZz\*(Aq
\&   #             \*(Aqmulti_line\*(Aq => "other\endata",  # it was "\en  other\en  data\en"
\&   #             \*(Aqother_stuff\*(Aq => \*(Aqsomething else\*(Aq, # it was \*(Aqsomething\*(Aq
\&   #             \*(Aqanything_else\*(Aq => \*(Aqnot filtered\*(Aq  # the same
\&   #           }
.Ve
.IP "handler => { id|re => CODE|'SPLIT_LINES' }" 4
.IX Item "handler => { id|re => CODE|'SPLIT_LINES' }"
This option allows you to execute any code during the parsing of the MML in order to change the returned structure or do any other task. It allows you to implement your own syntax, checks and executions, skip any branch, change the options of any child node, generate nodes or even objects to add to the returned structure.
.Sp
You must set it to an hash of id/handler. The key id can be the literal element id which content you want to handler, or any compiled RE you want to match against the id elements; the filter may be a CODE reference or the name of a literal built-in handler \f(CW\*(AqSPLIT_LINES\*(Aq\fR (an handler that splits the lines of the node into an array of elements: see the example below).
.Sp
The referenced CODE will be called instead the standard \f(CW\*(C`IO::Util::parse_mml\*(C'\fR handler, and will receive \fIid\fR, \fIdata_reference\fR and \fIactive_options_referece\fR as the arguments.
.Sp
It is expected to return the branch to add to the returned structure. If the referenced CODE needs to refers to the original branch structure, it could retrieve it by using \fBIO::Util::parse_mml()\fR.
.Sp
A few examples using this same MML string:
.Sp
.Vb 9
\&   $mml = << \*(AqEOS\*(Aq;
\&   <opt>
\&     <a>
\&        <b>Foo</b>
\&        <b>Bar</b>
\&     </a>
\&     <c>something</c>
\&   </opt>
\&   EOS
.Ve
.Sp
Regular parsing and structure:
.Sp
.Vb 1
\&   $struct = load_mml \e$mml # no options
\&   
\&   # $struct = {
\&   #             \*(Aqa\*(Aq => {
\&   #                      \*(Aqb\*(Aq => [
\&   #                               \*(AqFoo\*(Aq,
\&   #                               \*(AqBar\*(Aq
\&   #                             ]
\&   #                    },
\&   #             \*(Aqc\*(Aq => \*(Aqsomething\*(Aq
\&   #           } ;
.Ve
.Sp
Skip all the 'a' elements:
.Sp
.Vb 1
\&   $struct = load_mml \e$mml, handler=>{ a => sub{} } ; # just for \*(Aqa\*(Aq elements
\&                     
\&   # $struct = { \*(Aqc\*(Aq => \*(Aqsomething\*(Aq } ;
.Ve
.Sp
Folding an array:
.Sp
.Vb 1
\&   $struct = load_mml \e$mml, handler => { a => \e&a_handler } ; # just for \*(Aqa\*(Aq
\&
\&     
\&   sub a_handler {
\&       # get the original branch
\&       my $branch = IO::Util::parse_mml( @_ );
\&       $$branch{b} # [\*(AqFoo\*(Aq,\*(AqBar\*(Aq]
\&   }
\&   
\&   # $structB = {
\&   #              \*(Aqa\*(Aq => [
\&   #                       \*(AqFoo\*(Aq,
\&   #                       \*(AqBar\*(Aq
\&   #                     ],
\&   #              \*(Aqc\*(Aq => \*(Aqsomething\*(Aq
\&   #            } ;
.Ve
.Sp
You can also use the built-in handler 'SPLIT_LINES' and write a MML like this:
.Sp
.Vb 11
\&   $mml = << \*(AqEOS\*(Aq;
\&   <opt>
\&     <a>
\&        <b>
\&        Foo
\&        Bar
\&        </b>
\&     </a>
\&     <c>something</c>
\&   </opt>
\&   EOS
\&   
\&   $struct = load_mml \e$mml,
\&              handler=>{ b => \*(AqSPLIT_LINES },
\&              filter =>{ b => \*(AqTRIM_BLANKS\*(Aq }
\&   
\&   # $struct = {
\&   #             \*(Aqa\*(Aq => {
\&   #                      \*(Aqb\*(Aq => [
\&   #                               \*(AqFoo\*(Aq,
\&   #                               \*(AqBar\*(Aq
\&   #                             ]
\&   #                    },
\&   #             \*(Aqc\*(Aq => \*(Aqsomething\*(Aq
\&   #           } ;
.Ve
.SS "parse_mml (id, MML [, options])"
.IX Subsection "parse_mml (id, MML [, options])"
Used internally and eventually by any handler, in order to parse any \fIMML\fR chunk and return its branch structure. It requires the element \fIid\fR, the reference to the \fIMML\fR chunk, eventually accepting the options hash reference to use for the branch.
.PP
\&\fBNote\fR: You can escape any character (specially < and >) by using the backslash '\e'. XML comments can be added to the MML and will be ignored by the parser.
.SH "SUPPORT and FEEDBACK"
.IX Header "SUPPORT and FEEDBACK"
If you need support or if you want just to send me some feedback or request, please use this link: http://perl.4pro.net/?IO::Util.
.SH "AUTHOR and COPYRIGHT"
.IX Header "AUTHOR and COPYRIGHT"
© 2004\-2005 by Domizio Demichelis.
.PP
All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 829:" 4
.IX Item "Around line 829:"
Non-ASCII character seen before =encoding in '©'. Assuming CP1252
