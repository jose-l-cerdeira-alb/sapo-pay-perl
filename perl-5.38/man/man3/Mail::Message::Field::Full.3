.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::Message::Field::Full 3"
.TH Mail::Message::Field::Full 3 2023-12-11 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Mail::Message::Field::Full \- construct one smart line in a message header
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 3
\& Mail::Message::Field::Full
\&   is a Mail::Message::Field
\&   is a Mail::Reporter
\&
\& Mail::Message::Field::Full is extended by
\&   Mail::Message::Field::Structured
\&   Mail::Message::Field::Unstructured
.Ve
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& # Getting to understand the complexity of a header field ...
\&
\& my $fast = $msg\->head\->get(\*(Aqsubject\*(Aq);
\& my $full = Mail::Message::Field::Full\->from($fast);
\&
\& my $full = $msg\->head\->get(\*(Aqsubject\*(Aq)\->study;  # same
\& my $full = $msg\->head\->study(\*(Aqsubject\*(Aq);       # same
\& my $full = $msg\->study(\*(Aqsubject\*(Aq);             # same
\&
\& # ... or build a complex header field yourself
\&
\& my $f = Mail::Message::Field::Full\->new(\*(AqTo\*(Aq);
\& my $f = Mail::Message::Field::Full\->new(\*(AqSubject: hi!\*(Aq);
\& my $f = Mail::Message::Field::Full\->new(Subject => \*(Aqhi!\*(Aq);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is the \fIfull\fR implementation of a header field: it has \fIfull\fR
understanding of all predefined header fields.  These objects will be
quite slow, because header fields can be very complex.  Of course, this
class delivers the optimal result, but for a quite large penalty in
performance and memory consumption.  Are you willing to accept?
.PP
This class supports the common header description from RFC2822 (formerly
RFC822), the extensions with respect to character set encodings as specified
in RFC2047, and the extensions on language specification and long parameter
wrapping from RFC2231.  If you do not need the latter two, then the
Mail::Message::Field::Fast and Mail::Message::Field::Flex
are enough for your application.
.PP
Extends "DESCRIPTION" in Mail::Message::Field.
.SH OVERLOADED
.IX Header "OVERLOADED"
Extends "OVERLOADED" in Mail::Message::Field.
.IP "overload: \fB""""\fR" 4
.IX Item "overload: """""
Inherited, see "OVERLOADED" in Mail::Message::Field
.IP "overload: \fB0+\fR" 4
.IX Item "overload: 0+"
Inherited, see "OVERLOADED" in Mail::Message::Field
.IP "overload: \fB<=\fR>" 4
.IX Item "overload: <=>"
Inherited, see "OVERLOADED" in Mail::Message::Field
.IP "overload: \fBbool\fR" 4
.IX Item "overload: bool"
Inherited, see "OVERLOADED" in Mail::Message::Field
.IP "overload: \fBcmp\fR" 4
.IX Item "overload: cmp"
Inherited, see "OVERLOADED" in Mail::Message::Field
.IP "overload: \fBstringification\fR" 4
.IX Item "overload: stringification"
In string context, the decoded body is returned, as if \fBdecodedBody()\fR
would have been called.
.SH METHODS
.IX Header "METHODS"
Extends "METHODS" in Mail::Message::Field.
.SS Constructors
.IX Subsection "Constructors"
Extends "Constructors" in Mail::Message::Field.
.ie n .IP $obj\->\fBclone\fR() 4
.el .IP \f(CW$obj\fR\->\fBclone\fR() 4
.IX Item "$obj->clone()"
Inherited, see "Constructors" in Mail::Message::Field
.ie n .IP "Mail::Message::Field::Full\->\fBfrom\fR($field, %options)" 4
.el .IP "Mail::Message::Field::Full\->\fBfrom\fR($field, \f(CW%options\fR)" 4
.IX Item "Mail::Message::Field::Full->from($field, %options)"
Convert any \f(CW$field\fR (a Mail::Message::Field object) into a new
Mail::Message::Field::Full object.  This conversion is done the hard
way: the string which is produced by the original object is parsed
again.  Usually, the string which is parsed is exactly the line (or lines)
as found in the original input source, which is a good thing because Full
fields are much more careful with the actual content.
.Sp
\&\f(CW%options\fR are passed to the constructor (see \fBnew()\fR).  In any case, some
extensions of this Full field class is returned.  It depends on which
field is created what kind of class we get.
.Sp
example:
.Sp
.Vb 2
\& my $fast = $msg\->head\->get(\*(Aqsubject\*(Aq);
\& my $full = Mail::Message::Field::Full\->from($fast);
\&
\& my $full = $msg\->head\->get(\*(Aqsubject\*(Aq)\->study;  # same
\& my $full = $msg\->head\->study(\*(Aqsubject\*(Aq);       # same
\& my $full = $msg\->get(\*(Aqsubject\*(Aq);               # same
.Ve
.IP Mail::Message::Field::Full\->\fBnew\fR($data) 4
.IX Item "Mail::Message::Field::Full->new($data)"
Creating a new field object the correct way is a lot of work, because
there is so much freedom in the RFCs, but at the same time so many
restrictions.  Most fields are implemented, but if you have your own
field (and do no want to contribute it to MailBox), then simply call
new on your own package.
.Sp
You have the choice to instantiate the object as string or in prepared
parts:
.RS 4
.IP \(bu 4
\&\fBnew\fR LINE, OPTIONS
.Sp
Pass a LINE as it could be found in a file: a (possibly folded) line
which is terminated by a new-line.
.IP \(bu 4
\&\fBnew\fR NAME, [BODY], OPTIONS
.Sp
A set of values which shape the line.
.RE
.RS 4
.Sp
The NAME is a wellformed header name (you may use \fBwellformedName()\fR) to
be sure about the casing.  The BODY is a string, one object, or an
ref-array of objects.  In case of objects, they must fit to the
constructor of the field: the types which are accepted may differ.
The optional ATTRIBUTE list contains Mail::Message::Field::Attribute
objects.  Finally, there are some OPTIONS.
.Sp
.Vb 7
\& \-Option  \-\-Defined in     \-\-Default
\&  charset                    undef
\&  encoding                   \*(Aqq\*(Aq
\&  force                      false
\&  language                   undef
\&  log       Mail::Reporter   \*(AqWARNINGS\*(Aq
\&  trace     Mail::Reporter   \*(AqWARNINGS\*(Aq
.Ve
.IP "charset => STRING" 2
.IX Item "charset => STRING"
The body is specified in utf8, and must become 7\-bits ascii to be
transmited.  Specify a charset to which the multi-byte utf8 is converted
before it gets encoded.  See \fBencode()\fR, which does the job.
.IP "encoding => 'q'|'Q'|'b'|'B'" 2
.IX Item "encoding => 'q'|'Q'|'b'|'B'"
Non-ascii characters are encoded using Quoted-Printable ('q' or 'Q') or
Base64 ('b' or 'B') encoding.
.IP "force => BOOLEAN" 2
.IX Item "force => BOOLEAN"
Enforce encoding in the specified charset, even when it is not needed
because the body does not contain any non-ascii characters.
.IP "language => STRING" 2
.IX Item "language => STRING"
The language used can be specified, however is rarely used my mail clients.
.IP "log => LEVEL" 2
.IX Item "log => LEVEL"
.PD 0
.IP "trace => LEVEL" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.PD
.Sp
example:
.Sp
.Vb 2
\& my $s = Mail::Message::Field::Full\->new(\*(AqSubject: Hello World\*(Aq);
\& my $s = Mail::Message::Field::Full\->new(\*(AqSubject\*(Aq, \*(AqHello World\*(Aq);
\&
\& my @attrs   = (Mail::Message::Field::Attribute\->new(...), ...);
\& my @options = (extra => \*(Aqthe color blue\*(Aq);
\& my $t = Mail::Message::Field::Full\->new(To => \e@addrs, @attrs, @options);
.Ve
.RE
.SS "The field"
.IX Subsection "The field"
Extends "The field" in Mail::Message::Field.
.ie n .IP $obj\->\fBisStructured\fR() 4
.el .IP \f(CW$obj\fR\->\fBisStructured\fR() 4
.IX Item "$obj->isStructured()"
.PD 0
.IP Mail::Message::Field::Full\->\fBisStructured\fR() 4
.IX Item "Mail::Message::Field::Full->isStructured()"
.PD
Inherited, see "The field" in Mail::Message::Field
.ie n .IP $obj\->\fBlength\fR() 4
.el .IP \f(CW$obj\fR\->\fBlength\fR() 4
.IX Item "$obj->length()"
Inherited, see "The field" in Mail::Message::Field
.ie n .IP $obj\->\fBnrLines\fR() 4
.el .IP \f(CW$obj\fR\->\fBnrLines\fR() 4
.IX Item "$obj->nrLines()"
Inherited, see "The field" in Mail::Message::Field
.ie n .IP "$obj\->\fBprint\fR( [$fh] )" 4
.el .IP "\f(CW$obj\fR\->\fBprint\fR( [$fh] )" 4
.IX Item "$obj->print( [$fh] )"
Inherited, see "The field" in Mail::Message::Field
.ie n .IP $obj\->\fBsize\fR() 4
.el .IP \f(CW$obj\fR\->\fBsize\fR() 4
.IX Item "$obj->size()"
Inherited, see "The field" in Mail::Message::Field
.ie n .IP "$obj\->\fBstring\fR( [$wrap] )" 4
.el .IP "\f(CW$obj\fR\->\fBstring\fR( [$wrap] )" 4
.IX Item "$obj->string( [$wrap] )"
Inherited, see "The field" in Mail::Message::Field
.ie n .IP $obj\->\fBtoDisclose\fR() 4
.el .IP \f(CW$obj\fR\->\fBtoDisclose\fR() 4
.IX Item "$obj->toDisclose()"
Inherited, see "The field" in Mail::Message::Field
.SS "Access to the name"
.IX Subsection "Access to the name"
Extends "Access to the name" in Mail::Message::Field.
.ie n .IP $obj\->\fBName\fR() 4
.el .IP \f(CW$obj\fR\->\fBName\fR() 4
.IX Item "$obj->Name()"
Inherited, see "Access to the name" in Mail::Message::Field
.ie n .IP $obj\->\fBname\fR() 4
.el .IP \f(CW$obj\fR\->\fBname\fR() 4
.IX Item "$obj->name()"
Inherited, see "Access to the name" in Mail::Message::Field
.ie n .IP "$obj\->\fBwellformedName\fR( [STRING] )" 4
.el .IP "\f(CW$obj\fR\->\fBwellformedName\fR( [STRING] )" 4
.IX Item "$obj->wellformedName( [STRING] )"
Inherited, see "Access to the name" in Mail::Message::Field
.SS "Access to the body"
.IX Subsection "Access to the body"
Extends "Access to the body" in Mail::Message::Field.
.ie n .IP $obj\->\fBbody\fR() 4
.el .IP \f(CW$obj\fR\->\fBbody\fR() 4
.IX Item "$obj->body()"
Inherited, see "Access to the body" in Mail::Message::Field
.ie n .IP $obj\->\fBdecodedBody\fR(%options) 4
.el .IP \f(CW$obj\fR\->\fBdecodedBody\fR(%options) 4
.IX Item "$obj->decodedBody(%options)"
Returns the unfolded body of the field, where encodings are resolved.  The
returned line will still contain comments and such.  The \f(CW%options\fR are passed
to the decoder, see \fBdecode()\fR.
.Sp
BE WARNED: if the field is a structured field, the content may change syntax,
because of encapsulated special characters.  By default, the body is decoded
as text, which results in a small difference within comments as well
(read the RFC).
.ie n .IP $obj\->\fBfolded\fR() 4
.el .IP \f(CW$obj\fR\->\fBfolded\fR() 4
.IX Item "$obj->folded()"
Inherited, see "Access to the body" in Mail::Message::Field
.ie n .IP "$obj\->\fBfoldedBody\fR( [$body] )" 4
.el .IP "\f(CW$obj\fR\->\fBfoldedBody\fR( [$body] )" 4
.IX Item "$obj->foldedBody( [$body] )"
Inherited, see "Access to the body" in Mail::Message::Field
.ie n .IP "$obj\->\fBstripCFWS\fR( [STRING] )" 4
.el .IP "\f(CW$obj\fR\->\fBstripCFWS\fR( [STRING] )" 4
.IX Item "$obj->stripCFWS( [STRING] )"
.PD 0
.IP "Mail::Message::Field::Full\->\fBstripCFWS\fR( [STRING] )" 4
.IX Item "Mail::Message::Field::Full->stripCFWS( [STRING] )"
.PD
Inherited, see "Access to the body" in Mail::Message::Field
.ie n .IP "$obj\->\fBunfoldedBody\fR( [$body, [$wrap]] )" 4
.el .IP "\f(CW$obj\fR\->\fBunfoldedBody\fR( [$body, [$wrap]] )" 4
.IX Item "$obj->unfoldedBody( [$body, [$wrap]] )"
Inherited, see "Access to the body" in Mail::Message::Field
.SS "Access to the content"
.IX Subsection "Access to the content"
Extends "Access to the content" in Mail::Message::Field.
.ie n .IP $obj\->\fBaddresses\fR() 4
.el .IP \f(CW$obj\fR\->\fBaddresses\fR() 4
.IX Item "$obj->addresses()"
Inherited, see "Access to the content" in Mail::Message::Field
.ie n .IP "$obj\->\fBattribute\fR( $name, [$value] )" 4
.el .IP "\f(CW$obj\fR\->\fBattribute\fR( \f(CW$name\fR, [$value] )" 4
.IX Item "$obj->attribute( $name, [$value] )"
Inherited, see "Access to the content" in Mail::Message::Field
.ie n .IP $obj\->\fBattributes\fR() 4
.el .IP \f(CW$obj\fR\->\fBattributes\fR() 4
.IX Item "$obj->attributes()"
Inherited, see "Access to the content" in Mail::Message::Field
.ie n .IP $obj\->\fBbeautify\fR() 4
.el .IP \f(CW$obj\fR\->\fBbeautify\fR() 4
.IX Item "$obj->beautify()"
For structured header fields, this removes the original encoding of the
field's body (the format as it was offered to \fBparse()\fR), therefore the
next request for the field will have to re-produce the read data clean
and nice.  For unstructured bodies, this method doesn't do a thing.
.ie n .IP "$obj\->\fBcomment\fR( [STRING] )" 4
.el .IP "\f(CW$obj\fR\->\fBcomment\fR( [STRING] )" 4
.IX Item "$obj->comment( [STRING] )"
Inherited, see "Access to the content" in Mail::Message::Field
.ie n .IP "$obj\->\fBcreateComment\fR(STRING, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBcreateComment\fR(STRING, \f(CW%options\fR)" 4
.IX Item "$obj->createComment(STRING, %options)"
.PD 0
.ie n .IP "Mail::Message::Field::Full\->\fBcreateComment\fR(STRING, %options)" 4
.el .IP "Mail::Message::Field::Full\->\fBcreateComment\fR(STRING, \f(CW%options\fR)" 4
.IX Item "Mail::Message::Field::Full->createComment(STRING, %options)"
.PD
Create a comment to become part in a field.  Comments are automatically
included within parenthesis.  Matching pairs of parenthesis are
permitted within the STRING.  When a non-matching parenthesis are used,
it is only permitted with an escape (a backslash) in front of them.
These backslashes will be added automatically if needed (don't worry!).
Backslashes will stay, except at the end, where it will be doubled.
.Sp
The \f(CW%options\fR are \f(CW\*(C`charset\*(C'\fR, \f(CW\*(C`language\*(C'\fR, and \f(CW\*(C`encoding\*(C'\fR as always.
The created comment is returned.
.ie n .IP "$obj\->\fBcreatePhrase\fR(STRING, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBcreatePhrase\fR(STRING, \f(CW%options\fR)" 4
.IX Item "$obj->createPhrase(STRING, %options)"
.PD 0
.ie n .IP "Mail::Message::Field::Full\->\fBcreatePhrase\fR(STRING, %options)" 4
.el .IP "Mail::Message::Field::Full\->\fBcreatePhrase\fR(STRING, \f(CW%options\fR)" 4
.IX Item "Mail::Message::Field::Full->createPhrase(STRING, %options)"
.PD
A phrase is a text which plays a well defined role.  This is the main
difference with comments, which have do specified meaning.  Some special
characters in the phrase will cause it to be surrounded with double
quotes: do not specify them yourself.
.Sp
The \f(CW%options\fR are \f(CW\*(C`charset\*(C'\fR, \f(CW\*(C`language\*(C'\fR, and \f(CW\*(C`encoding\*(C'\fR, as always.
.ie n .IP $obj\->\fBstudy\fR() 4
.el .IP \f(CW$obj\fR\->\fBstudy\fR() 4
.IX Item "$obj->study()"
Inherited, see "Access to the content" in Mail::Message::Field
.ie n .IP "$obj\->\fBtoDate\fR( [$time] )" 4
.el .IP "\f(CW$obj\fR\->\fBtoDate\fR( [$time] )" 4
.IX Item "$obj->toDate( [$time] )"
.PD 0
.IP "Mail::Message::Field::Full\->\fBtoDate\fR( [$time] )" 4
.IX Item "Mail::Message::Field::Full->toDate( [$time] )"
.PD
Inherited, see "Access to the content" in Mail::Message::Field
.ie n .IP $obj\->\fBtoInt\fR() 4
.el .IP \f(CW$obj\fR\->\fBtoInt\fR() 4
.IX Item "$obj->toInt()"
Inherited, see "Access to the content" in Mail::Message::Field
.SS "Other methods"
.IX Subsection "Other methods"
Extends "Other methods" in Mail::Message::Field.
.ie n .IP $obj\->\fBdateToTimestamp\fR(STRING) 4
.el .IP \f(CW$obj\fR\->\fBdateToTimestamp\fR(STRING) 4
.IX Item "$obj->dateToTimestamp(STRING)"
.PD 0
.IP Mail::Message::Field::Full\->\fBdateToTimestamp\fR(STRING) 4
.IX Item "Mail::Message::Field::Full->dateToTimestamp(STRING)"
.PD
Inherited, see "Other methods" in Mail::Message::Field
.SS Internals
.IX Subsection "Internals"
Extends "Internals" in Mail::Message::Field.
.ie n .IP "$obj\->\fBconsume\fR( $line | <$name,<$body|$objects>> )" 4
.el .IP "\f(CW$obj\fR\->\fBconsume\fR( \f(CW$line\fR | <$name,<$body|$objects>> )" 4
.IX Item "$obj->consume( $line | <$name,<$body|$objects>> )"
Inherited, see "Internals" in Mail::Message::Field
.ie n .IP "$obj\->\fBdecode\fR(STRING, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBdecode\fR(STRING, \f(CW%options\fR)" 4
.IX Item "$obj->decode(STRING, %options)"
.PD 0
.ie n .IP "Mail::Message::Field::Full\->\fBdecode\fR(STRING, %options)" 4
.el .IP "Mail::Message::Field::Full\->\fBdecode\fR(STRING, \f(CW%options\fR)" 4
.IX Item "Mail::Message::Field::Full->decode(STRING, %options)"
.PD
Decode field encoded STRING to an utf8 string.  The input STRING is part of
a header field, and as such, may contain encoded words in \f(CW\*(C`=?...?.?...?=\*(C'\fR
format defined by RFC2047.  The STRING may contain multiple encoded parts,
maybe using different character sets.
.Sp
Be warned:  you MUST first interpret the field into parts, like phrases and
comments, and then decode each part separately, otherwise the decoded text
may interfere with your markup characters.
.Sp
Be warned: language information, which is defined in RFC2231, is ignored.
.Sp
Encodings with unknown charsets are left untouched [requires v2.085,
otherwise croaked].  Unknown characters within an charset are replaced by
a '?'.
.Sp
.Vb 2
\& \-Option \-\-Default
\&  is_text  1
.Ve
.RS 4
.IP "is_text => BOOLEAN" 2
.IX Item "is_text => BOOLEAN"
Encoding on text is slightly more complicated than encoding structured data,
because it contains blanks.  Visible blanks have to be ignored between two
encoded words in the text, but not when an encoded word follows or precedes
an unencoded word.  Phrases and comments are texts.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\& print Mail::Message::Field::Full\->decode(\*(Aq=?iso\-8859\-1?Q?J=F8rgen?=\*(Aq);
\&    # prints   JE<0slash>rgen
.Ve
.RE
.ie n .IP "$obj\->\fBdefaultWrapLength\fR( [$length] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultWrapLength\fR( [$length] )" 4
.IX Item "$obj->defaultWrapLength( [$length] )"
Inherited, see "Internals" in Mail::Message::Field
.ie n .IP "$obj\->\fBencode\fR(STRING, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBencode\fR(STRING, \f(CW%options\fR)" 4
.IX Item "$obj->encode(STRING, %options)"
Encode the (possibly utf8 encoded) STRING to a string which is acceptable
to the RFC2047 definition of a header: only containing us-ascii characters.
.Sp
.Vb 6
\& \-Option  \-\-Default
\&  charset   \*(Aqus\-ascii\*(Aq
\&  encoding  \*(Aqq\*(Aq
\&  force     <flase>
\&  language  undef
\&  name      undef
.Ve
.RS 4
.IP "charset => STRING" 2
.IX Item "charset => STRING"
STRING is an utf8 string which has to be translated into any byte-wise
character set for transport, because MIME-headers can only contain ascii
characters.
.IP "encoding => 'q'|'Q'|'b'|'B'" 2
.IX Item "encoding => 'q'|'Q'|'b'|'B'"
The character encoding to be used.  With \f(CW\*(C`q\*(C'\fR or \f(CW\*(C`Q\*(C'\fR, quoted-printable
encoding will be used.  With \f(CW\*(C`b \*(C'\fR or \f(CW\*(C`B \*(C'\fR, base64 encoding will be taken.
.IP "force => BOOLEAN" 2
.IX Item "force => BOOLEAN"
Encode the string, even when it only contains us-ascii characters.  By
default, this is off because it decreases readibility of the produced
header fields.
.IP "language => STRING" 2
.IX Item "language => STRING"
RFC2231 defines how to specify language encodings in encoded words.  The
STRING is a strandard iso language name.
.IP "name => STRING" 2
.IX Item "name => STRING"
[3.002] When the name of the field is given, the first encoded line will
be shorter.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBfold\fR( $name, $body, [$maxchars] )" 4
.el .IP "\f(CW$obj\fR\->\fBfold\fR( \f(CW$name\fR, \f(CW$body\fR, [$maxchars] )" 4
.IX Item "$obj->fold( $name, $body, [$maxchars] )"
.PD 0
.ie n .IP "Mail::Message::Field::Full\->\fBfold\fR( $name, $body, [$maxchars] )" 4
.el .IP "Mail::Message::Field::Full\->\fBfold\fR( \f(CW$name\fR, \f(CW$body\fR, [$maxchars] )" 4
.IX Item "Mail::Message::Field::Full->fold( $name, $body, [$maxchars] )"
.PD
Inherited, see "Internals" in Mail::Message::Field
.ie n .IP "$obj\->\fBsetWrapLength\fR( [$length] )" 4
.el .IP "\f(CW$obj\fR\->\fBsetWrapLength\fR( [$length] )" 4
.IX Item "$obj->setWrapLength( [$length] )"
Inherited, see "Internals" in Mail::Message::Field
.ie n .IP $obj\->\fBstringifyData\fR(STRING|ARRAY|$objects) 4
.el .IP \f(CW$obj\fR\->\fBstringifyData\fR(STRING|ARRAY|$objects) 4
.IX Item "$obj->stringifyData(STRING|ARRAY|$objects)"
Inherited, see "Internals" in Mail::Message::Field
.ie n .IP $obj\->\fBunfold\fR(STRING) 4
.el .IP \f(CW$obj\fR\->\fBunfold\fR(STRING) 4
.IX Item "$obj->unfold(STRING)"
Inherited, see "Internals" in Mail::Message::Field
.SS Parsing
.IX Subsection "Parsing"
You probably do not want to call these parsing methods yourself: use
the standard constructors (\fBnew()\fR) and it will be done for you.
.ie n .IP $obj\->\fBconsumeComment\fR(STRING) 4
.el .IP \f(CW$obj\fR\->\fBconsumeComment\fR(STRING) 4
.IX Item "$obj->consumeComment(STRING)"
.PD 0
.IP Mail::Message::Field::Full\->\fBconsumeComment\fR(STRING) 4
.IX Item "Mail::Message::Field::Full->consumeComment(STRING)"
.PD
Try to read a comment from the STRING.  When successful, the comment
without encapsulating parenthesis is returned, together with the rest
of the string.
.ie n .IP $obj\->\fBconsumeDotAtom\fR(STRING) 4
.el .IP \f(CW$obj\fR\->\fBconsumeDotAtom\fR(STRING) 4
.IX Item "$obj->consumeDotAtom(STRING)"
Returns three elemens: the atom-text, the rest string, and the
concatenated comments.  Both atom and comments can be undef.
.ie n .IP $obj\->\fBconsumePhrase\fR(STRING) 4
.el .IP \f(CW$obj\fR\->\fBconsumePhrase\fR(STRING) 4
.IX Item "$obj->consumePhrase(STRING)"
.PD 0
.IP Mail::Message::Field::Full\->\fBconsumePhrase\fR(STRING) 4
.IX Item "Mail::Message::Field::Full->consumePhrase(STRING)"
.PD
Take the STRING, and try to strip-off a valid phrase.  In the obsolete
phrase syntax, any sequence of words is accepted as phrase (as long as
certain special characters are not used).  RFC2822 is stricter: only
one word or a quoted string is allowed.  As always, the obsolete
syntax is accepted, and the new syntax is produced.
.Sp
This method returns two elements: the phrase (or undef) followed
by the resulting string.  The phrase will be removed from the optional
quotes.  Be warned that \f(CW""\fR will return an empty, valid phrase.
.Sp
example:
.Sp
.Vb 1
\& my ($phrase, $rest) = $field\->consumePhrase( q["hi!" <sales@example.com>] );
.Ve
.ie n .IP $obj\->\fBparse\fR(STRING) 4
.el .IP \f(CW$obj\fR\->\fBparse\fR(STRING) 4
.IX Item "$obj->parse(STRING)"
Get the detailed information from the STRING, and store the data found
in the field object.  The accepted input is very field type dependent.
Unstructured fields do no parsing whatsoever.
.ie n .IP $obj\->\fBproduceBody\fR() 4
.el .IP \f(CW$obj\fR\->\fBproduceBody\fR() 4
.IX Item "$obj->produceBody()"
Produce the text for the field, based on the information stored within the
field object.
.Sp
Usually, you wish the exact same line as was found in the input source
of a message.  But when you have created a field yourself, it should get
formatted.  You may call \fBbeautify()\fR on a preformatted field to enforce
a call to this method when the field is needed later.
.SS "Error handling"
.IX Subsection "Error handling"
Extends "Error handling" in Mail::Message::Field.
.ie n .IP $obj\->\fBAUTOLOAD\fR() 4
.el .IP \f(CW$obj\fR\->\fBAUTOLOAD\fR() 4
.IX Item "$obj->AUTOLOAD()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBaddReport\fR($object) 4
.el .IP \f(CW$obj\fR\->\fBaddReport\fR($object) 4
.IX Item "$obj->addReport($object)"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "$obj->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD 0
.ie n .IP "Mail::Message::Field::Full\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "Mail::Message::Field::Full\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "Mail::Message::Field::Full->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBerrors\fR() 4
.el .IP \f(CW$obj\fR\->\fBerrors\fR() 4
.IX Item "$obj->errors()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR( [$level, [$strings]] )" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "$obj->log( [$level, [$strings]] )"
.PD 0
.IP "Mail::Message::Field::Full\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "Mail::Message::Field::Full->log( [$level, [$strings]] )"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBlogPriority\fR($level) 4
.el .IP \f(CW$obj\fR\->\fBlogPriority\fR($level) 4
.IX Item "$obj->logPriority($level)"
.PD 0
.IP Mail::Message::Field::Full\->\fBlogPriority\fR($level) 4
.IX Item "Mail::Message::Field::Full->logPriority($level)"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBlogSettings\fR() 4
.el .IP \f(CW$obj\fR\->\fBlogSettings\fR() 4
.IX Item "$obj->logSettings()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBnotImplemented\fR() 4
.el .IP \f(CW$obj\fR\->\fBnotImplemented\fR() 4
.IX Item "$obj->notImplemented()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR( [$level] )" 4
.IX Item "$obj->report( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR( [$level] )" 4
.IX Item "$obj->reportAll( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR( [$level] )" 4
.IX Item "$obj->trace( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBwarnings\fR() 4
.el .IP \f(CW$obj\fR\->\fBwarnings\fR() 4
.IX Item "$obj->warnings()"
Inherited, see "Error handling" in Mail::Reporter
.SS Cleanup
.IX Subsection "Cleanup"
Extends "Cleanup" in Mail::Message::Field.
.ie n .IP $obj\->\fBDESTROY\fR() 4
.el .IP \f(CW$obj\fR\->\fBDESTROY\fR() 4
.IX Item "$obj->DESTROY()"
Inherited, see "Cleanup" in Mail::Reporter
.SH DETAILS
.IX Header "DETAILS"
Extends "DETAILS" in Mail::Message::Field.
.SH DIAGNOSTICS
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: Field content is not numerical: $content" 4
.el .IP "Warning: Field content is not numerical: \f(CW$content\fR" 4
.IX Item "Warning: Field content is not numerical: $content"
The numeric value of a field is requested (for instance the \f(CW\*(C`Lines\*(C'\fR or
\&\f(CW\*(C`Content\-Length\*(C'\fR fields should be numerical), however the data contains
weird characters.
.ie n .IP "Error: Field name too long (max $length), in '$name'" 4
.el .IP "Error: Field name too long (max \f(CW$length\fR), in '$name'" 4
.IX Item "Error: Field name too long (max $length), in '$name'"
It is not specified in the RFCs how long a field name can be, but
at least it should be a few characters shorter than the line wrap.
.IP "Warning: Illegal character in charset '$charset'" 4
.IX Item "Warning: Illegal character in charset '$charset'"
The field is created with an utf8 string which only contains data from the
specified character set.  However, that character set can never be a valid
name because it contains characters which are not permitted.
.ie n .IP "Warning: Illegal character in field name $name" 4
.el .IP "Warning: Illegal character in field name \f(CW$name\fR" 4
.IX Item "Warning: Illegal character in field name $name"
A new field is being created which does contain characters not permitted
by the RFCs.  Using this field in messages may break other e\-mail clients
or transfer agents, and therefore mutulate or extinguish your message.
.IP "Warning: Illegal character in language '$lang'" 4
.IX Item "Warning: Illegal character in language '$lang'"
The field is created with data which is specified to be in a certain language,
however, the name of the language cannot be valid: it contains characters
which are not permitted by the RFCs.
.IP "Warning: Illegal encoding '$encoding', used 'q'" 4
.IX Item "Warning: Illegal encoding '$encoding', used 'q'"
The RFCs only permit base64 (\f(CW\*(C`b \*(C'\fR or \f(CW\*(C`B \*(C'\fR) or quoted-printable
(\f(CW\*(C`q\*(C'\fR or \f(CW\*(C`Q\*(C'\fR) encoding.  Other than these four options are illegal.
.ie n .IP "Error: Package $package does not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR does not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package does not implement $method."
Fatal error: the specific package (or one of its superclasses) does not
implement this method where it should. This message means that some other
related classes do implement this method however the class at hand does
not.  Probably you should investigate this and probably inform the author
of the package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Message distribution version 3.015,
built on December 11, 2023. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH LICENSE
.IX Header "LICENSE"
Copyrights 2001\-2023 by [Mark Overmeer <markov@cpan.org>]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
