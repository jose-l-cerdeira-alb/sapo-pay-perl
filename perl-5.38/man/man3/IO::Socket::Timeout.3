.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Socket::Timeout 3"
.TH IO::Socket::Timeout 3 2015-09-29 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
IO::Socket::Timeout \- IO::Socket with read/write timeout
.SH VERSION
.IX Header "VERSION"
version 0.32
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use IO::Socket::Timeout;
\&
\&  # creates a standard IO::Socket::INET object, with a connection timeout
\&  my $socket = IO::Socket::INET\->new( Timeout => 2 );
\&  # enable read and write timeouts on the socket
\&  IO::Socket::Timeout\->enable_timeouts_on($socket);
\&  # setup the timeouts
\&  $socket\->read_timeout(0.5);
\&  $socket\->write_timeout(0.5);
\&
\&  # When using the socket:
\&  use Errno qw(ETIMEDOUT EWOULDBLOCK);
\&  print $socket "some request";
\&  my $response = <$socket>;
\&  if (! $response && ( 0+$! == ETIMEDOUT || 0+$! == EWOULDBLOCK )) {
\&    die "timeout reading on the socket";
\&  }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\f(CW\*(C`IO::Socket\*(C'\fR provides a way to set a timeout on the socket, but the timeout
will be used only for connection, not for reading / writing operations.
.PP
This module provides a way to set a timeout on read / write operations on an
\&\f(CW\*(C`IO::Socket\*(C'\fR instance, or any \f(CW\*(C`IO::Socket::*\*(C'\fR modules, like
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR.
.SH "CLASS METHOD"
.IX Header "CLASS METHOD"
.SS enable_timeouts_on
.IX Subsection "enable_timeouts_on"
.Vb 1
\&  IO::Socket::Timeout\->enable_timeouts_on($socket);
.Ve
.PP
Given a socket, it'll return it, but will enable read and write timeouts on it.
You'll have to use \f(CW\*(C`read_timeout\*(C'\fR and \f(CW\*(C`write_timeout\*(C'\fR on it later on.
.PP
Returns the socket, so that you can chain this method with others.
.PP
If the argument is \f(CW\*(C`undef\*(C'\fR, the method simply returns empty list.
.SH METHODS
.IX Header "METHODS"
These methods are to be called on a socket that has been previously passed to
\&\f(CWenable_timeouts_on()\fR.
.SS read_timeout
.IX Subsection "read_timeout"
.Vb 2
\&  my $current_timeout = $socket\->read_timeout();
\&  $socket\->read_timeout($new_timeout);
.Ve
.PP
Get or set the read timeout value for a socket created with this module.
.SS write_timeout
.IX Subsection "write_timeout"
.Vb 2
\&  my $current_timeout = $socket\->write_timeout();
\&  $socket\->write_timeout($new_timeout);
.Ve
.PP
Get or set the write timeout value for a socket created with this module.
.SS disable_timeout
.IX Subsection "disable_timeout"
.Vb 1
\&  $socket\->disable_timeout;
.Ve
.PP
Disable the read and write timeouts for a socket created with this module.
.SS enable_timeout
.IX Subsection "enable_timeout"
.Vb 1
\&  $socket\->enable_timeout;
.Ve
.PP
Re-enable the read and write timeouts for a socket created with this module.
.SS timeout_enabled
.IX Subsection "timeout_enabled"
.Vb 2
\&  my $is_timeout_enabled = $socket\->timeout_enabled();
\&  $socket\->timeout_enabled(0);
.Ve
.PP
Get or Set the fact that a socket has timeouts enabled.
.SH "WHEN TIMEOUT IS HIT"
.IX Header "WHEN TIMEOUT IS HIT"
When a timeout (read, write) is hit on the socket, the function trying to be
performed will return \f(CW\*(C`undef\*(C'\fR or empty string, and \f(CW$!\fR will be set to
\&\f(CW\*(C`ETIMEOUT\*(C'\fR or \f(CW\*(C`EWOULDBLOCK\*(C'\fR. You should test for both.
.PP
You can import \f(CW\*(C`ETIMEOUT\*(C'\fR and \f(CW\*(C`EWOULDBLOCK\*(C'\fR by using \f(CW\*(C`POSIX\*(C'\fR:
.PP
.Vb 1
\&  use Errno qw(ETIMEDOUT EWOULDBLOCK);
.Ve
.SH "IF YOU NEED TO RETRY"
.IX Header "IF YOU NEED TO RETRY"
If you want to implement a try / wait / retry mechanism, I recommend using a
third-party module, like \f(CW\*(C`Action::Retry\*(C'\fR. Something like this:
.PP
.Vb 1
\&  my $socket;
\&
\&  my $action = Action::Retry\->new(
\&    attempt_code => sub {
\&        # (re\-)create the socket if needed
\&        if (! $socket) {
\&          $socket = IO::Socket\->new(...);
\&          IO::Socket::Timeout\->enable_timeouts_on($socket);
\&          $socket\->read_timeout(0.5);
\&        }
\&        # send the request, read the answer
\&        $socket\->print($_[0]);
\&        defined(my $answer = $socket\->getline)
\&          or $socket = undef, die $!;
\&        $answer;
\&    },
\&    on_failure_code => sub { die \*(Aqaborting, to many retries\*(Aq },
\&  );
\&
\&  my $reply = $action\->run(\*(AqGET mykey\*(Aq);
.Ve
.SH "IMPORT options"
.IX Header "IMPORT options"
You can give a list of socket modules names when use-ing this module, so that
internally, composed classes needed gets created and loaded at compile time.
.PP
.Vb 1
\&  use IO::Socket::Timeout qw(IO::Socket::INET);
.Ve
.SH "ENVIRONMENT VARIABLE"
.IX Header "ENVIRONMENT VARIABLE"
.SS PERL_IO_SOCKET_TIMEOUT_FORCE_SELECT
.IX Subsection "PERL_IO_SOCKET_TIMEOUT_FORCE_SELECT"
This module implements timeouts using one of two strategies. If possible (if
the operating system is linux, freebsd or mac), it uses \f(CWsetsockopt()\fR to set
read / write timeouts. Otherwise it uses \f(CWselect()\fR before performing socket
operations.
.PP
To force the use of \f(CWselect()\fR, you can set
PERL_IO_SOCKET_TIMEOUT_FORCE_SELECT to a true value at compile time (typically
in a BEGIN block)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Action::Retry, IO::Select, PerlIO::via::Timeout, Time::Out
.SH THANKS
.IX Header "THANKS"
Thanks to Vincent Pitt, Christian Hansen and Toby Inkster for various help and
useful remarks.
.SH AUTHOR
.IX Header "AUTHOR"
Damien "dams" Krotkine
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Damien "dams" Krotkine.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
