.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mail::Box::Parser 3"
.TH Mail::Box::Parser 3 2023-12-11 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Mail::Box::Parser \- reading and writing messages
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 2
\& Mail::Box::Parser
\&   is a Mail::Reporter
\&
\& Mail::Box::Parser is extended by
\&   Mail::Box::Parser::C
\&   Mail::Box::Parser::Perl
.Ve
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& # Not instatiatiated itself
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
The \f(CW\*(C`Mail::Box::Parser\*(C'\fR manages the parsing of folders.  Usually, you won't
need to know anything about this module, except the options which are
involved with this code.
.PP
There are two implementations of this module planned:
.IP \(bu 4
Mail::Box::Parser::Perl
.Sp
A slower parser which only uses plain Perl.  This module is a bit slower,
and does less checking and less recovery.
.IP \(bu 4
Mail::Box::Parser::C
.Sp
A fast parser written in \f(CW\*(C`C\*(C'\fR.  This package is released as separate
module on CPAN, because the module distribution via CPAN can not
handle XS files which are not located in the root directory of the
module tree.  If a C compiler is available on your system, it will be
used automatically.
.PP
Extends "DESCRIPTION" in Mail::Reporter.
.SH METHODS
.IX Header "METHODS"
Extends "METHODS" in Mail::Reporter.
.SS Constructors
.IX Subsection "Constructors"
Extends "Constructors" in Mail::Reporter.
.IP Mail::Box::Parser\->\fBnew\fR(%options) 4
.IX Item "Mail::Box::Parser->new(%options)"
Create a parser object which can handle one file.  For
mbox-like mailboxes, this object can be used to read a whole folder.  In
case of MH-like mailboxes, each message is contained in a single file,
so each message has its own parser object.
.Sp
.Vb 6
\& \-Option  \-\-Defined in     \-\-Default
\&  file                       undef
\&  filename                   <required>
\&  log       Mail::Reporter   \*(AqWARNINGS\*(Aq
\&  mode                       \*(Aqr\*(Aq
\&  trace     Mail::Reporter   \*(AqWARNINGS\*(Aq
.Ve
.RS 4
.IP "file => FILE-HANDLE" 2
.IX Item "file => FILE-HANDLE"
Any \f(CW\*(C`IO::File\*(C'\fR or \f(CW\*(C`GLOB\*(C'\fR which can be used to read the data from.  In
case this option is specified, the \f(CW\*(C`filename\*(C'\fR is informational only.
.IP "filename => FILENAME" 2
.IX Item "filename => FILENAME"
The name of the file to be read.
.IP "log => LEVEL" 2
.IX Item "log => LEVEL"
.PD 0
.IP "mode => OPENMODE" 2
.IX Item "mode => OPENMODE"
.PD
File-open mode, which defaults to \f(CW\*(Aqr\*(Aq\fR, which means `read\-only'.
See \f(CW\*(C`perldoc \-f open\*(C'\fR for possible modes.  Only applicable 
when no \f(CW\*(C`file\*(C'\fR is specified.
.IP "trace => LEVEL" 2
.IX Item "trace => LEVEL"
.RE
.RS 4
.RE
.SS "The parser"
.IX Subsection "The parser"
.PD 0
.ie n .IP $obj\->\fBfileChanged\fR() 4
.el .IP \f(CW$obj\fR\->\fBfileChanged\fR() 4
.IX Item "$obj->fileChanged()"
.PD
Returns whether the file which is parsed has changed after the last
time \fBtakeFileInfo()\fR was called.
.ie n .IP $obj\->\fBfilename\fR() 4
.el .IP \f(CW$obj\fR\->\fBfilename\fR() 4
.IX Item "$obj->filename()"
Returns the name of the file this parser is working on.
.ie n .IP $obj\->\fBrestart\fR() 4
.el .IP \f(CW$obj\fR\->\fBrestart\fR() 4
.IX Item "$obj->restart()"
Restart the parser on a certain file, usually because the content has
changed.
.ie n .IP $obj\->\fBstart\fR(%options) 4
.el .IP \f(CW$obj\fR\->\fBstart\fR(%options) 4
.IX Item "$obj->start(%options)"
Start the parser by opening a file.
.Sp
.Vb 2
\& \-Option\-\-Default
\&  file    undef
.Ve
.RS 4
.IP "file => FILEHANDLE|undef" 2
.IX Item "file => FILEHANDLE|undef"
The file is already open, for instance because the data must be read
from STDIN.
.RE
.RS 4
.RE
.ie n .IP $obj\->\fBstop\fR() 4
.el .IP \f(CW$obj\fR\->\fBstop\fR() 4
.IX Item "$obj->stop()"
Stop the parser, which will include a close of the file.  The lock on the
folder will not be removed (is not the responsibility of the parser).
.SS Parsing
.IX Subsection "Parsing"
.ie n .IP "$obj\->\fBbodyAsFile\fR( $fh [$chars, [$lines]] )" 4
.el .IP "\f(CW$obj\fR\->\fBbodyAsFile\fR( \f(CW$fh\fR [$chars, [$lines]] )" 4
.IX Item "$obj->bodyAsFile( $fh [$chars, [$lines]] )"
Try to read one message-body from the file, and immediately write
it to the specified file-handle.  Optionally, the predicted number
of CHARacterS and/or \f(CW$lines\fR to be read can be supplied.  These values may be
\&\f(CW\*(C`undef\*(C'\fR and may be wrong.
.Sp
The return is a list of three scalars: the location of the body (begin
and end) and the number of lines in the body.
.ie n .IP "$obj\->\fBbodyAsList\fR( [$chars, [$lines]] )" 4
.el .IP "\f(CW$obj\fR\->\fBbodyAsList\fR( [$chars, [$lines]] )" 4
.IX Item "$obj->bodyAsList( [$chars, [$lines]] )"
Try to read one message-body from the file.  Optionally, the predicted number
of CHARacterS and/or \f(CW$lines\fR to be read can be supplied.  These values may be
\&\f(CW\*(C`undef\*(C'\fR and may be wrong.
.Sp
The return is a list of scalars, each containing one line (including
line terminator), preceded by two integers representing the location
in the file where this body started and ended.
.ie n .IP "$obj\->\fBbodyAsString\fR( [$chars, [$lines]] )" 4
.el .IP "\f(CW$obj\fR\->\fBbodyAsString\fR( [$chars, [$lines]] )" 4
.IX Item "$obj->bodyAsString( [$chars, [$lines]] )"
Try to read one message-body from the file.  Optionally, the predicted number
of CHARacterS and/or \f(CW$lines\fR to be read can be supplied.  These values may be
\&\f(CW\*(C`undef\*(C'\fR and may be wrong.
.Sp
The return is a list of three scalars, the location in the file
where the body starts, where the body ends, and the string containing the
whole body.
.ie n .IP "$obj\->\fBbodyDelayed\fR( [$chars, [$lines]] )" 4
.el .IP "\f(CW$obj\fR\->\fBbodyDelayed\fR( [$chars, [$lines]] )" 4
.IX Item "$obj->bodyDelayed( [$chars, [$lines]] )"
Try to read one message-body from the file, but the data is skipped.
Optionally, the predicted number of CHARacterS and/or \f(CW$lines\fR to be skipped
can be supplied.  These values may be \f(CW\*(C`undef\*(C'\fR and may be wrong.
.Sp
The return is a list of four scalars: the location of the body (begin and
end), the size of the body, and the number of lines in the body.  The
number of lines may be \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$obj\->\fBfilePosition\fR( [$position] )" 4
.el .IP "\f(CW$obj\fR\->\fBfilePosition\fR( [$position] )" 4
.IX Item "$obj->filePosition( [$position] )"
Returns the location of the next byte to be used in the file which is
parsed.  When a \f(CW$position\fR is specified, the location in the file is
moved to the indicated spot first.
.ie n .IP $obj\->\fBlineSeparator\fR() 4
.el .IP \f(CW$obj\fR\->\fBlineSeparator\fR() 4
.IX Item "$obj->lineSeparator()"
Returns the character or characters which are used to separate lines
in the folder file.  This is based on the first line of the file.
UNIX systems use a single LF to separate lines.  Windows uses a CR and
a LF.  Mac uses CR.
.ie n .IP $obj\->\fBpopSeparator\fR() 4
.el .IP \f(CW$obj\fR\->\fBpopSeparator\fR() 4
.IX Item "$obj->popSeparator()"
Remove the last-pushed separator from the list which is maintained by the
parser.  This will return \f(CW\*(C`undef\*(C'\fR when there is none left.
.ie n .IP $obj\->\fBpushSeparator\fR(STRING|Regexp) 4
.el .IP \f(CW$obj\fR\->\fBpushSeparator\fR(STRING|Regexp) 4
.IX Item "$obj->pushSeparator(STRING|Regexp)"
Add a boundary line.  Separators tell the parser where to stop reading.
A famous separator is the \f(CW\*(C`From\*(C'\fR\-line, which is used in Mbox-like
folders to separate messages.  But also parts (\fIattachments\fR) is a
message are divided by separators.
.Sp
The specified STRING describes the start of the separator-line.  The
Regexp can specify a more complicated format.
.ie n .IP $obj\->\fBreadHeader\fR() 4
.el .IP \f(CW$obj\fR\->\fBreadHeader\fR() 4
.IX Item "$obj->readHeader()"
Read the whole message-header and return it as list of field-value
pairs.  Mind that some fields will appear more than once.
.Sp
The first element will represent the position in the file where the
header starts.  The follows the list of header field names and bodies.
.Sp
example:
.Sp
.Vb 1
\& my ($where, @header) = $parser\->readHeader;
.Ve
.ie n .IP $obj\->\fBreadSeparator\fR(%options) 4
.el .IP \f(CW$obj\fR\->\fBreadSeparator\fR(%options) 4
.IX Item "$obj->readSeparator(%options)"
Read the currently active separator (the last one which was pushed).  The
line (or \f(CW\*(C`undef\*(C'\fR) is returned.  Blank-lines before the separator lines
are ignored.
.Sp
The return are two scalars, where the first gives the location of the
separator in the file, and the second the line which is found as
separator.  A new separator is activated using \fBpushSeparator()\fR.
.SS Internals
.IX Subsection "Internals"
.ie n .IP $obj\->\fBcloseFile\fR() 4
.el .IP \f(CW$obj\fR\->\fBcloseFile\fR() 4
.IX Item "$obj->closeFile()"
Close the file which was being parsed.
.ie n .IP "$obj\->\fBdefaultParserType\fR( [$class] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultParserType\fR( [$class] )" 4
.IX Item "$obj->defaultParserType( [$class] )"
.PD 0
.IP "Mail::Box::Parser\->\fBdefaultParserType\fR( [$class] )" 4
.IX Item "Mail::Box::Parser->defaultParserType( [$class] )"
.PD
Returns the parser to be used to parse all subsequent
messages, possibly first setting the parser using the optional argument.
Usually, the parser is autodetected; the \f(CW\*(C`C\*(C'\fR\-based parser will be used
when it can be, and the Perl-based parser will be used otherwise.
.Sp
The \f(CW$class\fR argument allows you to specify a package name to force a
particular parser to be used (such as your own custom parser). You have
to \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR the package yourself before calling this method
with an argument. The parser must be a sub-class of \f(CW\*(C`Mail::Box::Parser\*(C'\fR.
.ie n .IP $obj\->\fBopenFile\fR($args) 4
.el .IP \f(CW$obj\fR\->\fBopenFile\fR($args) 4
.IX Item "$obj->openFile($args)"
Open the file to be parsed.  \f(CW$args\fR is a ref-hash of options.
.Sp
.Vb 3
\& \-Option  \-\-Default
\&  filename  <required>
\&  mode      <required>
.Ve
.RS 4
.IP "filename => FILENAME" 2
.IX Item "filename => FILENAME"
.PD 0
.IP "mode => STRING" 2
.IX Item "mode => STRING"
.RE
.RS 4
.RE
.ie n .IP $obj\->\fBtakeFileInfo\fR() 4
.el .IP \f(CW$obj\fR\->\fBtakeFileInfo\fR() 4
.IX Item "$obj->takeFileInfo()"
.PD
Capture some data about the file being parsed, to be compared later.
.SS "Error handling"
.IX Subsection "Error handling"
Extends "Error handling" in Mail::Reporter.
.ie n .IP $obj\->\fBAUTOLOAD\fR() 4
.el .IP \f(CW$obj\fR\->\fBAUTOLOAD\fR() 4
.IX Item "$obj->AUTOLOAD()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBaddReport\fR($object) 4
.el .IP \f(CW$obj\fR\->\fBaddReport\fR($object) 4
.IX Item "$obj->addReport($object)"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "\f(CW$obj\fR\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "$obj->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD 0
.ie n .IP "Mail::Box::Parser\->\fBdefaultTrace\fR( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )" 4
.el .IP "Mail::Box::Parser\->\fBdefaultTrace\fR( [$level]|[$loglevel, \f(CW$tracelevel\fR]|[$level, \f(CW$callback\fR] )" 4
.IX Item "Mail::Box::Parser->defaultTrace( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBerrors\fR() 4
.el .IP \f(CW$obj\fR\->\fBerrors\fR() 4
.IX Item "$obj->errors()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBlog\fR( [$level, [$strings]] )" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "$obj->log( [$level, [$strings]] )"
.PD 0
.IP "Mail::Box::Parser\->\fBlog\fR( [$level, [$strings]] )" 4
.IX Item "Mail::Box::Parser->log( [$level, [$strings]] )"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBlogPriority\fR($level) 4
.el .IP \f(CW$obj\fR\->\fBlogPriority\fR($level) 4
.IX Item "$obj->logPriority($level)"
.PD 0
.IP Mail::Box::Parser\->\fBlogPriority\fR($level) 4
.IX Item "Mail::Box::Parser->logPriority($level)"
.PD
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBlogSettings\fR() 4
.el .IP \f(CW$obj\fR\->\fBlogSettings\fR() 4
.IX Item "$obj->logSettings()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBnotImplemented\fR() 4
.el .IP \f(CW$obj\fR\->\fBnotImplemented\fR() 4
.IX Item "$obj->notImplemented()"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBreport\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreport\fR( [$level] )" 4
.IX Item "$obj->report( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBreportAll\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR( [$level] )" 4
.IX Item "$obj->reportAll( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP "$obj\->\fBtrace\fR( [$level] )" 4
.el .IP "\f(CW$obj\fR\->\fBtrace\fR( [$level] )" 4
.IX Item "$obj->trace( [$level] )"
Inherited, see "Error handling" in Mail::Reporter
.ie n .IP $obj\->\fBwarnings\fR() 4
.el .IP \f(CW$obj\fR\->\fBwarnings\fR() 4
.IX Item "$obj->warnings()"
Inherited, see "Error handling" in Mail::Reporter
.SS Cleanup
.IX Subsection "Cleanup"
Extends "Cleanup" in Mail::Reporter.
.ie n .IP $obj\->\fBDESTROY\fR() 4
.el .IP \f(CW$obj\fR\->\fBDESTROY\fR() 4
.IX Item "$obj->DESTROY()"
Inherited, see "Cleanup" in Mail::Reporter
.SH DIAGNOSTICS
.IX Header "DIAGNOSTICS"
.ie n .IP "Warning: File $filename changed during access." 4
.el .IP "Warning: File \f(CW$filename\fR changed during access." 4
.IX Item "Warning: File $filename changed during access."
When a message parser starts working, it takes size and modification time
of the file at hand.  If the folder is written, it checks whether there
were changes in the file made by external programs.
.Sp
Calling \fBMail::Box::update()\fR on a folder before it being closed
will read these new messages.  But the real source of this problem is
locking: some external program (for instance the mail transfer agent,
like sendmail) uses a different locking mechanism as you do and therefore
violates your rights.
.IP "Error: Filename or handle required to create a parser." 4
.IX Item "Error: Filename or handle required to create a parser."
A message parser needs to know the source of the message at creation.  These
sources can be a filename (string), file handle object or GLOB.
See new(filename) and new(file).
.ie n .IP "Error: Package $package does not implement $method." 4
.el .IP "Error: Package \f(CW$package\fR does not implement \f(CW$method\fR." 4
.IX Item "Error: Package $package does not implement $method."
Fatal error: the specific package (or one of its superclasses) does not
implement this method where it should. This message means that some other
related classes do implement this method however the class at hand does
not.  Probably you should investigate this and probably inform the author
of the package.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Mail-Message distribution version 3.015,
built on December 11, 2023. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH LICENSE
.IX Header "LICENSE"
Copyrights 2001\-2023 by [Mark Overmeer <markov@cpan.org>]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
