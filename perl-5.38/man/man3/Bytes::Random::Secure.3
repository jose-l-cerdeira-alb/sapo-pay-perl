.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bytes::Random::Secure 3"
.TH Bytes::Random::Secure 3 2015-07-13 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Bytes::Random::Secure \- Perl extension to generate cryptographically\-secure
random bytes.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 3
\&    use Bytes::Random::Secure qw(
\&        random_bytes random_bytes_base64 random_bytes_hex
\&    );
\&
\&    my $bytes = random_bytes(32); # A string of 32 random bytes.
\&
\&    my $bytes = random_string_from( \*(Aqabcde\*(Aq, 10 ); # 10 random a,b,c,d, and e\*(Aqs.
\&
\&    my $bytes_as_base64 = random_bytes_base64(57); # Base64 encoded rand bytes.
\&
\&    my $bytes_as_hex = random_bytes_hex(8); # Eight random bytes as hex digits.
\&
\&    my $bytes_as_quoted_printable = random_bytes_qp(100); # QP encoded bytes.
\&
\&
\&    my $random = Bytes::Random::Secure\->new(
\&        Bits        => 64,
\&        NonBlocking => 1,
\&    ); # Seed with 64 bits, and use /dev/urandom (or other non\-blocking).
\&
\&    my $bytes = $random\->bytes(32); # A string of 32 random bytes.
\&    my $long  = $random\->irand;     # 32\-bit random integer.
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Bytes::Random::Secure provides two interfaces for obtaining crypto-quality
random bytes.  The simple interface is built around plain functions.  For
greater control over the Random Number Generator's seeding, there is an Object
Oriented interface that provides much more flexibility.
.PP
The "functions" interface provides functions that can be used any time you need
a string of a specific number of random bytes.  The random bytes are available
as simple strings, or as hex-digits, Quoted Printable, or MIME Base64.  There
are equivalent methods available from the OO interface, plus a few others.
.PP
This module can be a drop-in replacement for Bytes::Random, with the primary
enhancement of using a cryptographic-quality random number generator to create
the random data.  The \f(CW\*(C`random_bytes\*(C'\fR function emulates the user interface of
Bytes::Random's function by the same name.  But with Bytes::Random::Secure
the random number generator comes from Math::Random::ISAAC, and is suitable
for cryptographic purposes.  The harder problem to solve is how to seed the
generator.  This module uses Crypt::Random::Seed to generate the initial
seeds for Math::Random::ISAAC.
.PP
In addition to providing \f(CWrandom_bytes()\fR, this module also provides several
functions not found in Bytes::Random: \f(CW\*(C`random_string_from\*(C'\fR,
\&\f(CWrandom_bytes_base64()\fR, \f(CW\*(C`random_bytes_hex\*(C'\fR, and \f(CW\*(C`random_bytes_qp\*(C'\fR.
.PP
And finally, for those who need finer control over how Crypt::Random::Seed
generates its seed, there is an object oriented interface with a constructor
that facilitates configuring the seeding process, while providing methods that
do everything the "functions" interface can do (truth be told, the functions
interface is just a thin wrapper around the OO version, with some sane defaults
selected).  The OO interface also provides an \f(CW\*(C`irand\*(C'\fR method, not available
through the functions interface.
.SH RATIONALE
.IX Header "RATIONALE"
There are many uses for cryptographic quality randomness.  This module aims to
provide a generalized tool that can fit into many applications while providing
a minimal dependency chain, and a user interface that is simple.  You're free
to come up with your own use-cases, but there are several obvious ones:
.IP \(bu 4
Creating temporary passphrases (\f(CWrandom_string_from()\fR).
.IP \(bu 4
Generating per-account random salt to be hashed along with passphrases 
(and stored alongside them) to prevent rainbow table attacks.
.IP \(bu 4
Generating a secret that can be hashed along with a cookie's session
content to prevent cookie forgeries.
.IP \(bu 4
Building raw cryptographic-quality pseudo-random data sets for testing
or sampling.
.IP \(bu 4
Feeding secure key-gen utilities.
.PP
Why use this module?  This module employs several well-designed CPAN tools to
first generate a strong random seed, and then to instantiate a high quality
random number generator based on the seed.  The code in this module really
just glues together the building blocks.  However, it has taken a good deal of
research to come up with what I feel is a strong tool-chain that isn't going to
fall back to a weak state on some systems.  The interface is designed with
simplicity in mind, to minimize the potential for misconfiguration.
.SH EXPORTS
.IX Header "EXPORTS"
By default \f(CW\*(C`random_bytes\*(C'\fR is the only function exported.  Optionally
\&\f(CW\*(C`random_string_from\*(C'\fR, \f(CW\*(C`random_bytes_base64\*(C'\fR, \f(CW\*(C`random_bytes_hex\*(C'\fR,
and \f(CW\*(C`random_bytes_qp\*(C'\fR may be exported.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
The \fBfunctions interface\fR seeds the ISAAC generator on first use with a 256 bit
seed that uses Crypt::Random::Seed's default configuration as a strong random
seed source.
.SS random_bytes
.IX Subsection "random_bytes"
.Vb 1
\&    my $random_bytes = random_bytes( 512 );
.Ve
.PP
Returns a string containing as many random bytes as requested.  Obviously the
string isn't useful for display, as it can contain any byte value from 0 through
255.
.PP
The parameter is a byte-count, and must be an integer greater or equal to zero.
.SS random_string_from
.IX Subsection "random_string_from"
.Vb 2
\&    my $random_bytes = random_string_from( $bag, $length );
\&    my $random_bytes = random_string_from( \*(Aqabc\*(Aq, 50 );
.Ve
.PP
\&\f(CW$bag\fR is a string of characters from which \f(CW\*(C`random_string_from\*(C'\fR may choose in
building a random string.  We call it a 'bag', because it's permissible to have
repeated chars in the bag (if not, we could call it a set).  Repeated digits
get more weight.  For example, \f(CW\*(C`random_string_from( \*(Aqaab\*(Aq, 1 )\*(C'\fR would have a
66.67% chance of returning an 'a', and a 33.33% chance of returning a 'b'.  For
unweighted distribution, ensure there are no duplicates in \f(CW$bag\fR.
.PP
This \fIisn't\fR a "draw and discard", or a permutation algorithm; each character
selected is independent of previous or subsequent selections; duplicate
selections are possible by design.
.PP
Return value is a string of size \f(CW$length\fR, of characters chosen at random
from the 'bag' string.
.PP
It is perfectly legal to pass a Unicode string as the "bag", and in that case,
the yield will include Unicode characters selected from those passed in via the
bag string.
.PP
This function is useful for random string generation such as temporary
random passwords.
.SS random_bytes_base64
.IX Subsection "random_bytes_base64"
.Vb 2
\&    my $random_bytes_b64           = random_bytes_base64( $num_bytes );
\&    my $random_bytes_b64_formatted = random_bytes_base64( $num_bytes, $eol );
.Ve
.PP
Returns a MIME Base64 encoding of a string of \f(CW$number_of_bytes\fR random bytes.
Note, it should be obvious, but is worth mentioning that a base64 encoding of
base256 data requires more digits to represent the bytes requested.  The actual
number of digits required, including padding is \f(CW4(n/3)\fR.
Furthermore, the Base64 standard is to add padding to the end of any string for
which \f(CW\*(C`length % 57\*(C'\fR is a non-zero value.
.PP
If an \f(CW$eol\fR is specified, the character(s) specified will be used as line
delimiters after every 76th character.  The default is \f(CW\*(C`qq{\en}\*(C'\fR.  If you wish
to eliminate line-break insertions, specify an empty string: \f(CW\*(C`q{}\*(C'\fR.
.SS random_bytes_hex
.IX Subsection "random_bytes_hex"
.Vb 1
\&    my $random_bytes_as_hex = random_bytes_hex( $num_bytes );
.Ve
.PP
Returns a string of hex digits representing the string of \f(CW$number_of_bytes\fR
random bytes.
.PP
It's worth mentioning that a hex (base16) representation of base256 data
requires two digits for every byte requested. So
\&\f(CW\*(C`length( random_bytes_hex( 16 ) )\*(C'\fR will return 32, as it takes 32 hex digits to
represent 16 bytes.  Simple stuff, but better to mention it now than forget and
set a database field that's too narrow.
.SS random_bytes_qp
.IX Subsection "random_bytes_qp"
.Vb 2
\&    my $random_bytes_qp           = random_bytes_qp( $num_bytes );
\&    my $random_bytes_qp_formatted = random_bytes_qp( $num_bytes, $eol );
.Ve
.PP
Produces a string of \f(CW$num_bytes\fR random bytes, using MIME Quoted Printable
encoding (as produced by MIME::QuotedPrint's \f(CW\*(C`encode_qp\*(C'\fR function.  The
default configuration uses \f(CW\*(C`\en\*(C'\fR as a line break after every 76 characters, and
the "binmode" setting is used to guarantee a lossless round trip.  If no line
break is wanted, pass an empty string as \f(CW$eol\fR.
.SH METHODS
.IX Header "METHODS"
The \fBObject Oriented interface\fR provides methods that mirror the "functions"
interface.  However, the OO interface offers the advantage that the user can
control how many bits of entropy are used in seeding, and even how
Crypt::Random::Seed is configured.
.SS new
.IX Subsection "new"
.Vb 2
\&    my $random = Bytes::Random::Secure\->new( Bits => 512 );
\&    my $bytes  = $random\->bytes( 32 );
.Ve
.PP
The constructor is used to specify how the ISAAC generator is seeded.  Future
versions may also allow for alternate CSPRNGs to be selected.  If no parameters
are passed the default configuration specifies 256 bits for the seed.  The rest
of the default configuration accepts the Crypt::Random::Seed defaults, which
favor the strongest operating system provided entropy source, which in many
cases may be "blocking".
.PP
\fICONSTRUCTOR PARAMETERS\fR
.IX Subsection "CONSTRUCTOR PARAMETERS"
.PP
Bits
.IX Subsection "Bits"
.PP
.Vb 1
\&    my $random = Bytes::Random::Secure\->new( Bits => 128 );
.Ve
.PP
The \f(CW\*(C`Bits\*(C'\fR parameter specifies how many bits (rounded up to nearest multiple of
32) will be used in seeding the ISAAC random number generator.  The default is
256 bits of entropy.  But in some cases it may not be necessary, or even wise to
pull so many bits of entropy out of \f(CW\*(C`/dev/random\*(C'\fR (a blocking source).
.PP
Any value between 64 and 8192 will be accepted. If an out-of-range value is
specified, or a value that is not a multiple of 32, a warning will be generated
and the parameter will be rounded up to the nearest multiple of 32 within the
range of 64 through 8192 bits.  So if 16384 is specified, you will get 8192.  If
33 is specified, you will get 64.
.PP
\&\fBNote:\fR In the Perlish spirit of "\fIno arbitrary limits\fR", the maximum number
of bits this module accepts is 8192, which is the maximum number that ISAAC can
utilize.  But just because you \fIcan\fR specify a seed of 8192 bits doesn't mean
you ought to, much less need to.  And if you do, you probably want to use the
\&\f(CW\*(C`NonBlocking\*(C'\fR option, discussed below.  8192 bits is a lot to ask from a
blocking source such as \f(CW\*(C`/dev/random\*(C'\fR, and really anything beyond 512 bits in
the seed is probably wasteful.
.PP
PRNG
.IX Subsection "PRNG"
.PP
Reserved for future use.  Eventually the user will be able to select other RNGs
aside from Math::Random::ISAAC.
.PP
Unique
.IX Subsection "Unique"
.PP
Reserved for future use.
.PP
Other Crypt::Random::Seed Configuration Parameters
.IX Subsection "Other Crypt::Random::Seed Configuration Parameters"
.PP
For additional seeding control, refer to the POD for Crypt::Random::Seed.
By supplying a Crypt::Random::Seed parameter to Bytes::Random::Secure's
constructor, it will be passed through to Crypt::Random::Seed.  For example:
.PP
.Vb 1
\&    my $random = Bytes::Random::Secure\->new( NonBlocking => 1, Bits => 64 );
.Ve
.PP
In this example, \f(CW\*(C`Bits\*(C'\fR is used internally, while \f(CW\*(C`NonBlocking\*(C'\fR is passed
through to Crypt::Random::Seed.
.SS bytes
.IX Subsection "bytes"
.Vb 1
\&    my $random_bytes = $random\->bytes(1024);
.Ve
.PP
This works just like the \f(CW\*(C`random_bytes\*(C'\fR function.
.SS string_from
.IX Subsection "string_from"
.Vb 1
\&    my $random_string = $random\->string_from( \*(Aqabcdefg\*(Aq, 10 );
.Ve
.PP
Just like \f(CW\*(C`random_string_from\*(C'\fR: Returns a string of random octets selected
from the "Bag" string (in this case ten octets from 'abcdefg').
.SS bytes_hex
.IX Subsection "bytes_hex"
.Vb 1
\&    my $random_hex = $random\->bytes_hex(12);
.Ve
.PP
Identical in function to \f(CW\*(C`random_bytes_hex\*(C'\fR.
.SS bytes_base64
.IX Subsection "bytes_base64"
.Vb 1
\&    my $random_base64 = $random\->bytes_base64( 32, EOL => "\en" );
.Ve
.PP
Identical in function to \f(CW\*(C`random_bytes_base64\*(C'\fR.
.SS bytes_qp
.IX Subsection "bytes_qp"
.Vb 1
\&    my $random_qp = $random\->bytes_qp( 80 );
.Ve
.PP
You guessed it: Identical in function to \f(CW\*(C`random_bytes_qp\*(C'\fR.
.SS irand
.IX Subsection "irand"
.Vb 1
\&    my $unsigned_long = $random\->irand;
.Ve
.PP
Returns a random 32\-bit unsigned integer.  The value will satisfy
\&\f(CW\*(C`0 <= x <= 2**32\-1\*(C'\fR.  This functionality is only available through the OO
interface.
.SS shuffle
.IX Subsection "shuffle"
.Vb 1
\&    my $aref_shuffled = $random\->shuffle($aref);
.Ve
.PP
Shuffles the contents of a reference to an array in sitiu, and returns
the same reference.
.PP
List::Util, which ships with Perl, includes \f(CW\*(C`shuffle\*(C'\fR function. But that
function is flawed in two ways. First, from a cryptographic standpoint,
it uses Perl's \f(CW\*(C`rand\*(C'\fR, which is not a CSPRNG, and therefore is inadequate.
.PP
Second, because Perl's rand has an internal state of just 32 bits, it cannot
possibly generate all permutations of arrays containing 13 or more elements.
.PP
This module's \f(CW\*(C`shuffle\*(C'\fR uses a CSPRNG, and also benefits from large seeds
and a huge internal state. ISAAC can be seeded with up to 8192 bits, yielding
2^8192 possible initial states, and 2^8288 possible internal states. A seed of
8192 bits will assure that for arrays of up to 966 elements every permutation
is accessible.
.SH CONFIGURATION
.IX Header "CONFIGURATION"
Bytes::Random::Secure's interface tries to \fIkeep it simple\fR.  There is
generally nothing to configure.  This design, eliminates much of the  potential
for diminishing the quality of the random byte stream through misconfiguration.
The ISAAC algorithm is used as our factory, seeded with a strong source.
.PP
There may be times when the default seed characteristics carry too heavy a
burden on system resources.  The default seed for the functions interface is
256 bits of entropy taken from /dev/random (a blocking source on many systems),
or via API calls on Windows.  The default seed size for the OO interface is also
256 bits. If /dev/random should become depleted at the time that this module
attempts to seed the ISAAC generator, there could be delay while additional
system entropy is generated.  If this is a problem, it is possible to override
the default seeding characteristics using the OO interface instead of the
functions interface.  However, under most circumstances, this capability may be
safely ignored.
.PP
Beginning with Bytes::Random::Secure version 0.20, Crypt::Random::Seed
provides our strong seed (previously it was Crypt::Random::Source).  This module
gives us excellent "strong source" failsafe behavior, while keeping the
non-core dependencies to a bare minimum.  Best of all, it performs well across
a wide variety of platforms, and is compatible with Perl versions back through
5.6.0.
.PP
And as mentioned earlier in this document, there may be circumstances where
the performance of the operating system's strong random source is prohibitive
from using the module's default seeding configuration.  Use the OO interface
instead, and read the documentation for Crypt::Random::Seed to learn what
options are available.
.PP
Prior to version 0.20, a heavy dependency chain was required for reliably
and securely seeding the ISAAC generator.  Earlier versions required
Crypt::Random::Source, which in turn required Any::Moose.  Thanks to Dana
Jacobsen's new Crypt::Random::Seed module, this situation has been resolved.
So if you're looking for a secure random bytes solution that "just works"
portably, and on Perl versions as far back as 5.6.0, you've come to the right
place.  Users of older versions of this module are encouraged to update to
version 0.20 or higher to benefit from the improved user interface and lighter
dependency chain.
.SS "OPTIONAL (RECOMMENDED) DEPENDENCY"
.IX Subsection "OPTIONAL (RECOMMENDED) DEPENDENCY"
If performance is a consideration, you may also install 
Math::Random::ISAAC::XS. Bytes::Random::Secure's random number generator 
uses Math::Random::ISAAC.  That module implements the ISAAC algorithm in pure
Perl.  However, if you install Math::Random::ISAAC::XS, you
get the same algorithm implemented in C/XS, which will provide better
performance.  If you need to produce your random bytes more quickly, simply
installing Math::Random::ISAAC::XS will result in it automatically being used,
and a pretty good performance improvement will coincide.
.SH CAVEATS
.IX Header "CAVEATS"
.SS "FORK AND THREAD SAFETY"
.IX Subsection "FORK AND THREAD SAFETY"
When programming for parallel computation, avoid the "functions" interface \fBdo\fR
use the Object Oriented interface, and create a unique \f(CW\*(C`Bytes::Random::Secure\*(C'\fR 
object within each process or thread.  Bytes::Random::Secure uses
a CSPRNG, and sharing the same RNG between threads or processes will share the 
same seed and the same starting point.  This is probably not what one would 
want to do. By instantiating the B::R::S object after forking or creating 
threads, a unique randomness stream will be created per thread or process.
.SS "STRONG RANDOMNESS"
.IX Subsection "STRONG RANDOMNESS"
It's easy to generate weak pseudo-random bytes.  It's also easy to think you're
generating strong pseudo-random bytes when really you're not.  And it's hard to
test for pseudo-random cryptographic acceptable quality.  There are many high
quality random number generators that are suitable for statistical purposes,
but not necessarily up to the rigors of cryptographic use.
.PP
Assuring strong (ie, secure) random bytes in a way that works across a wide
variety of platforms is also challenging.  A primary goal for this module is to
provide cryptographically secure pseudo-random bytes.  A secondary goal is to
provide a simple user experience (thus reducing the propensity for getting it
wrong).  A tertiary goal is to minimize the dependencies required to achieve
the primary and secondary goals, to the extent that is practical.
.SS ISAAC
.IX Subsection "ISAAC"
The ISAAC algorithm is considered to be a cryptographically strong pseudo-random
number generator.  There are 1.0e2466 initial states.  The best known attack for
discovering initial state would theoretically take a complexity of
approximately 4.67e1240, which has no practical impact on ISAAC's security.
Cycles are guaranteed to have a minimum length of 2**40, with an average cycle
of 2**8295.  Because there is no practical attack capable of discovering
initial state, and because the average cycle is so long, it's generally
unnecessary to re-seed a running application.  The results are uniformly
distributed, unbiased, and unpredictable unless the seed is known.
.PP
To confirm the quality of the CSPRNG, this module's test suite implements the
FIPS\-140\-1 <http://csrc.nist.gov/publications/fips/fips1401.htm> tests for
strong random number generators.  See the comments in \f(CW\*(C`t/27\-fips140\-1.t\*(C'\fR for
details.
.SS DEPENDENCIES
.IX Subsection "DEPENDENCIES"
To keep the dependencies as light as possible this module uses some ideas from
Math::Random::Secure.  That module is an excellent resource, but implements
a broader range of functionality than is needed here.  So we just borrowed
from it.
.PP
The primary source of random data in this module comes from the excellent
Math::Random::ISAAC.  To be useful and secure, even Math::Random::ISAAC
needs a cryptographically sound seed, which we derive from
Crypt::Random::Seed.  There are no known weaknesses in the ISAAC algorithm.
And Crypt::Random::Seed does a very good job of preventing fall-back to weak
seed sources.
.PP
This module requires Perl 5.6 or newer.  The module also uses a number of core
modules, some of which require newer versions than those contemporary with 5.6.
Unicode support in \f(CW\*(C`random_string_from\*(C'\fR is best with Perl 5.8.9 or newer.
See the INSTALLATION section in this document for details.
.PP
If Test::Warn is installed, test coverage is 100%.  For those who don't want
to bother installing Test::Warn, you can just take our word for it.  It's an
optional installation dependency.
.SS "BLOCKING ENTROPY SOURCE"
.IX Subsection "BLOCKING ENTROPY SOURCE"
It is possible (and has been seen in testing) that the system's random
entropy source might not have enough entropy in reserve to generate the seed
requested by this module without blocking.  If you suspect that you're a victim
of blocking from reads on \f(CW\*(C`/dev/random\*(C'\fR, one option is to manipulate the
random seed configuration by using the object oriented interface.
.PP
This module seeds as lazily as possible so that using the module, and even
instantiating a Bytes::Random::Secure object will not trigger reads from
\&\f(CW\*(C`/dev/random\*(C'\fR.  Only the first time the object is used to deliver random bytes
will the RNG be seeded.  Long-running scripts may prefer to force early seeding
as close to start-up time as possible, rather than allowing it to happen later
in a program's run-time.  This can be achieved simply by invoking any of the
functions or methods that return a random byte.  As soon as a random byte is
requested for the first time, the CSPRNG will be seeded.
.SS "UNICODE SUPPORT"
.IX Subsection "UNICODE SUPPORT"
The \f(CW\*(C`random_string_from\*(C'\fR function, and \f(CW\*(C`string_from\*(C'\fR method permit the user
to pass a "bag" (or source) string containing Unicode characters.  For any
modern Perl version, this will work just as you would hope.  But some versions
of Perl older than 5.8.9 exhibited varying degrees of bugginess in their
handling of Unicode.  If you're depending on the Unicode features of this
module while using Perl versions older than 5.8.9 be sure to test thoroughly,
and don't be surprised when the outcome isn't as expected.  ...this is to be
expected.  Upgrade.
.PP
No other functions or methods in this module get anywhere near Perl's Unicode
features.  So as long as you're not passing Unicode source strings to
\&\f(CW\*(C`random_string_from\*(C'\fR, you have nothing to worry about, even if you're using
Perl 5.6.0.
.SS "MODULO BIAS"
.IX Subsection "MODULO BIAS"
Care is taken so that there is no modulo bias in the randomness returned
either by \f(CW\*(C`random_bytes\*(C'\fR or its siblings, nor by \f(CW\*(C`random_string_from\*(C'\fR.  As a
matter if fact, this is exactly \fIwhy\fR the \f(CW\*(C`random_string_from\*(C'\fR function is
useful.  However, the algorithm to eliminate modulo bias can impact the
performance of the \f(CW\*(C`random_string_from\*(C'\fR function. Any time the length of the
bag string is significantly less than the nearest greater or equal factor
of 2**32, performance will degrade.  Unfortunately there is no known algorithm
that improves upon this situation.  Fortunately, for sanely sized strings, it's
a minor issue.  To put it in perspective, even in the case of passing a "bag"
string of length 2**31 (which is huge), the expected time to return random
bytes will only double.  Given that the entire Unicode range is just over a
million possible code-points, it seems unlikely that the normal use case would
ever have to be concerned with the performance of the \f(CW\*(C`random_string_from\*(C'\fR
function.
.SH INSTALLATION
.IX Header "INSTALLATION"
This module should install without any fuss on modern versions of Perl.  For
older Perl versions (particularly 5.6 and early 5.8.x's), it may be necessary
to update your CPAN installer to a more modern version before installing this
this module.
.PP
Another alternative for those with old Perl versions who don't want to update
their CPAN installer (You must know you're crazy, right?): Review \f(CW\*(C`Makefile.PL\*(C'\fR
and assure that you've got the dependencies listed under \f(CW\*(C`PREREQ_PM\*(C'\fR and
\&\f(CW\*(C`BUILD_REQUIRES\*(C'\fR, in at least the minimum versions specified.  Then proceed as
usual.
.PP
This module only has two non-Core dependencies.  But it does expect that some
of the Core dependencies are newer than those supplied with 5.6 or early 5.8's.
If you keep your CPAN installer up-to-date, you shouldn't have to think about
this, as it will usually just "do the right thing", pulling in newer dependency
versions as directed by the module's META files.
.PP
Test coverage for Bytes::Random::Secure is 100% (per Devel::Cover) on any
system that has Test::Warn installed.  But to keep the module light-weight,
Test::Warn is not dragged in by default at installation time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Random::Secure and Crypt::Random provide strong CSPRINGs and even
more configuration options, but come with hefty toolchains.
.PP
Bytes::Random::Secure::Tiny is a stand-alone adaptation of
Bytes::Random::Secure with no dependencies. It will, however, detect if
Math::Random::ISAAC, Math::Random::ISAAC::XS, and Crypt::Random::Seed
are installed on the target system, and if they are, it quietly upgrades to
using them.
.SH AUTHOR
.IX Header "AUTHOR"
David Oswald \f(CW\*(C`<davido [at] cpan (dot) org>\*(C'\fR
.SH BUGS
.IX Header "BUGS"
Please report any bugs or feature requests to 
\&\f(CW\*(C`bug\-bytes\-random\-secure at rt.cpan.org\*(C'\fR, or through the web interface at 
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Bytes\-Random\-Secure>.  I will 
be notified, and then you'll automatically be notified of progress on your bug 
as I make changes.
.SH SUPPORT
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Bytes::Random::Secure
.Ve
.PP
You can also look for information at:
.IP \(bu 4
Github Repo: <https://github.com/daoswald/Bytes\-Random\-Secure>
.IP \(bu 4
RT: CPAN's request tracker (report bugs here)
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Bytes\-Random\-Secure>
.IP \(bu 4
AnnoCPAN: Annotated CPAN documentation
.Sp
<http://annocpan.org/dist/Bytes\-Random\-Secure>
.IP \(bu 4
CPAN Ratings
.Sp
<http://cpanratings.perl.org/d/Bytes\-Random\-Secure>
.IP \(bu 4
Search CPAN
.Sp
<http://search.cpan.org/dist/Bytes\-Random\-Secure/>
.SH ACKNOWLEDGEMENTS
.IX Header "ACKNOWLEDGEMENTS"
Dana Jacobsen ( \fI<dana@acm.org>\fR ) for his work that led to
Crypt::Random::Seed, thereby significantly reducing the dependencies while
improving the portability and backward compatibility of this module.  Also for
providing a patch to this module that greatly improved the performance
of \f(CW\*(C`random_bytes\*(C'\fR.
.PP
Dana Jacosen also provided extensive input, code reviews, and testing that 
helped to guide the direction this module has taken.  The code for the
FIPS\-140\-1 tests was taken directly from Crypt::Random::TESHA2.  Thanks!
.PP
Bytes::Random for implementing a nice, simple interface that this module
patterns itself after.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 David Oswald.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
