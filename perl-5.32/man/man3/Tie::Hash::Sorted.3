.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Sorted 3"
.TH Sorted 3 "2003-09-11" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::Hash::Sorted \- Presents hashes in sorted order
.SH "VERSION"
.IX Header "VERSION"
Version 0.07 released on 11 Sept 2003
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Tie::Hash::Sorted;
\&
\& my %ages = (
\&     \*(AqJohn\*(Aq   => 33,
\&     \*(AqJacob\*(Aq  => 29,
\&     \*(AqJingle\*(Aq => 15,
\&     \*(AqHeimer\*(Aq => 48,
\&     \*(AqSmitz\*(Aq  => 12,
\& );
\&
\& my $sort_by_numeric_value = sub {
\&     my $hash = shift;
\&     [ sort {$hash\->{$b} <=> $hash\->{$a}} keys %$hash ];
\& };
\&
\& tie my %sorted_ages, \*(AqTie::Hash::Sorted\*(Aq,
\&     \*(AqHash\*(Aq         => \e %ages,
\&     \*(AqSort_Routine\*(Aq => $sort_by_numeric_value;
\&
\& for my $name ( keys %sorted_ages ) {
\&     print "$name is $sorted_ages{$name} years old.\en";
\& }
\&
\& ### OUTPUT ###
\& Heimer is 48 ears old.
\& John is 33 ears old.
\& Jacob is 29 ears old.
\& Jingle is 15 ears old.
\& Smitz is 12 ears old.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module presents hashes in sorted order.
.SH "SYNTAX"
.IX Header "SYNTAX"
In order to \f(CW\*(C`tie()\*(C'\fR your hash to \f(CW\*(C`Tie::Hash::Sorted\*(C'\fR:
.PP
.Vb 1
\& tie HASH, \*(AqTie::Hash::Sorted\*(Aq, [OPTIONS => VALUE];
.Ve
.PP
or
.PP
.Vb 1
\& HASHREF = tie HASH, \*(AqTie::Hash::Sorted\*(Aq, [OPTIONS => VALUE];
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "Hash" 4
.IX Item "Hash"
If you do not want to start with an empty hash, you can specify a hash
reference
.IP "Sort_Routine" 4
.IX Item "Sort_Routine"
If you do not want to use the default sort routine, you can specify a code
reference. The sub is very flexible with the following two requirements. It
must accept a hash reference as its only argument and it must return an array
reference.
.Sp
The funtion is passed a reference to an unsorted hash and is expected to
return the correct order for the hash's keys.
.Sp
.Vb 4
\& sub {
\&     my $unsorted_hash = shift;
\&     return [ sort keys %$unsorted_hash ];
\& }
.Ve
.SS "Optimization"
.IX Subsection "Optimization"
There are four different kinds of optimization.
.IP "default" 4
.IX Item "default"
By default, the hash will remain sorted until a re-sort is required. Changes
will set a flag to re-sort the hash the next time it is iterated over.
.IP "none" 4
.IX Item "none"
This will cause the hash to be re-sorted once every time you iterate over the
hash. Use it if the sort routine depends on something that can't be detected
in the tied hash. Perhaps you have a hash of hashes (HoH) sorted by the
number of second level keys.
.Sp
Even if you fall into this category, you may be able to use the default
optimization. You can use \*(L"Resort\*(R" after any change you know the tied
hash can't detect.
.IP "keys" 4
.IX Item "keys"
This optimization works the same as the default except it will not set the
flag for re-sorting if the only change detected is to an already existing
value.
.IP "values" 4
.IX Item "values"
This optimization works the same as the default except it will not set the
flag for re-sorting if the new value is the same as the old value.
.SH "METHODS"
.IX Header "METHODS"
.SS "Sort_Routine"
.IX Subsection "Sort_Routine"
You can change the sort routine at any time. The change will take affect when
you iterate over the hash.
.PP
.Vb 6
\& tie my %sorted_hash, \*(AqTie::Hash::Sorted\*(Aq, \*(AqHash\*(Aq => \e%hash;
\& my $sort = sub {
\&     my $hash = shift;
\&     return [ sort { $a cmp $b || $a <=> $b } keys %$hash ];
\& };
\& tied( %sorted_hash ) \-> Sort_Routine( $sort );
.Ve
.SS "Optimization"
.IX Subsection "Optimization"
You can change the optimization promise at any time.
.PP
.Vb 6
\& tie my %sorted_hash, \*(AqTie::Hash::Sorted\*(Aq, \*(AqHash\*(Aq => \e%hash;
\& my $sort = sub {
\&     my $hash = shift;
\&     return [ sort { $a cmp $b || $a <=> $b } keys %$hash ];
\& };
\& tied( %sorted_hash ) \-> Optimization( \*(Aqkeys\*(Aq );
.Ve
.SS "Resort"
.IX Subsection "Resort"
This method sets the flags for re-sorting the next time you iterate over the
hash. It would typically only be used in with Optimization => 'none'. Call
this method after changes that you don't expect Tie::Hash::Sorted to be able
to notice.
.PP
.Vb 2
\& my @months = qw(January March April June August December);
\& my (%data, %order);
\&
\& @data{@months} = (33, 29, 15, 48, 23, 87);
\& @order{@months} = (1, 3, 4, 6, 8, 12);
\&
\& my $sort = sub {
\&     my $hash = shift;    
\&     return [ sort {$order{$a} <=> $order{$b}} keys %$hash ];
\& };
\&
\& tie my %sorted_data, \*(AqTie::Hash::Sorted\*(Aq, 
\&     \*(AqHash\*(Aq         => \e%data,
\&     \*(AqSort_Routine\*(Aq => $sort,
\&     \*(AqOptimization\*(Aq => \*(Aqnone\*(Aq;
\&
\& for my $month ( keys %sorted_data ) {
\&     print "$month had $sorted_data{$month} million sales.\en";
\& }
\& # More code that iterates over the hash
\& # Since there are no changes, you get the benefits of no re\-sorting
\&
\& @order{@months} = (12, 8, 6, 4, 3, 1);
\&
\& # Tie::Hash::Sorted doesn\*(Aqt know that %order just changed so we\*(Aqll force
\& # the issue.
\& tied( %sorted_data ) \-> Resort;
\&
\& for my $month ( keys %sorted_data ) {
\&     print "$month had $sorted_data{$month} million sales.\en";
\& }
.Ve
.SS "Count"
.IX Subsection "Count"
Current versions of perl (so far, 5.8.1 and below) implement
\&\f(CW\*(C`scalar keys %tied_hash\*(C'\fR poorly. Use the Count method instead to get the
number of elements in the hash.
.PP
.Vb 3
\& my %data = ( a=>1, b=>2, c=>3, d=>4 );
\& tie my %sorted_data, \*(AqTie::Hash::Sorted\*(Aq, \*(AqHash\*(Aq => \e%data;
\& print tied( %sorted_data ) \-> Count, "\en";
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Joshua Gatcomb, <Limbic_Region_2000@Yahoo.com>
.PP
Joshua Jore, <jjore@cpan.org>
.PP
Currently maintained by Joshua Gatcomb, <Limbic_Region_2000@Yahoo.com>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This module was inspired by Tie::SortHash.
.PP
Various people from PerlMonks (<http://www.perlmonks.org>) provided
invaluable input.
.SH "BUGS"
.IX Header "BUGS"
None known.  Bug reports, fixes, and feedback are desired.
.SH "CAVEATS"
.IX Header "CAVEATS"
As of this release, tied hashes always return 0 in scalar context and false
in boolean context. You might want to consider using \*(L"Count\*(R" as an
alternative.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\& Copyright (c) 2003 Joshua Gatcomb. All rights reserved.
\& This program is free software; you can redistribute it
\& and/or modify it under the same terms as Perl itself.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl(1), perltie
.PP
\&\s-1README\s0 for a comparison to Tie::IxHash and Tie::SortHash
