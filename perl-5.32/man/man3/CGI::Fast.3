.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CGI::Fast 3"
.TH CGI::Fast 3 "2019-03-29" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Fast \- CGI Interface for Fast CGI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use CGI::Fast
\&        socket_path  => \*(Aq9000\*(Aq,
\&        socket_perm  => 0777,
\&        listen_queue => 50;
\&
\&    use CGI qw/ :standard /;
\&
\&    $COUNTER = 0;
\&
\&    # optional, will default to STDOUT, STDERR
\&    CGI::Fast\->file_handles({
\&        fcgi_output_file_handle => IO::Handle\->new,
\&        fcgi_error_file_handle  => IO::Handle\->new,
\&    });
\&
\&    while ($q = CGI::Fast\->new) {
\&        process_request($q);
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CGI::Fast is a subclass of the \s-1CGI\s0 object created by \s-1CGI\s0.pm.  It is
specialized to work with the \s-1FCGI\s0 module, which greatly speeds up \s-1CGI\s0
scripts by turning them into persistently running server processes.
Scripts that perform time-consuming initialization processes, such as
loading large modules or opening persistent database connections, will
see large performance improvements.
.PP
Note that as CGI::Fast is based on \s-1CGI\s0.pm it is no longer advised as
a way to write Perl web apps. See <https://metacpan.org/pod/CGI#CGI.pm\-HAS\-BEEN\-REMOVED\-FROM\-THE\-PERL\-CORE>
for more information about this
.SH "OTHER PIECES OF THE PUZZLE"
.IX Header "OTHER PIECES OF THE PUZZLE"
In order to use CGI::Fast you'll need the \s-1FCGI\s0 module.  See
http://www.cpan.org/ for details.
.SH "WRITING FASTCGI PERL SCRIPTS"
.IX Header "WRITING FASTCGI PERL SCRIPTS"
FastCGI scripts are persistent: one or more copies of the script
are started up when the server initializes, and stay around until
the server exits or they die a natural death.  After performing
whatever one-time initialization it needs, the script enters a
loop waiting for incoming connections, processing the request, and
waiting some more.
.PP
A typical FastCGI script will look like this:
.PP
.Vb 6
\&    #!perl
\&    use CGI::Fast;
\&    do_some_initialization();
\&    while ($q = CGI::Fast\->new) {
\&        process_request($q);
\&    }
.Ve
.PP
Each time there's a new request, CGI::Fast returns a
\&\s-1CGI\s0 object to your loop.  The rest of the time your script
waits in the call to \fBnew()\fR.  When the server requests that
your script be terminated, \fBnew()\fR will return undef.  You can
of course exit earlier if you choose.  A new version of the
script will be respawned to take its place (this may be
necessary in order to avoid Perl memory leaks in long-running
scripts).
.PP
\&\s-1CGI\s0.pm's default \s-1CGI\s0 object mode also works.  Just modify the loop
this way:
.PP
.Vb 3
\&    while (CGI::Fast\->new) {
\&        process_request();
\&    }
.Ve
.PP
Calls to \fBheader()\fR, \fBstart_form()\fR, etc. will all operate on the
current request.
.SH "INSTALLING FASTCGI SCRIPTS"
.IX Header "INSTALLING FASTCGI SCRIPTS"
See the FastCGI developer's kit documentation for full details.  On
the Apache server, the following line must be added to srm.conf:
.PP
.Vb 1
\&    AddType application/x\-httpd\-fcgi .fcgi
.Ve
.PP
FastCGI scripts must end in the extension .fcgi.  For each script you
install, you must add something like the following to srm.conf:
.PP
.Vb 1
\&    FastCgiServer /usr/etc/httpd/fcgi\-bin/file_upload.fcgi \-processes 2
.Ve
.PP
This instructs Apache to launch two copies of file_upload.fcgi at
startup time.
.SH "USING FASTCGI SCRIPTS AS CGI SCRIPTS"
.IX Header "USING FASTCGI SCRIPTS AS CGI SCRIPTS"
Any script that works correctly as a FastCGI script will also work
correctly when installed as a vanilla \s-1CGI\s0 script.  However it will
not see any performance benefit.
.SH "EXTERNAL FASTCGI SERVER INVOCATION"
.IX Header "EXTERNAL FASTCGI SERVER INVOCATION"
FastCGI supports a \s-1TCP/IP\s0 transport mechanism which allows FastCGI scripts to run
external to the webserver, perhaps on a remote machine.  To configure the
webserver to connect to an external FastCGI server, you would add the following
to your srm.conf:
.PP
.Vb 1
\&    FastCgiExternalServer /usr/etc/httpd/fcgi\-bin/file_upload.fcgi \-host sputnik:8888
.Ve
.PP
Two environment variables affect how the \f(CW\*(C`CGI::Fast\*(C'\fR object is created,
allowing \f(CW\*(C`CGI::Fast\*(C'\fR to be used as an external FastCGI server. (See \f(CW\*(C`FCGI\*(C'\fR
documentation for \f(CW\*(C`FCGI::OpenSocket\*(C'\fR for more information.)
.PP
You can set these as \s-1ENV\s0 variables or imports in the use CGI::Fast statement.
If the \s-1ENV\s0 variables are set then these will be favoured so you can override
the import statements on the command line, etc.
.IP "\s-1FCGI_SOCKET_PATH /\s0 socket_path" 4
.IX Item "FCGI_SOCKET_PATH / socket_path"
The address (\s-1TCP/IP\s0) or path (\s-1UNIX\s0 Domain) of the socket the external FastCGI
script to which bind an listen for incoming connections from the web server.
.IP "\s-1FCGI_SOCKET_PERM /\s0 socket_perm" 4
.IX Item "FCGI_SOCKET_PERM / socket_perm"
Permissions for \s-1UNIX\s0 Domain socket.
.IP "\s-1FCGI_LISTEN_QUEUE /\s0 listen_queue" 4
.IX Item "FCGI_LISTEN_QUEUE / listen_queue"
Maximum length of the queue of pending connections, defaults to 100.
.PP
For example:
.PP
.Vb 4
\&    use CGI::Fast
\&        socket_path  => "sputnik:8888",
\&        listen_queue => "50"
\&    ;
\&
\&    use CGI qw/ :standard /;
\&
\&    do_some_initialization();
\&
\&    while ($q = CGI::Fast\->new) {
\&        process_request($q);
\&    }
.Ve
.PP
Or:
.PP
.Vb 2
\&    use CGI::Fast;
\&    use CGI qw/ :standard /;
\&
\&    do_some_initialization();
\&
\&    $ENV{FCGI_SOCKET_PATH} = "sputnik:8888";
\&    $ENV{FCGI_LISTEN_QUEUE} = 50;
\&
\&    while ($q = CGI::Fast\->new) {
\&        process_request($q);
\&    }
.Ve
.PP
Note the importance of having use \s-1CGI\s0 after use CGI::Fast as this will
prevent any \s-1CGI\s0 import pragmas being overwritten by CGI::Fast. You can
use CGI::Fast as a drop in replacement like so:
.PP
.Vb 1
\&    use CGI::Fast qw/ :standard /
.Ve
.SH "FILE HANDLES"
.IX Header "FILE HANDLES"
\&\s-1FCGI\s0 defaults to using \s-1STDOUT\s0 and \s-1STDERR\s0 as its output filehandles \- this
may lead to unexpected redirect of output if you migrate scripts from \s-1CGI\s0.pm
to CGI::Fast. To get around this you can use the file_handles method, which
you must do \fBbefore\fR the first call to CGI::Fast\->new. For example using
IO::Handle:
.PP
.Vb 4
\&    CGI::Fast\->file_handles({
\&        fcgi_output_file_handle => IO::Handle\->new,
\&        fcgi_error_file_handle  => IO::Handle\->new,
\&    });
\&
\&    while (CGI::Fast\->new) {
\&        ..
\&    }
.Ve
.PP
Overriding \s-1STDIN\s0 using the \f(CW\*(C`fcgi_input_file_handle\*(C'\fR key is also possible,
however doing so is likely to break at least \s-1POST\s0 requests.
.SH "CAVEATS"
.IX Header "CAVEATS"
I haven't tested this very much.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 1996\-1998, Lincoln D. Stein.  All rights reserved. Currently
maintained by Lee Johnson
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
Address bug reports and comments to:
.PP
.Vb 1
\&    https://github.com/leejo/cgi\-fast
.Ve
.SH "BUGS"
.IX Header "BUGS"
This section intentionally left blank.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CGI::Carp, \s-1CGI\s0
