.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::Perl::ECDSA 3"
.TH Crypt::Perl::ECDSA 3 "2020-09-27" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::Perl::ECDSA \- Elliptic curve cryptography in pure Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    my $pub_key1 = Crypt::Perl::ECDSA::Parse::public($pem_or_der);
\&    my $prv_key1 = Crypt::Perl::ECDSA::Parse::private($pem_or_der);
\&
\&    #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    my $prkey_by_name = Crypt::Perl::ECDSA::Generate::by_curve_name(\*(Aqsecp521r1\*(Aq);
\&
\&    #Probably only useful for trying out a custom curve?
\&    my $prkey_by_curve = Crypt::Perl::ECDSA::Generate::by_explicit_curve(
\&        {
\&            p => ..., #isa Crypt::Perl::BigInt
\&            a => ..., #isa Crypt::Perl::BigInt
\&            b => ..., #isa Crypt::Perl::BigInt
\&            n => ..., #isa Crypt::Perl::BigInt
\&
\&            # Supposedly this can be deduced from the above, but I don’t
\&            # see the math for this around. It’s not in libtomcryt, AFAICT.
\&            # It may have to do with Schoof’s Algorithm?
\&            h => ..., #isa Crypt::Perl::BigInt
\&
\&            gx => ..., #isa Crypt::Perl::BigInt
\&            gy => ..., #isa Crypt::Perl::BigInt
\&        },
\&    );
\&
\&    #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    my $msg = \*(AqMy message\*(Aq;
\&
\&    # Deterministic signatures. This is probably the way to go
\&    # for normal use cases. You can use sha1, sha224, sha256, sha384,
\&    # or sha512.
\&    my $det_sig = $private\->sign_sha256($msg);
\&
\&    my $msg_hash = Digest::SHA::sha256($msg);
\&
\&    # NB: This verifies a *digest*, not the original message.
\&    die \*(AqWut\*(Aq if !$public\->verify($msg_hash, $sig);
\&    die \*(AqWut\*(Aq if !$private\->verify($msg_hash, $sig);
\&
\&    # Signature in JSON Web Algorithm format (deterministic):
\&    my $jwa_sig = $private\->sign_jwa($msg);
\&
\&    # You can also create non\-deterministic signatures. These risk a
\&    # security compromise if there is any flaw in the underlying CSPRNG.
\&    # Note that this signs a *digest*, not the message itself.
\&    my $sig = $private\->sign($msg_hash);
\&
\&    #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $key\->to_der_with_curve_name();
\&    $key\->to_der_with_curve_name( compressed => 1 );
\&    $key\->to_pem_with_curve_name();
\&    $key\->to_pem_with_curve_name( compressed => 1 );
\&
\&    $key\->to_der_with_explicit_curve();
\&    $key\->to_der_with_explicit_curve( seed => 1 );
\&    $key\->to_der_with_explicit_curve( compressed => 1 );
\&    $key\->to_der_with_explicit_curve( seed => 1, compressed => 1 );
\&    $key\->to_pem_with_explicit_curve();
\&    $key\->to_pem_with_explicit_curve( seed => 1 );
\&    $key\->to_pem_with_explicit_curve( compressed => 1 );
\&    $key\->to_pem_with_explicit_curve( seed => 1, compressed => 1 );
.Ve
.SH "DISCUSSION"
.IX Header "DISCUSSION"
See the documentation for Crypt::Perl::ECDSA::PublicKey and
Crypt::Perl::ECDSA::PrivateKey for discussions of what these interfaces
can do.
.SH "SECURITY"
.IX Header "SECURITY"
The security advantages of elliptic-curve cryptography (\s-1ECC\s0) are a matter of
some controversy. While the math itself is apparently bulletproof, there are
varying opinions about the integrity of the various curves that are recommended
for \s-1ECC.\s0 Some believe that some curves contain backdoors that would allow
\&\s-1NIST\s0 <https://www.nist.gov> to sniff a transmission. For more information,
look at <http://safecurves.cr.yp.to>.
.PP
That said, \s-1RSA\s0 will eventually no longer be viable: as \s-1RSA\s0 keys get bigger, the
security advantage of increasing their size diminishes.
.PP
\&\f(CW\*(C`Crypt::Perl\*(C'\fR “has no opinion” regarding which curves you use; it ships all
of the prime-field curves that (OpenSSL <http://openssl.org>) includes and
works with any of them. You can try out custom curves as well.
.SS "Deterministic Signatures"
.IX Subsection "Deterministic Signatures"
This library can create deterministic signatures, as per
\&\s-1RFC 6979\s0 <https://tools.ietf.org/html/rfc6979>. Read that RFC’s
introduction to learn why this is a good idea.
.SH "FORMATS SUPPORTED"
.IX Header "FORMATS SUPPORTED"
Elliptic-curve keys can be in a variety of formats. This library supports
almost all of them:
.IP "Parse and export of named curves and explicit curves. (See below about explicit curve parameters.)" 4
.IX Item "Parse and export of named curves and explicit curves. (See below about explicit curve parameters.)"
.PD 0
.IP "Parse and export of curve points in compressed or uncompressed form, and parse of points in hybrid form. (\s-1NB:\s0 \s-1RFC 5480\s0 <https://www.rfc-editor.org/rfc/rfc5480.txt> prohibits use of the hybrid form.)" 4
.IX Item "Parse and export of curve points in compressed or uncompressed form, and parse of points in hybrid form. (NB: RFC 5480 <https://www.rfc-editor.org/rfc/rfc5480.txt> prohibits use of the hybrid form.)"
.PD
.PP
Explicit curves (i.e., giving the curve by full parameters rather than by
name reference) may be a known curve or an arbitrary curve.
Explicit curves may include or omit the seed value. It is omitted in output
by default. Explicit curves may also include or
omit the cofactor, but if the curve is unknown the cofactor is required.
This is because this library’s export of explicit curves always includes the
cofactor. While it’s not required for \s-1ECDSA,\s0 it’s recommended, and it’s
required for \s-1ECDH.\s0 Moreover, unlike the seed (which nither \s-1ECDSA\s0 nor \s-1ECDH\s0
requires), the cofactor is small enough that its inclusion only enlarges the
key by a few bytes.
.PP
I believe the cofactor can be deduced from the other curve parameters;
if someone wants to submit a \s-1PR\s0 to do this that would be nice.
.PP
Generator/base points will be exported as compressed or uncompressed
according to the public point. If for some reason you really need a
compressed base point but an uncompressed public point or vice-versa,
and you need this library to do it for you,
please explain your need for such a thing in your pull request. :\-)
.SH "TODO"
.IX Header "TODO"
Functionality can be augmented as feature requests come in.
Patches are welcome—particularly with tests!
.PP
In particular, it would be great to support characteristic-two curves,
though almost everything seems to expect the prime-field variety.
(OpenSSL is the only implementation I know of that
supports characteristic-two.)
.PP
It would also be nice to have logic that deduces the cofactor from the
other curve parameters.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Most of the \s-1ECDSA\s0 logic here is ported from Kenji Urushima’s
jsrsasign <http://kjur.github.io/jsrsasign/>.
.PP
Curve data is copied from OpenSSL. (See the script included in the
distribution.)
.PP
The point decompression logic is ported from LibTomCrypt <http://libtom.net>.
.PP
Deterministic \s-1ECDSA\s0 logic derived in part from
python-ecdsa <https://github.com/ecdsa/python-ecdsa>.
